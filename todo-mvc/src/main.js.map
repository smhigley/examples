{"version":3,"sources":["webpack:///src/main.js","webpack:///webpack/bootstrap 8faf4fb77a7b09923762","webpack:///./src/main.ts","webpack:///./src/widgets/createTodoItem.ts","webpack:///./src/widgets/createCheckboxInput.ts","webpack:///src/mixins/createVNodeEvented.ts","webpack:///node_modules/dojo-shim/Set.ts","webpack:///node_modules/dojo-shim/Symbol.ts","webpack:///node_modules/dojo-shim/support/util.ts","webpack:///node_modules/dojo-shim/support/global.ts","webpack:///node_modules/dojo-shim/support/has.ts","webpack:///node_modules/dojo-has/has.ts","webpack:///./~/process/browser.js","webpack:///node_modules/dojo-shim/iterator.ts","webpack:///node_modules/dojo-shim/string.ts","webpack:///node_modules/dojo-shim/support/decorators.ts","webpack:///node_modules/dojo-compose/mixins/createEvented.ts","webpack:///node_modules/dojo-compose/mixins/createDestroyable.ts","webpack:///node_modules/dojo-compose/compose.ts","webpack:///node_modules/dojo-compose/aspect.ts","webpack:///node_modules/dojo-shim/WeakMap.ts","webpack:///node_modules/dojo-shim/array.ts","webpack:///node_modules/dojo-shim/number.ts","webpack:///node_modules/dojo-core/lang.ts","webpack:///node_modules/dojo-core/has.ts","webpack:///node_modules/dojo-core/global.ts","webpack:///node_modules/dojo-shim/Promise.ts","webpack:///node_modules/dojo-shim/support/queue.ts","webpack:///./~/timers-browserify/main.js","webpack:///node_modules/dojo-shim/Map.ts","webpack:///node_modules/dojo-shim/object.ts","webpack:///node_modules/dojo-core/aspect.ts","webpack:///src/mixins/createFormFieldMixin.ts","webpack:///src/util/lang.ts","webpack:///./~/immutable/dist/immutable.js","webpack:///node_modules/dojo-compose/util/createCancelableEvent.ts","webpack:///node_modules/dojo-compose/mixins/createStateful.ts","webpack:///src/mixins/createRenderMixin.ts","webpack:///./~/maquette/dist/maquette.js","webpack:///./src/actions/userActions.ts","webpack:///./src/actions/todoStoreActions.ts","webpack:///./src/stores/todoStore.ts","webpack:///node_modules/dojo-stores/createMemoryStore.ts","webpack:///./~/@reactivex/rxjs/dist/amd/Observable.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/root.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/@reactivex/rxjs/dist/amd/symbol/observable.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/toSubscriber.js","webpack:///./~/@reactivex/rxjs/dist/amd/Subscriber.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/isFunction.js","webpack:///./~/@reactivex/rxjs/dist/amd/Subscription.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/isArray.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/isObject.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/tryCatch.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/errorObject.js","webpack:///./~/@reactivex/rxjs/dist/amd/util/UnsubscriptionError.js","webpack:///./~/@reactivex/rxjs/dist/amd/symbol/rxSubscriber.js","webpack:///./~/@reactivex/rxjs/dist/amd/Observer.js","webpack:///./src/actions/widgetStoreActions.ts","webpack:///./src/stores/widgetStore.ts","webpack:///node_modules/dojo-actions/createAction.ts","webpack:///node_modules/dojo-core/async/Task.ts","webpack:///node_modules/dojo-core/async/ExtensiblePromise.ts","webpack:///src/mixins/createStatefulChildrenMixin.ts","webpack:///./src/widgets/createFocusableTextInput.ts","webpack:///src/createButton.ts","webpack:///src/themes/structural/modules/Button.ts","webpack:///./src/widgets/createTodoFooter.ts","webpack:///./src/widgets/createTodoFilter.ts","webpack:///src/mixins/createParentMapMixin.ts","webpack:///./src/routes.ts","webpack:///node_modules/dojo-routing/history/createHashHistory.ts","webpack:///node_modules/dojo-core/on.ts","webpack:///node_modules/dojo-routing/createRouter.ts","webpack:///node_modules/dojo-core/UrlSearchParams.ts","webpack:///node_modules/dojo-routing/lib/path.ts","webpack:///node_modules/dojo-routing/createRoute.ts","webpack:///./src/widgets/createTodoList.ts","webpack:///src/mixins/createParentListMixin.ts","webpack:///src/createWidget.ts","webpack:///src/createPanel.ts","webpack:///src/mixins/createRenderableChildrenMixin.ts","webpack:///src/mixins/createCloseableMixin.ts","webpack:///node_modules/dojo-app/createApp.ts","webpack:///node_modules/dojo-app/lib/realizeCustomElements.ts","webpack:///node_modules/dojo-app/lib/parseJsonAttribute.ts","webpack:///node_modules/dojo-app/lib/makeIdGenerator.ts","webpack:///src/projector.ts","webpack:///node_modules/dojo-core/queue.ts","webpack:///node_modules/dojo-dom/dom.ts","webpack:///node_modules/dojo-dom/has.ts","webpack:///node_modules/dojo-app/lib/resolveListenersMap.ts","webpack:///node_modules/dojo-app/lib/moduleResolver.ts","webpack:///node_modules/dojo-app/lib/InstanceRegistry.ts","webpack:///node_modules/dojo-app/lib/factories.ts","webpack:///node_modules/dojo-app/lib/extractRegistrationElements.ts","webpack:///node_modules/dojo-app/lib/RegistryProvider.ts","webpack:///node_modules/dojo-core/IdentityRegistry.ts"],"names":["require","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift","0","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","v","createApp_1","global_1","Promise_1","createPanel_1","createWidget_1","userActions_1","routes_1","todoStore_1","widgetStore_1","createCheckboxInput_1","createFocusableTextInput_1","createTodoFooter_1","createTodoItem_1","createTodoList_1","app","default","defaultWidgetStore","registerStore","loadDefinition","widgets","listeners","keypress","todoInput","options","tagName","change","todoToggleAll","customElements","name","_a","Promise","resolve","realize","body","then","bindActions","start","manageChildren","childrenMap","get","this","checkbox","label","editInput","widget","setState","state","value","focused","editing","checked","completed","WeakMap_1","createButton_1","createRenderMixin_1","createStatefulChildrenMixin_1","maquette_1","createTodoItem","mixin","initialize","instance","destroyed","own","destroy","createChildren","classes","todoToggleComplete","do","button","click","todoRemove","dblclick","todoEdit","blur","event","todoSave","keyup","todoEditInput","children","set","on","catch","err","emit","target","error","extend","concat","getChildrenNodes","h","render","Object","defineProperty","createFormFieldMixin_1","createVNodeEvented_1","createCheckboxInput","nodeAttributes","handlesArraytoHandle","handles","forEach","handle","aspect_1","lang_1","createEvented_1","Set_1","vnodeEvents","UNINITIALIZED_LISTENERS","freeze","createVNodeEvented","assign","aspectAdvice","around","origFn","_this","args","_i","arguments","type_1","Array","isArray","map","listener","has","resolveListener","listenerMapArg_1","keys","TypeError","method","__decorate","decorators","key","desc","d","r","getOwnPropertyDescriptor","Reflect","decorate","decorators_1","iterator_1","Shim","Set","iterable","_setData","Symbol","toStringTag","forOf","add","prototype","clear","delete","idx","indexOf","splice","entries","ShimIterator","callbackfn","thisArg","iterator","values","result","next","done","enumerable","configurable","Error","hasClass","has_1","util_1","isSymbol","validateSymbol","InternalSymbol","defineProperties","create","objPrototype","globalSymbols","getSymbolName","created","postfix","String","getValueDescriptor","description","sym","__description__","__name__","keyFor","hasInstance","for","isConcatSpreadable","match","replace","search","species","split","toPrimitive","unscopables","constructor","toString","valueOf","Exposed","SymbolShim","wellKnown","writable","wrapNative","nativeFunction","globalObject","Function","__export","hasOwnProperty","has_2","fill","Number","POSITIVE_INFINITY","Math","acosh","clz32","imul","Map","WeakMap","key1","key2","setImmediate","postMessage","Boolean","MutationObserver","WebKitMutationObserver","global","process","isStaticFeatureFunction","load","resourceId","config","normalize","skip","term","tokens","exists","feature","staticCache","testCache","testFunctions","overwrite","globalScope","self","staticFeatures","DojoHasEnvironment","location","versions","node","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","array","noop","nextTick","title","browser","env","argv","version","addListener","once","off","removeListener","removeAllListeners","binding","cwd","chdir","dir","umask","isIterable","isArrayLike","doBreak","broken","l","char","code","charCodeAt","string_1","HIGH_SURROGATE_MIN","HIGH_SURROGATE_MAX","staticDone","list","_nextIndex","_nativeIterator","_list","LOW_SURROGATE_MIN","LOW_SURROGATE_MAX","normalizeSubstringArgs","text","position","isEnd","min","max","raw","callSite","substitutions","rawStrings","numSubstitutions","length_1","fromCodePoint","codePoints","fromCharCode","MAX_SIZE","codeUnits","index","codePoint","isValid","isFinite","floor","RangeError","highSurrogate","lowSurrogate","codePointAt","first","second","repeat","count","Infinity","startsWith","end","slice","endsWith","endPosition","includes","trueClass","falseClass","isActionable","Map_1","compose_1","createDestroyable_1","listenersMap","createEvented","listenerMap","className","isDestroyable","handlesWeakMap","createDestroyable","missingMethod","assignFactoryName","assignFunctionName","Symbol_1","fn","nameDescriptor","assignProperties","sources","source","getOwnPropertyNames","reduce","descriptors","sourceDescriptor","sourceValue","targetDescriptor","targetValue","current","array_1","from","objectCreate","rebase","getInitFunctionNames","initFns","privateFactoryData","factoryDescriptor","assignAdviceMap","createPrivateFactoryData","optionsAdvice","advice","factories","initFunction","proto","staticProperties","factoryData","base","optionsInitFns","initFn","createFactory","SyntaxError","unshift","factoryPrototype","_loop_1","aspect","sourceMethod","before","after","staticMethods","DEFAULT_FACTORY_LABEL","isComposeFactory","extension","overlay","overlayFunction","aspectAdviceToAdviceMap","mapAdvice","adviceTuple","adviceMap","beforeAdvice","afterAdvice","aroundAdvice","objectKeys","isComposeMixinable","toMixin","mixinDescriptor","doFrom","doBefore","doAfter","doAround","_static","doExtend","doMixin","doOverlay","doAspect","doStatic","doFactoryDescriptor","static","compose","getDispatcher","joinPoint","dispatcher","dispatchAdviceMap","previousArgs","currentArgs","previousResult","before_1","after_1","advise","AdviceType","Around","Before","After","getUID","random","DELETED","generateName","startId","Date","now","_frozenEntries","_getFrozenEntryIndex","entry","_name","frozenIndex","isFrozen","toLength","isNaN","number_1","MAX_SAFE_INTEGER","toInteger","abs","normalizeOffset","arrayLike","mapFunction","bind","Constructor","of","items","copyWithin","offset","direction","find","findIndex","searchElement","fromIndex","currentElement","isInteger","isSafeInteger","EPSILON","pow","MIN_SAFE_INTEGER","shouldDeepCopyObject","copyArray","inherited","item","_mixin","deep","kwArgs","mixins","deepAssign","deepMixin","duplicate","getPrototypeOf","isIdentical","a","b","lateBind","suppliedArgs","partial","targetFunction","createHandle","destructor","createCompositeHandle","handles_1","requestAnimationFrame","ArrayBuffer","FormData","XMLHttpRequest","request","open","responseType","abort","queue_1","isThenable","executor","isChained","isResolved","whenFinished","settle","newState","resolvedValue","queueMicroTask","onFulfilled","onRejected","reject","all","fulfill","complete","finish","populating","total","processItem","race","reason","clearImmediate","executeTask","isActive","getQueueHandle","microTasks","microTaskQueued","checkMicroTaskQueue","queueTask","enqueue","addEventListener","data","stopPropagation","HostMutationObserver","node_1","queue_2","observer","observe","attributes","setAttribute","Timeout","clearFn","_id","_clearFn","immediateIds","nextImmediateId","setInterval","clearInterval","close","unref","ref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","object_1","_keys","_values","_indexOfKey","is","context","length_2","value1","value2","getOwnPropertySymbols","o","filter","substring","isMapLike","receiveArguments","previous","advised","nextId","_b","_c","methodName","existing","results","executionId","newResults","createStateful_1","createCancelableEvent_1","lang_2","createFormMixin","valueToString","event_1","oldValue","defaultPrevented","stringToValue","disabled","getIndex","reference","size","insertInList","insert","insertInArray","valueReplacer","RegExp","valueReviver","regExpStr","regExp","flags","JSON","stringify","str","parse","test","isList","immutable_1","List","isChild","getRemoveHandle","parent","child","getDestroyHandle","lastIndexOf","keyOf","handle_1","handles_2","createClass","ctor","superClass","Iterable","Seq","KeyedIterable","isKeyed","KeyedSeq","IndexedIterable","isIndexed","IndexedSeq","SetIterable","isAssociative","SetSeq","maybeIterable","IS_ITERABLE_SENTINEL","maybeKeyed","IS_KEYED_SENTINEL","maybeIndexed","IS_INDEXED_SENTINEL","maybeAssociative","isOrdered","maybeOrdered","IS_ORDERED_SENTINEL","MakeRef","SetRef","OwnerID","arrCopy","arr","newArr","ii","ensureSize","iter","__iterate","returnTrue","wrapIndex","uint32Index","NaN","wholeSlice","begin","resolveBegin","resolveIndex","resolveEnd","defaultIndex","Iterator","iteratorValue","k","iteratorResult","iteratorDone","hasIterator","getIteratorFn","isIterator","maybeIterator","getIterator","iteratorFn","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","emptySequence","toSeq","seqFromValue","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","entrySeq","toIndexedSeq","indexedSeqFromValue","toSetSeq","ArraySeq","_array","ObjectSeq","object","_object","IterableSeq","_iterable","IteratorSeq","_iterator","_iteratorCache","isSeq","maybeSeq","IS_SEQ_SENTINEL","EMPTY_SEQ","seq","maybeIndexedSeqFromValue","seqIterate","reverse","useKeys","cache","_cache","maxIndex","__iterateUncached","seqIterator","__iteratorUncached","fromJS","json","converter","fromJSWith","","fromJSDefault","parentJSON","isPlainObj","toList","toMap","valueA","valueB","equals","deepEqual","__hash","notAssociative","every","flipped","cacheResult","_","allEqual","bSize","NOT_SET","Repeat","times","_value","EMPTY_REPEAT","invariant","condition","Range","step","_start","_end","_step","ceil","EMPTY_RANGE","Collection","KeyedCollection","IndexedCollection","SetCollection","smi","i32","hash","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashCode","hashJSObj","string","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","obj","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","isExtensible","nodeType","uniqueID","documentElement","assertNotInfinite","emptyMap","isMap","withMutations","maybeMap","IS_MAP_SENTINEL","ArrayMapNode","ownerID","BitmapIndexedNode","bitmap","nodes","HashArrayMapNode","HashCollisionNode","keyHash","ValueNode","MapIterator","_type","_reverse","_stack","_root","mapIteratorFrame","mapIteratorValue","prev","__prev","makeMap","root","MapPrototype","__ownerID","__altered","EMPTY_MAP","updateMap","newRoot","newSize","didChangeSize","CHANGE_LENGTH","didAlter","DID_ALTER","updateNode","update","isLeafNode","mergeIntoNode","newNode","idx1","MASK","idx2","SHIFT","createNodes","packNodes","excluding","packedII","packedNodes","bit","expandNodes","including","expandedNodes","SIZE","mergeIntoMapWith","merger","iterables","iters","mergeIntoCollectionWith","deepMerger","mergeDeep","deepMergerWith","mergeDeepWith","nextValue","collection","x","mergeIntoMap","updateInDeepMap","keyPathIter","notSetValue","updater","isNotSet","existingValue","newValue","nextExisting","nextUpdated","remove","popCount","setIn","val","canEdit","newArray","spliceIn","newLen","spliceOut","pop","empty","emptyList","makeList","VNode","toArray","setSize","maybeList","IS_LIST_SENTINEL","iterateList","iterateNodeOrLeaf","level","iterateLeaf","iterateNode","tailPos","tail","left","to","right","DONE","_origin","_capacity","getTailOffset","_tail","_level","origin","capacity","ListPrototype","EMPTY_LIST","updateList","setListBounds","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","editableVNode","listNodeFor","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","removeAfter","removeBefore","beginIndex","mergeIntoListWith","maxSize","OrderedMap","emptyOrderedMap","isOrderedMap","maybeOrderedMap","makeOrderedMap","omap","_map","EMPTY_ORDERED_MAP","updateOrderedMap","newMap","newList","flip","ToKeyedSequence","indexed","_iter","_useKeys","ToIndexedSequence","ToSetSequence","FromEntriesSequence","flipFactory","flipSequence","makeSequence","reversedSequence","cacheResultThrough","this$0","ITERATE_ENTRIES","__iterator","ITERATE_VALUES","ITERATE_KEYS","mapFactory","mapper","mappedSequence","reverseFactory","filterFactory","predicate","filterSequence","iterations","countByFactory","grouper","groups","asMutable","asImmutable","groupByFactory","isKeyedIter","coerce","iterableClass","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","sliceSize","resolvedSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","isKeyedIterable","singleton","concatSeq","flatten","sum","flattenFactory","depth","flatSequence","flatDeep","currentDepth","stopped","stack","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","comparator","defaultComparator","sort","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipSequence","iterators","isDone","steps","some","s","validateEntry","resolveSize","forceIterator","keyPath","Record","defaultValues","hasInitialized","RecordType","setProps","RecordTypePrototype","_defaultValues","RecordPrototype","makeRecord","likeRecord","record","recordName","names","setProp","emptySet","isSet","maybeSet","IS_SET_SENTINEL","updateSet","__empty","__make","makeSet","SetPrototype","EMPTY_SET","OrderedSet","emptyOrderedSet","isOrderedSet","maybeOrderedSet","makeOrderedSet","OrderedSetPrototype","EMPTY_ORDERED_SET","Stack","emptyStack","isStack","unshiftAll","maybeStack","IS_STACK_SENTINEL","makeStack","StackPrototype","_head","EMPTY_STACK","methods","keyCopier","keyMapper","entryMapper","not","neg","quoteString","defaultZipper","defaultNegComparator","hashIterable","ordered","keyed","hashMerge","murmurHashOfSize","SLICE$0","Keyed","Indexed","DELETE","ITERATOR_SYMBOL","KEYS","VALUES","ENTRIES","inspect","toSource","__toString","searchValue","other","possibleIndex","offsetValue","keyValues","updateIn","deleteIn","updatedValue","merge","mergeWith","mergeIn","mergeDeepIn","sortBy","mutable","wasAltered","__ensureOwner","iterate","removeIn","removed","MAX_ARRAY_MAP_SIZE","isEditable","newEntries","keyHashFrag","MAX_BITMAP_INDEXED_SIZE","newBitmap","newNodes","newCount","MIN_HASH_ARRAY_MAP_SIZE","keyMatch","subNode","oldSize","originIndex","newChild","removingFirst","oldChild","editable","sizeIndex","valueSeq","indexedIterable","defaultVal","_empty","fromKeys","keySeq","union","intersect","originalSet","subtract","peek","pushAll","toJS","__toJS","toJSON","toObject","toOrderedMap","toOrderedSet","toSet","toStack","__toStringMapper","join","returnValue","findEntry","sideEffect","joined","isFirst","reducer","initialReduction","reduction","useFirst","reduceRight","reversed","butLast","isEmpty","countBy","entriesSequence","filterNot","found","findKey","findLast","findLastEntry","findLastKey","flatMap","searchKey","getIn","searchKeyPath","nested","groupBy","hasIn","isSubset","isSuperset","last","lastKeyOf","maxBy","minBy","rest","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","IterablePrototype","chain","contains","mapEntries","mapKeys","KeyedIterablePrototype","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","zipWith","Immutable","createCancelableEvent","cancelable","preventDefault","unobserve","stateful","observedState","observedStateMap","statecomplete","setStatefulState","stateWeakMap","createStateful","observable","patch","observeState","subscription","subscribe","unsubscribe","stateFrom","generateID","cachedRender","createRenderMixin","idBase","cachedRenderCount","dirtyMap","renderCache","widgetClassesMap","getNodeAttributes","overrides","props","newProps","getSelectorAndWidgetClasses","selectorAndClasses","invalidate","baseIdProp","data-widget-id","styles","widgetClasses","cached","append","createDom","updateDom","NAMESPACE_W3","NAMESPACE_SVG","NAMESPACE_XLINK","emptyArray","same","vnode1","vnode2","vnodeSelector","properties","toTextVNode","domNode","appendChildren","parentSelector","insertions","main","missingTransition","DEFAULT_PROJECTION_OPTIONS","namespace","eventHandlerInterceptor","styleApplyer","styleName","style","transitions","enter","exit","applyDefaultProjectionOptions","projectorOptions","checkStyleValue","styleValue","setProperties","projectionOptions","propNames","propCount","propName","propValue","token","classList","classNames","classNameCount","j","styleNames","styleCount","oldPropValue","evt","setAttributeNS","updateProperties","previousProperties","propertiesUpdated","previousValue","previousOn","newStyleValue","oldStyleValue","findIndexOfChild","sameAs","nodeAdded","vNode","enterAnimation","nodeToRemove","exitAnimation","pointerEvents","removeDomNode","parentNode","removeChild","checkDistinguishable","childNodes","indexToCheck","parentVNode","operation","childNode","updateChildren","vnode","oldChildren","newChildren","oldChildrenLength","newChildrenLength","oldIndex","newIndex","textUpdated","findOldIndex","addChildren","initPropertiesAndChildren","textContent","afterCreate","insertBefore","createTextNode","charAt","createElementNS","updated","newVNode","replaceChild","firstChild","afterUpdate","updateAnimation","createProjection","updatedVnode","selector","childIndex","argsLength","onlyChild","dom","beforeNode","element","createCache","cachedInputs","cachedOutcome","inputs","calculation","createMapping","getSourceKey","createResult","updateResult","newSources","newKeys","oldTargets","sourceKey","searchIndex","createProjector","projector","propertyName","eventHandler","scheduleRender","scheduled","renderCompleted","projections","renderFunctions","doRender","renderNow","stop","cancelAnimationFrame","resume","renderMaquetteFunction","detach","createAction_1","todoStoreActions_1","keyCode","addTodo","updateTodo","deleteTodo","activeFilter","toggleAll","clearCompleted","deleteCompleted","promises","todoStore","changeRecord","widgetStoreActions_1","updateHeaderAndFooter","puts","deletes","putTodo","createMemoryStore_1","wrapResult","store","storeMethods","wrapError","Observable_1","dataWeakMap","itemObserverWeakMap","storeObserverWeakMap","createMemoryStore","idProperty","Observable","observers","observerArray","payload","beforeAll","afterAll","put","storeObservers","afterData","payload_1","completeObservable","completeStoreObservers","payload_2","fromArray","root_1","observable_1","toSubscriber_1","_isScalar","_subscribe","lift","operator","observerOrNext","sink","toSubscriber","syncErrorThrowable","syncErrorThrown","syncErrorValue","PromiseCtor","Rx","subscriber","$$observable","objectTypes","boolean","function","number","freeGlobal","webpackPolyfill","deprecate","paths","Subscriber_1","rxSubscriber_1","nextOrObserver","Subscriber","$$rxSubscriber","__extends","__","isFunction_1","Subscription_1","Observer_1","_super","destinationOrNext","isStopped","destination","SafeSubscriber","_next","_error","_complete","isUnsubscribed","Subscription","_parent","isFunction","_context","__tryOrSetError","__tryOrUnsub","_unsubscribe","isArray_1","isObject_1","tryCatch_1","errorObject_1","UnsubscriptionError_1","errors","hasErrors","_subscriptions","trial","tryCatch","errorObject","sub","isObject","UnsubscriptionError","teardown","EMPTY","subscriptions","subscriptionIndex","tryCatcher","tryCatchTarget","message","completedCount","activeCount","hidden","allCompleted","deletedId_1","placeholder","isAction","Task_1","doFunctions","configureFunctions","createAction","doFn","enabled","isTask","enable","disable","configure","configuration","configureFn","cancel","ExtensiblePromise_1","Task","canceler","_state","_cancel","finallyTask","runFinally","_finally","finally","task","unwrapPromises","unwrapped","ExtensiblePromise","_promise","handler","rejected","valueOrError","internalState","managementMap","currentChildrenIDs","generation","resolvingWidgets","childrenList","childrenIsList","widgetPromise","registry","promise","manageChildrenState","evtChildren","identify","storedChildren","isCreateChildrenMap","createStatefulChildrenMixin","management_1","registry_1","id_1","labels_1","childrenUID","instances","createChild","tuple","registryProvider","focus","activeElement","afterUpdateFunctions","createFocusableTextInput","Button_1","createButton","filterWidget","buttonWidget","clearCompletedButtonClasses","createParentMapMixin_1","createTodoFilter_1","createTodoFooter","clearCompletedButton","countLabel","class","createTodoFilter","innerHTML","href","selected","getChildKey","mapChildArray","childMap","keyCount","createParentMapMixin","createRoute_1","createRouter_1","createHashHistory_1","filterRoute","path","params","exec","router","history","on_1","privateStateMap","createHashHistory","prefix","privateState","browserLocation","pathname","dispatchEvent","ownerDocument","createEvent","nativeEvent","initEvent","bubbles","capture","removeEventListener","pausable","paused","pause","hasBeenAppended","route","parentMap","createDeferral","reportError","catchRejection","thenable","UrlSearchParams_1","path_1","createRouter","routes","add_1","dispatch","dispatchFromStart","canceled","deferrals","defer","success","searchParams","segments","trailingSlash","redirect","fallback","dispatched","select","currentSelection","result_1","link","roots","hierarchy","parent_1","addLeadingSlash","leadingSlash","addTrailingSlash","currentPathValues","currentSearchParams","selection","rawPathValues","rawSearchParams","expectedSegments","searchParameters","namedOffset","expectedSegments_1","segment","isNamedSegment","literal","searchParameters_1","value_1","_d","_e","dispatchCurrent","started","contextFactory","lastDispatch","redirectCount","redirecting","sharedContext_1","parseQueryString","input","query","indexOfFirstEquals","decodeURIComponent","UrlSearchParams","getAll","encodedKey","encodeURIComponent","values_1","pathnameTokens","searchStart","hashStart","t","hasRemaining","isMatch","expected","deconstruct","parameters","consume","inSearchComponent","name_1","closing","next_1","computeDefaultParams","fromPathname","createRoute","hasTrailingSlash","computeParams","trailingSlashMustMatch","knownSearchParams","guard","matchResult","guardResult","remainingSelection","remainingSegments_1","nestedResult","deconstructedPath","filterCompleted","filterActive","createParentListMixin_1","createTodoList","filteredChildren","createParentMixin","createWidget","createCloseableMixin_1","createRenderableChildrenMixin_1","createPanel","createRenderableChildrenMixin","results_1","createCloseableMixin","closeable","addIdentifier","identifiers","createCustomWidget","factoryHandle","customElementFactories","widgetFactories","widgetInstances","hasRegisteredFactory","hasRegisteredInstance","customFactory","registerWidgetFactory","getWidget","registerInstance","instanceRegistry","instanceHandle","addWidget","idHandle","register","IdentityRegistry_1","extractRegistrationElements_1","factories_1","InstanceRegistry_1","makeIdGenerator_1","moduleResolver_1","realizeCustomElements_1","RegistryProvider_1","RegistryProvider","DEFAULT_ACTION_STORE","DEFAULT_WIDGET_STORE","generateWidgetId","createApp","defaultActionStore","storeFactories","addStore","registerAction","action","actionFactories","addAction","registryHandle","registerActionFactory","registerCustomElementFactory","isValidName","wrapped","normalizeName","registerStoreFactory","registerWidget","actions","stores","resolveMid","actions_1","definition","makeActionFactory","customElements_1","makeCustomElementFactory","stores_1","makeStoreFactory","widgets_1","makeWidgetFactory","defaultStores","definitionHandle","realizationHandle","getAction","hasAction","identifyAction","getCustomElementFactory","hasCustomElementFactory","getStore","hasStore","identifyStore","missingFactory","hasWidget","identifyWidget","toAbsMid","reservedNames","toLowerCase","isCustomElement","getCustomElementsByWidgetProjector","allElements","allElements_1","attrIs","getAttribute","widgetProjectors","inverseStack","discardFirstNode","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","custom","getIdFromAttributes","resolveListeners","parseJsonAttribute_1","valid","check","eventType","identifier","resolveListenersMap_1","resolveOptions","idFromAttributes","getTransitionOptionFromProjector","hasAttribute","resolveStateFromAttribute","getInitialState","realizeCustomElements","appendQueue","immediatePlaceholderLookup","projectors","managedWidgets","loadedWidgets","widgetProjectors_1","cssTransitions","projector_1","projectorStateFrom","processing","isWidgetInstance","_factory","_listeners","_options","_store","projectorStore","initialState","generateId","appendQueue_1","widgets_2","attachedProjectors","immediatePlaceholders","immediatePlaceholders_1","dom_1","place","Position","Replace","attach","projectors_1","managedWidgets_1","w","parseJsonAttribute","makeIdGenerator","ProjectorState","projectorDataMap","noopHandle","emptyVNode","noopVNode","projectorData","childVNodes","afterInitialCreate","Attached","attachPromise","boundRender","attachHandle","Detached","setRoot","autoAttach","createStubbedProjector","defaultProjector","isMicroTaskQueued_1","queueAnimationTask","rafId","validateToken","addClass","targetElement","newClasses","classes_1","containsClass","applyFeatureClass","features","features_1","byId","getElementById","DOCUMENT_POSITION_CONTAINS","targetClass","fromString","html","unwrapElement","levels","fragment","useContextualFragment","master","tag","display","range","createRange","selectNode","tagWrap","wrap","wrappedHTML","pre","post","createContextualFragment","createDocumentFragment","relativeElement","ReferenceError","lastChild","nextSibling","FirstIn","removeClass","oldClasses","classes_2","toggleClass","force","func","children_1","property","attribute","caption","col","colgroup","optgroup","option","rp","rt","rtc","tbody","td","tfoot","th","thead","tr","param","tw","matches","msMatchesSelector","webkitMatchesSelector","carriesValue","withoutPromises","mixed","containsPromises","ref_1","flattened_1","resolveListenersMap","eventTypes","makeResolver","mid","member","__WEBPACK_AMD_REQUIRE_ARRAY__","__esModule","RESOLVE_CONTENTS","contents","member_1","Type","errorStrings","Action","Store","Widget","InstanceRegistry","expectedType","resolveStore","isInstance","resolveFactory","factory_1","defaultExport","rawOptions","customElement","isFactoryResolver","resolver","getRegistrationTasks","tasks","TAG_NAMES","parsers","createActionDefinition","importName","loadMultipleActions","createCustomElementDefinition","createStoreDefinition","createWidgetDefinition","extractRegistrationElements","isDefault","stateJson","optionsJson","listenersJson","underlyingRegistry","actionRegistry","storeRegistry","widgetRegistry","getState","IdentityRegistry","entryMap","idMap","existingEntry","existingId"],"mappings":"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","file":"src/main.js","sourcesContent":["require = function () {};\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({}[chunkId]||chunkId) + \".js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(4);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(85), __webpack_require__(27), __webpack_require__(28), __webpack_require__(82), __webpack_require__(81), __webpack_require__(41), __webpack_require__(72), __webpack_require__(43), __webpack_require__(61), __webpack_require__(6), __webpack_require__(66), __webpack_require__(69), __webpack_require__(5), __webpack_require__(79)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createApp_1 = __webpack_require__(85);\n\t    var global_1 = __webpack_require__(27);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var createPanel_1 = __webpack_require__(82);\n\t    var createWidget_1 = __webpack_require__(81);\n\t    var userActions_1 = __webpack_require__(41);\n\t    var routes_1 = __webpack_require__(72);\n\t    var todoStore_1 = __webpack_require__(43);\n\t    var widgetStore_1 = __webpack_require__(61);\n\t    var createCheckboxInput_1 = __webpack_require__(6);\n\t    var createFocusableTextInput_1 = __webpack_require__(66);\n\t    var createTodoFooter_1 = __webpack_require__(69);\n\t    var createTodoItem_1 = __webpack_require__(5);\n\t    var createTodoList_1 = __webpack_require__(79);\n\t    var app = createApp_1.default({ defaultWidgetStore: widgetStore_1.default });\n\t    app.registerStore('todo-store', todoStore_1.default);\n\t    app.loadDefinition({\n\t        widgets: [\n\t            {\n\t                id: 'new-todo',\n\t                factory: createFocusableTextInput_1.default,\n\t                listeners: {\n\t                    keypress: userActions_1.todoInput\n\t                }\n\t            },\n\t            {\n\t                id: 'main-section',\n\t                factory: createPanel_1.default,\n\t                options: {\n\t                    tagName: 'section'\n\t                }\n\t            },\n\t            {\n\t                id: 'todo-list',\n\t                factory: createTodoList_1.default\n\t            },\n\t            {\n\t                id: 'todo-toggle',\n\t                factory: createCheckboxInput_1.default,\n\t                listeners: {\n\t                    change: userActions_1.todoToggleAll\n\t                }\n\t            },\n\t            {\n\t                id: 'todo-footer',\n\t                factory: createTodoFooter_1.default\n\t            }\n\t        ],\n\t        customElements: [\n\t            {\n\t                name: 'dojo-widget',\n\t                factory: createWidget_1.default\n\t            },\n\t            {\n\t                name: 'todo-item',\n\t                factory: createTodoItem_1.default\n\t            }\n\t        ]\n\t    });\n\t    // Try to use the native promise so the browser can report unhandled rejections.\n\t    var _a = global_1.default.Promise, Promise /* tslint:enable */ = _a === void 0 ? Promise_1.default : _a;\n\t    Promise.resolve(app.realize(document.body))\n\t        .then(function () { return todoStore_1.bindActions(); })\n\t        .then(function () { return routes_1.default.start(); });\n\t});\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(22), __webpack_require__(67), __webpack_require__(39), __webpack_require__(65), __webpack_require__(40), __webpack_require__(41), __webpack_require__(6), __webpack_require__(66)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var createButton_1 = __webpack_require__(67);\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createStatefulChildrenMixin_1 = __webpack_require__(65);\n\t    var maquette_1 = __webpack_require__(40);\n\t    var userActions_1 = __webpack_require__(41);\n\t    var createCheckboxInput_1 = __webpack_require__(6);\n\t    var createFocusableTextInput_1 = __webpack_require__(66);\n\t    /**\n\t     * Internal map of sub children IDs\n\t     */\n\t    var childrenMap = new WeakMap_1.default();\n\t    /**\n\t     * Internal function to manage the children widgets\n\t     */\n\t    function manageChildren() {\n\t        /* Obtain references to children widgets */\n\t        var _a = childrenMap.get(this), checkbox = _a.checkbox, label = _a.label, editInput = _a.editInput;\n\t        /* Adjust the state of the children to reflect parent */\n\t        label.widget.setState({\n\t            label: this.state.label\n\t        });\n\t        editInput.widget.setState({\n\t            value: this.state.label,\n\t            focused: this.state.editing\n\t        });\n\t        checkbox.widget.setState({\n\t            checked: this.state.completed\n\t        });\n\t    }\n\t    var createTodoItem = createRenderMixin_1.default\n\t        .mixin({\n\t        mixin: createStatefulChildrenMixin_1.default,\n\t        initialize: function (instance, options) {\n\t            var destroyed = false;\n\t            instance.own({\n\t                destroy: function () {\n\t                    destroyed = true;\n\t                }\n\t            });\n\t            return instance.createChildren({\n\t                checkbox: {\n\t                    factory: createCheckboxInput_1.default,\n\t                    options: {\n\t                        state: {\n\t                            classes: ['toggle']\n\t                        },\n\t                        listeners: {\n\t                            change: function () { userActions_1.todoToggleComplete.do(instance.state); }\n\t                        }\n\t                    }\n\t                },\n\t                button: {\n\t                    factory: createButton_1.default,\n\t                    options: {\n\t                        state: {\n\t                            classes: ['destroy']\n\t                        },\n\t                        listeners: {\n\t                            click: function () { userActions_1.todoRemove.do(instance.state); }\n\t                        }\n\t                    }\n\t                },\n\t                label: {\n\t                    factory: createRenderMixin_1.default,\n\t                    options: {\n\t                        listeners: {\n\t                            dblclick: function () { userActions_1.todoEdit.do(instance.state); }\n\t                        },\n\t                        tagName: 'label'\n\t                    }\n\t                },\n\t                editInput: {\n\t                    factory: createFocusableTextInput_1.default,\n\t                    options: {\n\t                        state: {\n\t                            classes: ['edit']\n\t                        },\n\t                        listeners: {\n\t                            blur: function (event) { userActions_1.todoSave.do({ state: instance.state, event: event }); },\n\t                            keyup: function (event) { userActions_1.todoEditInput.do({ state: instance.state, event: event }); }\n\t                        }\n\t                    }\n\t                }\n\t            })\n\t                .then(function (children) {\n\t                if (destroyed) {\n\t                    return;\n\t                }\n\t                /* TODO: We are only using the label.widget but we are storing label: { id, widget }, is\n\t                    * that necessary? */\n\t                childrenMap.set(instance, children);\n\t                instance.on('statechange', manageChildren);\n\t                /* We have missed the widgets initial state change because we created the widgets async\n\t                    * so we should set state on the instance, so it will re-calculate its children */\n\t                instance.setState({});\n\t            })\n\t                .catch(function (err) {\n\t                instance.emit({\n\t                    type: 'error',\n\t                    target: instance,\n\t                    error: err\n\t                });\n\t            });\n\t        }\n\t    })\n\t        .extend({\n\t        get classes() {\n\t            /* TODO: Deal with this in nodeAttributes when class classes are implementend */\n\t            var classes = [];\n\t            if (this.state.editing) {\n\t                classes.push('editing');\n\t            }\n\t            return this.state.completed ? ['completed'].concat(classes) : classes;\n\t        },\n\t        getChildrenNodes: function () {\n\t            var _a = childrenMap.get(this), checkbox = _a.checkbox, label = _a.label, button = _a.button, editInput = _a.editInput;\n\t            return [\n\t                maquette_1.h('div.view', [\n\t                    checkbox.widget.render(),\n\t                    label.widget.render(),\n\t                    button.widget.render()\n\t                ]),\n\t                editInput.widget.render()\n\t            ];\n\t        },\n\t        tagName: 'li'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createTodoItem;\n\t});\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(39), __webpack_require__(34), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createFormFieldMixin_1 = __webpack_require__(34);\n\t    var createVNodeEvented_1 = __webpack_require__(7);\n\t    var createCheckboxInput = createRenderMixin_1.default\n\t        .mixin(createFormFieldMixin_1.default)\n\t        .mixin({\n\t        mixin: createVNodeEvented_1.default,\n\t        initialize: function (instance) {\n\t            instance.own(instance.on('input', function (event) {\n\t                instance.value = event.target.value;\n\t            }));\n\t        }\n\t    })\n\t        .extend({\n\t        nodeAttributes: [\n\t            function () {\n\t                var checked = this.state.checked;\n\t                return checked !== undefined ? { checked: checked } : {};\n\t            }\n\t        ],\n\t        tagName: 'input',\n\t        type: 'checkbox'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createCheckboxInput;\n\t});\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(33), __webpack_require__(25), __webpack_require__(18), __webpack_require__(8)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var aspect_1 = __webpack_require__(33);\n\t    var lang_1 = __webpack_require__(25);\n\t    var createEvented_1 = __webpack_require__(18);\n\t    var Set_1 = __webpack_require__(8);\n\t    var vnodeEvents = new Set_1.default([\n\t        'touchcancel',\n\t        'touchend',\n\t        'touchmove',\n\t        'touchstart',\n\t        'blur',\n\t        'change',\n\t        'click',\n\t        'dblclick',\n\t        'focus',\n\t        'input',\n\t        'keydown',\n\t        'keypress',\n\t        'keyup',\n\t        'load',\n\t        'mousedown',\n\t        'mouseenter',\n\t        'mouseleave',\n\t        'mousemove',\n\t        'mouseout',\n\t        'mouseover',\n\t        'mouseup',\n\t        'mousewheel',\n\t        'scroll',\n\t        'submit'\n\t    ]);\n\t    /**\n\t     * Internal function to convert an array of handles to a single array\n\t     *\n\t     * TODO: This is used in a couple places, maybe should migrate to a better place\n\t     *\n\t     * @params handles An array of handles\n\t     */\n\t    function handlesArraytoHandle(handles) {\n\t        return {\n\t            destroy: function () {\n\t                handles.forEach(function (handle) { return handle.destroy(); });\n\t            }\n\t        };\n\t    }\n\t    var UNINITIALIZED_LISTENERS = Object.freeze({});\n\t    var createVNodeEvented = createEvented_1.default\n\t        .mixin({\n\t        mixin: {\n\t            listeners: UNINITIALIZED_LISTENERS,\n\t            nodeAttributes: [\n\t                function () {\n\t                    return lang_1.assign({}, this.listeners);\n\t                }\n\t            ]\n\t        },\n\t        aspectAdvice: {\n\t            around: {\n\t                on: function (origFn) {\n\t                    return function () {\n\t                        var _this = this;\n\t                        var args = [];\n\t                        for (var _i = 0; _i < arguments.length; _i++) {\n\t                            args[_i - 0] = arguments[_i];\n\t                        }\n\t                        if (args.length === 2) {\n\t                            /* During initialization, sometimes the initialize functions occur out of order,\n\t                            * and Evented's initialize function could be called before this mixins, therefore\n\t                            * leaving this.listeners with an uninitiliazed value, therefore it is better to\n\t                            * determine if the value is unitialized here, ensuring that this.listeners is\n\t                            * always valid.\n\t                            */\n\t                            if (this.listeners === UNINITIALIZED_LISTENERS) {\n\t                                this.listeners = {};\n\t                            }\n\t                            var type_1;\n\t                            var listeners = void 0;\n\t                            type_1 = args[0], listeners = args[1];\n\t                            if (Array.isArray(listeners)) {\n\t                                var handles = listeners.map(function (listener) { return vnodeEvents.has(type_1) ?\n\t                                    aspect_1.on(_this.listeners, 'on' + type_1, createEvented_1.resolveListener(listener)) :\n\t                                    origFn.call(_this, type_1, listener); });\n\t                                return handlesArraytoHandle(handles);\n\t                            }\n\t                            else {\n\t                                return vnodeEvents.has(type_1) ?\n\t                                    aspect_1.on(this.listeners, 'on' + type_1, createEvented_1.resolveListener(listeners)) :\n\t                                    origFn.call(this, type_1, listeners);\n\t                            }\n\t                        }\n\t                        else if (args.length === 1) {\n\t                            var listenerMapArg_1 = args[0];\n\t                            return handlesArraytoHandle(Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); }));\n\t                        }\n\t                        else {\n\t                            throw new TypeError('Invalid arguments');\n\t                        }\n\t                    };\n\t                },\n\t                emit: function (origFn) {\n\t                    return function (event) {\n\t                        if (vnodeEvents.has(event.type)) {\n\t                            if (this.listeners === null) {\n\t                                this.listeners = {};\n\t                            }\n\t                            var method = this.listeners['on' + event.type];\n\t                            if (method) {\n\t                                method.call(this, event);\n\t                            }\n\t                        }\n\t                        else {\n\t                            origFn.call(this, event);\n\t                        }\n\t                    };\n\t                }\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createVNodeEvented;\n\t});\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(17), __webpack_require__(11), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var decorators_1 = __webpack_require__(17);\n\t    var global_1 = __webpack_require__(11);\n\t    var iterator_1 = __webpack_require__(15);\n\t    __webpack_require__(9);\n\t    var Shim;\n\t    (function (Shim) {\n\t        var Set = (function () {\n\t            function Set(iterable) {\n\t                var _this = this;\n\t                this._setData = [];\n\t                this[Symbol.toStringTag] = 'Set';\n\t                if (iterable) {\n\t                    iterator_1.forOf(iterable, function (value) { return _this.add(value); });\n\t                }\n\t            }\n\t            ;\n\t            Set.prototype.add = function (value) {\n\t                if (this.has(value)) {\n\t                    return this;\n\t                }\n\t                this._setData.push(value);\n\t                return this;\n\t            };\n\t            ;\n\t            Set.prototype.clear = function () {\n\t                this._setData.length = 0;\n\t            };\n\t            ;\n\t            Set.prototype.delete = function (value) {\n\t                var idx = this._setData.indexOf(value);\n\t                if (idx === -1) {\n\t                    return false;\n\t                }\n\t                this._setData.splice(idx, 1);\n\t                return true;\n\t            };\n\t            ;\n\t            Set.prototype.entries = function () {\n\t                return new iterator_1.ShimIterator(this._setData.map(function (value) { return [value, value]; }));\n\t            };\n\t            ;\n\t            Set.prototype.forEach = function (callbackfn, thisArg) {\n\t                var iterator = this.values();\n\t                var result = iterator.next();\n\t                while (!result.done) {\n\t                    callbackfn.call(thisArg, result.value, result.value, this);\n\t                    result = iterator.next();\n\t                }\n\t            };\n\t            ;\n\t            Set.prototype.has = function (value) {\n\t                return this._setData.indexOf(value) > -1;\n\t            };\n\t            ;\n\t            Set.prototype.keys = function () {\n\t                return new iterator_1.ShimIterator(this._setData);\n\t            };\n\t            ;\n\t            Object.defineProperty(Set.prototype, \"size\", {\n\t                get: function () {\n\t                    return this._setData.length;\n\t                },\n\t                enumerable: true,\n\t                configurable: true\n\t            });\n\t            ;\n\t            Set.prototype.values = function () {\n\t                return new iterator_1.ShimIterator(this._setData);\n\t            };\n\t            ;\n\t            Set.prototype[Symbol.iterator] = function () {\n\t                return new iterator_1.ShimIterator(this._setData);\n\t            };\n\t            ;\n\t            return Set;\n\t        }());\n\t        Shim.Set = Set;\n\t    })(Shim = exports.Shim || (exports.Shim = {}));\n\t    var Set = (function () {\n\t        /* istanbul ignore next */\n\t        function Set(iterable) {\n\t            /* istanbul ignore next */\n\t            this[Symbol.toStringTag] = 'Set';\n\t        }\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.add = function (value) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.clear = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.delete = function (value) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.entries = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.forEach = function (callbackfn, thisArg) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.has = function (value) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.keys = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        Object.defineProperty(Set.prototype, \"size\", {\n\t            /* istanbul ignore next */\n\t            get: function () { throw new Error('Abstract method'); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype.values = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Set.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        Set = __decorate([\n\t            decorators_1.hasClass('es6-set', global_1.default.Set, Shim.Set)\n\t        ], Set);\n\t        return Set;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = Set;\n\t});\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(11), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var has_1 = __webpack_require__(12);\n\t    var global_1 = __webpack_require__(11);\n\t    var util_1 = __webpack_require__(10);\n\t    var Shim;\n\t    (function (Shim) {\n\t        /* tslint:disable-next-line:variable-name */\n\t        var Symbol;\n\t        /* tslint:disable-next-line:variable-name */\n\t        var InternalSymbol;\n\t        var defineProperties = Object.defineProperties;\n\t        var defineProperty = Object.defineProperty;\n\t        var create = Object.create;\n\t        var objPrototype = Object.prototype;\n\t        var globalSymbols = {};\n\t        var getSymbolName = (function () {\n\t            var created = create(null);\n\t            return function (desc) {\n\t                var postfix = 0;\n\t                var name;\n\t                while (created[String(desc) + (postfix || '')]) {\n\t                    ++postfix;\n\t                }\n\t                desc += String(postfix || '');\n\t                created[desc] = true;\n\t                name = '@@' + desc;\n\t                // FIXME: Temporary guard until the duplicate execution when testing can be\n\t                // pinned down.\n\t                if (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n\t                    defineProperty(objPrototype, name, {\n\t                        set: function (value) {\n\t                            defineProperty(this, name, util_1.getValueDescriptor(value));\n\t                        }\n\t                    });\n\t                }\n\t                return name;\n\t            };\n\t        }());\n\t        InternalSymbol = function Symbol(description) {\n\t            if (this instanceof InternalSymbol) {\n\t                throw new TypeError('TypeError: Symbol is not a constructor');\n\t            }\n\t            return Symbol(description);\n\t        };\n\t        Symbol = function Symbol(description) {\n\t            if (this instanceof Symbol) {\n\t                throw new TypeError('TypeError: Symbol is not a constructor');\n\t            }\n\t            var sym = Object.create(InternalSymbol.prototype);\n\t            description = (description === undefined ? '' : String(description));\n\t            return defineProperties(sym, {\n\t                __description__: util_1.getValueDescriptor(description),\n\t                __name__: util_1.getValueDescriptor(getSymbolName(description))\n\t            });\n\t        };\n\t        /**\n\t         * A custom guard function that determines if an object is a symbol or not\n\t         * @param  {any}       value The value to check to see if it is a symbol or not\n\t         * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n\t         */\n\t        function isSymbol(value) {\n\t            return (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n\t        }\n\t        Shim.isSymbol = isSymbol;\n\t        /**\n\t         * Throws if the value is not a symbol, used internally within the Shim\n\t         * @param  {any}    value The value to check\n\t         * @return {symbol}       Returns the symbol or throws\n\t         */\n\t        function validateSymbol(value) {\n\t            if (!isSymbol(value)) {\n\t                throw new TypeError(value + ' is not a symbol');\n\t            }\n\t            return value;\n\t        }\n\t        /* Decorate the Symbol function with the appropriate properties */\n\t        defineProperty(Symbol, 'for', util_1.getValueDescriptor(function (key) {\n\t            if (globalSymbols[key]) {\n\t                return globalSymbols[key];\n\t            }\n\t            return (globalSymbols[key] = Symbol(String(key)));\n\t        }));\n\t        defineProperties(Symbol, {\n\t            keyFor: util_1.getValueDescriptor(function (sym) {\n\t                var key;\n\t                validateSymbol(sym);\n\t                for (key in globalSymbols) {\n\t                    if (globalSymbols[key] === sym) {\n\t                        return key;\n\t                    }\n\t                }\n\t            }),\n\t            hasInstance: util_1.getValueDescriptor(Symbol.for('hasInstance'), false, false),\n\t            isConcatSpreadable: util_1.getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n\t            iterator: util_1.getValueDescriptor(Symbol.for('iterator'), false, false),\n\t            match: util_1.getValueDescriptor(Symbol.for('match'), false, false),\n\t            replace: util_1.getValueDescriptor(Symbol.for('replace'), false, false),\n\t            search: util_1.getValueDescriptor(Symbol.for('search'), false, false),\n\t            species: util_1.getValueDescriptor(Symbol.for('species'), false, false),\n\t            split: util_1.getValueDescriptor(Symbol.for('split'), false, false),\n\t            toPrimitive: util_1.getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n\t            toStringTag: util_1.getValueDescriptor(Symbol.for('toStringTag'), false, false),\n\t            unscopables: util_1.getValueDescriptor(Symbol.for('unscopables'), false, false)\n\t        });\n\t        /* Decorate the InternalSymbol object */\n\t        defineProperties(InternalSymbol.prototype, {\n\t            constructor: util_1.getValueDescriptor(Symbol),\n\t            toString: util_1.getValueDescriptor(function () { return this.__name__; }, false, false)\n\t        });\n\t        /* Decorate the Symbol.prototype */\n\t        defineProperties(Symbol.prototype, {\n\t            toString: util_1.getValueDescriptor(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),\n\t            valueOf: util_1.getValueDescriptor(function () { return validateSymbol(this); })\n\t        });\n\t        defineProperty(Symbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(function () { return validateSymbol(this); }));\n\t        defineProperty(Symbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));\n\t        defineProperty(InternalSymbol.prototype, Symbol.toPrimitive, util_1.getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n\t        defineProperty(InternalSymbol.prototype, Symbol.toStringTag, util_1.getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n\t        /* tslint:disable-next-line:variable-name */\n\t        Shim.Exposed = Symbol;\n\t    })(Shim = exports.Shim || (exports.Shim = {}));\n\t    /* tslint:disable-next-line:variable-name */\n\t    var SymbolShim = has_1.default('es6-symbol') ? global_1.default.Symbol : global_1.default.Symbol = Shim.Exposed;\n\t    /**\n\t     * Fill any missing well known symbols if the native Symbol is missing them\n\t     */\n\t    ['hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n\t        'toStringTag', 'unscopables'].forEach(function (wellKnown) {\n\t        if (!Symbol[wellKnown]) {\n\t            Object.defineProperty(Symbol, wellKnown, util_1.getValueDescriptor(Symbol.for(wellKnown), false, false));\n\t        }\n\t    });\n\t    exports.isSymbol = Shim.isSymbol;\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = SymbolShim;\n\t});\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    /**\n\t     * Helper function to generate a value property descriptor\n\t     *\n\t     * @param value        The value the property descriptor should be set to\n\t     * @param enumerable   If the property should be enumberable, defaults to false\n\t     * @param writable     If the property should be writable, defaults to true\n\t     * @param configurable If the property should be configurable, defaults to true\n\t     * @return             The property descriptor object\n\t     */\n\t    function getValueDescriptor(value, enumerable, writable, configurable) {\n\t        if (enumerable === void 0) { enumerable = false; }\n\t        if (writable === void 0) { writable = true; }\n\t        if (configurable === void 0) { configurable = true; }\n\t        return {\n\t            value: value,\n\t            enumerable: enumerable,\n\t            writable: writable,\n\t            configurable: configurable\n\t        };\n\t    }\n\t    exports.getValueDescriptor = getValueDescriptor;\n\t    /**\n\t     * A helper function which wraps a function where the first argument becomes the scope\n\t     * of the call\n\t     *\n\t     * @param nativeFunction The source function to be wrapped\n\t     */\n\t    function wrapNative(nativeFunction) {\n\t        return function (target) {\n\t            var args = [];\n\t            for (var _i = 1; _i < arguments.length; _i++) {\n\t                args[_i - 1] = arguments[_i];\n\t            }\n\t            return nativeFunction.apply(target, args);\n\t        };\n\t    }\n\t    exports.wrapNative = wrapNative;\n\t});\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var globalObject = Function('return this')();\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = globalObject;\n\t});\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(11), __webpack_require__(13), __webpack_require__(13), __webpack_require__(13)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    function __export(m) {\n\t        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t    }\n\t    var global_1 = __webpack_require__(11);\n\t    var has_1 = __webpack_require__(13);\n\t    var has_2 = __webpack_require__(13);\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = has_1.default;\n\t    __export(__webpack_require__(13));\n\t    /* ECMAScript 6 and 7 Features */\n\t    /* Object */\n\t    has_2.add('es6-object-assign', typeof Object.assign === 'function');\n\t    /* Array */\n\t    has_2.add('es6-array-from', 'from' in global_1.default.Array);\n\t    has_2.add('es6-array-of', 'of' in global_1.default.Array);\n\t    has_2.add('es6-array-fill', function () {\n\t        if ('fill' in global_1.default.Array.prototype) {\n\t            /* Some versions of Safari do not properly implement this */\n\t            return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n\t        }\n\t        return false;\n\t    });\n\t    has_2.add('es6-array-findindex', 'findIndex' in global_1.default.Array.prototype);\n\t    has_2.add('es6-array-find', 'find' in global_1.default.Array.prototype);\n\t    has_2.add('es6-array-copywithin', 'copyWithin' in global_1.default.Array.prototype);\n\t    has_2.add('es7-array-includes', 'includes' in global_1.default.Array.prototype);\n\t    /* String */\n\t    has_2.add('es6-string-raw', 'raw' in global_1.default.String);\n\t    has_2.add('es6-string-fromcodepoint', 'fromCodePoint' in global_1.default.String);\n\t    has_2.add('es6-string-codepointat', 'codePointAt' in global_1.default.String.prototype);\n\t    has_2.add('es6-string-normalize', 'normalize' in global_1.default.String.prototype);\n\t    has_2.add('es6-string-repeat', 'repeat' in global_1.default.String.prototype);\n\t    has_2.add('es6-string-startswith', 'startsWith' in global_1.default.String.prototype);\n\t    has_2.add('es6-string-endswith', 'endsWith' in global_1.default.String.prototype);\n\t    has_2.add('es6-string-includes', 'includes' in global_1.default.String.prototype);\n\t    /* Math */\n\t    has_2.add('es6-math-acosh', typeof global_1.default.Math.acosh === 'function');\n\t    has_2.add('es6-math-clz32', typeof global_1.default.Math.clz32 === 'function');\n\t    has_2.add('es6-math-imul', function () {\n\t        if ('imul' in global_1.default.Math) {\n\t            /* Some versions of Safari on ios do not properly implement this */\n\t            return Math.imul(0xffffffff, 5) === -5;\n\t        }\n\t        return false;\n\t    });\n\t    /* Promise */\n\t    has_2.add('es6-promise', typeof global_1.default.Promise !== 'undefined' && typeof global_1.default.Symbol !== 'undefined');\n\t    /* Set */\n\t    has_2.add('es6-set', function () {\n\t        if (typeof global_1.default.Set === 'function') {\n\t            /* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n\t            var set = new global_1.default.Set([1]);\n\t            return set.has(1) && 'keys' in set && typeof set.keys === 'function';\n\t        }\n\t        return false;\n\t    });\n\t    /* Map */\n\t    has_2.add('es6-map', function () {\n\t        if (typeof global_1.default.Map === 'function') {\n\t            /*\n\t            IE11 and older versions of Safari are missing critical ES6 Map functionality\n\t            We wrap this in a try/catch because sometimes the Map constructor exists, but does not\n\t            take arguments (iOS 8.4)\n\t             */\n\t            try {\n\t                var map = new global_1.default.Map([[0, 1]]);\n\t                return map.has(0) && typeof map.keys === 'function' &&\n\t                    typeof map.values === 'function' && typeof map.entries === 'function';\n\t            }\n\t            catch (e) {\n\t                /* istanbul ignore next: not testing on iOS at the moment */\n\t                return false;\n\t            }\n\t        }\n\t        return false;\n\t    });\n\t    /* WeakMap */\n\t    has_2.add('es6-weakmap', function () {\n\t        if (typeof global_1.default.WeakMap !== 'undefined') {\n\t            /* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n\t            var key1 = {};\n\t            var key2 = {};\n\t            var map = new global_1.default.WeakMap([[key1, 1]]);\n\t            return map.get(key1) === 1 && map.set(key2, 2) === map;\n\t        }\n\t        return false;\n\t    });\n\t    /* Symbol */\n\t    has_2.add('es6-symbol', typeof global_1.default.Symbol === 'function');\n\t    /* Miscellaneous features */\n\t    has_2.add('float32array', 'Float32Array' in global_1.default);\n\t    has_2.add('setimmediate', typeof global_1.default.setImmediate !== 'undefined');\n\t    has_2.add('postmessage', typeof postMessage === 'function');\n\t    has_2.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); });\n\t    /* DOM Features */\n\t    has_2.add('dom-mutationobserver', function () { return has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver); });\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, process) {(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    /**\n\t     * A cache of results of feature tests\n\t     */\n\t    exports.testCache = {};\n\t    /**\n\t     * A cache of the un-resolved feature tests\n\t     */\n\t    exports.testFunctions = {};\n\t    /**\n\t     * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n\t     */\n\t    var globalScope = (function () {\n\t        /* istanbul ignore else */\n\t        if (typeof window !== 'undefined') {\n\t            // Browsers\n\t            return window;\n\t        }\n\t        else if (typeof global !== 'undefined') {\n\t            // Node\n\t            return global;\n\t        }\n\t        else if (typeof self !== 'undefined') {\n\t            // Web workers\n\t            return self;\n\t        }\n\t        /* istanbul ignore next */\n\t        return {};\n\t    })();\n\t    /* Grab the staticFeatures if there are available */\n\t    var staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;\n\t    /* Cleaning up the DojoHasEnviornment */\n\t    if ('DojoHasEnvironment' in globalScope) {\n\t        delete globalScope.DojoHasEnvironment;\n\t    }\n\t    /**\n\t     * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n\t     * returns a map.\n\t     *\n\t     * @param value The value to guard for\n\t     */\n\t    function isStaticFeatureFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t    /**\n\t     * The cache of asserted features that were available in the global scope when the\n\t     * module loaded\n\t     */\n\t    var staticCache = staticFeatures\n\t        ? isStaticFeatureFunction(staticFeatures)\n\t            ? staticFeatures.apply(globalScope)\n\t            : staticFeatures\n\t        : {}; /* Providing an empty cache, if none was in the environment\n\t\n\t/**\n\t * AMD plugin function.\n\t *\n\t * Conditional loads modules based on a has feature test value.\n\t *\n\t * @param resourceId Gives the resolved module id to load.\n\t * @param require The loader require function with respect to the module that contained the plugin resource in its\n\t *                dependency list.\n\t * @param load Callback to loader that consumes result of plugin demand.\n\t */\n\t    function load(resourceId, require, load, config) {\n\t        resourceId ? require([resourceId], load) : load();\n\t    }\n\t    exports.load = load;\n\t    /**\n\t     * AMD plugin function.\n\t     *\n\t     * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n\t     * value(s).\n\t     *\n\t     * @param resourceId The id of the module\n\t     * @param normalize Resolves a relative module id into an absolute module id\n\t     */\n\t    function normalize(resourceId, normalize) {\n\t        var tokens = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n\t        var i = 0;\n\t        function get(skip) {\n\t            var term = tokens[i++];\n\t            if (term === ':') {\n\t                // empty string module name, resolves to null\n\t                return null;\n\t            }\n\t            else {\n\t                // postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t                if (tokens[i++] === '?') {\n\t                    if (!skip && has(term)) {\n\t                        // matched the feature, get the first value from the options\n\t                        return get();\n\t                    }\n\t                    else {\n\t                        // did not match, get the second value, passing over the first\n\t                        get(true);\n\t                        return get(skip);\n\t                    }\n\t                }\n\t                // a module\n\t                return term;\n\t            }\n\t        }\n\t        var id = get();\n\t        return id && normalize(id);\n\t    }\n\t    exports.normalize = normalize;\n\t    /**\n\t     * Check if a feature has already been registered\n\t     *\n\t     * @param feature the name of the feature\n\t     */\n\t    function exists(feature) {\n\t        return Boolean(feature in staticCache || feature in exports.testCache || exports.testFunctions[feature]);\n\t    }\n\t    exports.exists = exists;\n\t    /**\n\t     * Register a new test for a named feature.\n\t     *\n\t     * @example\n\t     * has.add('dom-addeventlistener', !!document.addEventListener);\n\t     *\n\t     * @example\n\t     * has.add('touch-events', function () {\n\t     *    return 'ontouchstart' in document\n\t     * });\n\t     *\n\t     * @param feature the name of the feature\n\t     * @param value the value reported of the feature, or a function that will be executed once on first test\n\t     * @param overwrite if an existing value should be overwritten. Defaults to false.\n\t     */\n\t    function add(feature, value, overwrite) {\n\t        if (overwrite === void 0) { overwrite = false; }\n\t        if (exists(feature) && !overwrite && !(feature in staticCache)) {\n\t            throw new TypeError(\"Feature \\\"\" + feature + \"\\\" exists and overwrite not true.\");\n\t        }\n\t        if (typeof value === 'function') {\n\t            exports.testFunctions[feature] = value;\n\t        }\n\t        else {\n\t            exports.testCache[feature] = value;\n\t            delete exports.testFunctions[feature];\n\t        }\n\t    }\n\t    exports.add = add;\n\t    /**\n\t     * Return the current value of a named feature.\n\t     *\n\t     * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n\t     */\n\t    function has(feature) {\n\t        var result;\n\t        if (feature in staticCache) {\n\t            result = staticCache[feature];\n\t        }\n\t        else if (exports.testFunctions[feature]) {\n\t            result = exports.testCache[feature] = exports.testFunctions[feature].call(null);\n\t            delete exports.testFunctions[feature];\n\t        }\n\t        else if (feature in exports.testCache) {\n\t            result = exports.testCache[feature];\n\t        }\n\t        else {\n\t            throw new TypeError(\"Attempt to detect unregistered has feature \\\"\" + feature + \"\\\"\");\n\t        }\n\t        return result;\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = has;\n\t    /*\n\t     * Out of the box feature tests\n\t     */\n\t    /* Evironments */\n\t    /* Used as a value to provide a debug only code path */\n\t    add('debug', true);\n\t    /* Detects if the environment is \"browser like\" */\n\t    add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\t    /* Detects if the enviornment appears to be NodeJS */\n\t    add('host-node', function () {\n\t        if (typeof process === 'object' && process.versions && process.versions.node) {\n\t            return process.versions.node;\n\t        }\n\t    });\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(14)))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(16), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var string_1 = __webpack_require__(16);\n\t    __webpack_require__(9);\n\t    var staticDone = { done: true, value: undefined };\n\t    /**\n\t     * A class that provides \"shims\" an iterator interface on array like\n\t     * objects.\n\t     */\n\t    var ShimIterator = (function () {\n\t        function ShimIterator(list) {\n\t            this._nextIndex = -1;\n\t            if (isIterable(list)) {\n\t                this._nativeIterator = list[Symbol.iterator]();\n\t            }\n\t            else {\n\t                this._list = list;\n\t            }\n\t        }\n\t        ;\n\t        /**\n\t         * Return the next iteration result for the Iterator\n\t         */\n\t        ShimIterator.prototype.next = function () {\n\t            if (this._nativeIterator) {\n\t                return this._nativeIterator.next();\n\t            }\n\t            if (!this._list) {\n\t                return staticDone;\n\t            }\n\t            if (++this._nextIndex < this._list.length) {\n\t                return {\n\t                    done: false,\n\t                    value: this._list[this._nextIndex]\n\t                };\n\t            }\n\t            return staticDone;\n\t        };\n\t        ;\n\t        ShimIterator.prototype[Symbol.iterator] = function () {\n\t            return this;\n\t        };\n\t        return ShimIterator;\n\t    }());\n\t    exports.ShimIterator = ShimIterator;\n\t    /**\n\t     * A type guard for checking if something has an Iterable interface\n\t     *\n\t     * @param value The value to type guard against\n\t     */\n\t    function isIterable(value) {\n\t        return value && typeof value[Symbol.iterator] === 'function';\n\t    }\n\t    exports.isIterable = isIterable;\n\t    /**\n\t     * A type guard for checking if something is ArrayLike\n\t     *\n\t     * @param value The value to type guard against\n\t     */\n\t    function isArrayLike(value) {\n\t        return value && typeof value.length === 'number';\n\t    }\n\t    exports.isArrayLike = isArrayLike;\n\t    /**\n\t     * Returns the iterator for an object\n\t     *\n\t     * @param iterable The iterable object to return the iterator for\n\t     */\n\t    function get(iterable) {\n\t        if (isIterable(iterable)) {\n\t            return iterable[Symbol.iterator]();\n\t        }\n\t        else if (isArrayLike(iterable)) {\n\t            return new ShimIterator(iterable);\n\t        }\n\t    }\n\t    exports.get = get;\n\t    ;\n\t    /**\n\t     * Shims the functionality of `for ... of` blocks\n\t     *\n\t     * @param iterable The object the provides an interator interface\n\t     * @param callback The callback which will be called for each item of the iterable\n\t     * @param thisArg Optional scope to pass the callback\n\t     */\n\t    function forOf(iterable, callback, thisArg) {\n\t        var broken = false;\n\t        function doBreak() {\n\t            broken = true;\n\t        }\n\t        /* We need to handle iteration of double byte strings properly */\n\t        if (!isIterable(iterable) && typeof iterable === 'string') {\n\t            var l = iterable.length;\n\t            for (var i = 0; i < l; ++i) {\n\t                var char = iterable[i];\n\t                if ((i + 1) < l) {\n\t                    var code = char.charCodeAt(0);\n\t                    if ((code >= string_1.HIGH_SURROGATE_MIN) && (code <= string_1.HIGH_SURROGATE_MAX)) {\n\t                        char += iterable[++i];\n\t                    }\n\t                }\n\t                callback.call(thisArg, char, iterable, doBreak);\n\t                if (broken) {\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var iterator = get(iterable);\n\t            if (iterator) {\n\t                var result = iterator.next();\n\t                while (!result.done) {\n\t                    callback.call(thisArg, result.value, iterable, doBreak);\n\t                    if (broken) {\n\t                        return;\n\t                    }\n\t                    result = iterator.next();\n\t                }\n\t            }\n\t        }\n\t    }\n\t    exports.forOf = forOf;\n\t});\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var has_1 = __webpack_require__(12);\n\t    var util_1 = __webpack_require__(10);\n\t    /**\n\t     * The minimum location of high surrogates\n\t     */\n\t    exports.HIGH_SURROGATE_MIN = 0xD800;\n\t    /**\n\t     * The maximum location of high surrogates\n\t     */\n\t    exports.HIGH_SURROGATE_MAX = 0xDBFF;\n\t    /**\n\t     * The minimum location of low surrogates\n\t     */\n\t    exports.LOW_SURROGATE_MIN = 0xDC00;\n\t    /**\n\t     * The maximum location of low surrogates\n\t     */\n\t    exports.LOW_SURROGATE_MAX = 0xDFFF;\n\t    var Shim;\n\t    (function (Shim) {\n\t        /**\n\t         * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t         * Used by startsWith, includes, and endsWith.\n\t         *\n\t         * @return Normalized position.\n\t         */\n\t        function normalizeSubstringArgs(name, text, search, position, isEnd) {\n\t            if (isEnd === void 0) { isEnd = false; }\n\t            if (text == null) {\n\t                throw new TypeError('string.' + name + ' requires a valid string to search against.');\n\t            }\n\t            var length = text.length;\n\t            position = position !== position ? (isEnd ? length : 0) : position;\n\t            return [text, String(search), Math.min(Math.max(position, 0), length)];\n\t        }\n\t        function raw(callSite) {\n\t            var substitutions = [];\n\t            for (var _i = 1; _i < arguments.length; _i++) {\n\t                substitutions[_i - 1] = arguments[_i];\n\t            }\n\t            var rawStrings = callSite.raw;\n\t            var result = '';\n\t            var numSubstitutions = substitutions.length;\n\t            if (callSite == null || callSite.raw == null) {\n\t                throw new TypeError('string.raw requires a valid callSite object with a raw value');\n\t            }\n\t            for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {\n\t                result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');\n\t            }\n\t            return result;\n\t        }\n\t        Shim.raw = raw;\n\t        function fromCodePoint() {\n\t            var codePoints = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                codePoints[_i - 0] = arguments[_i];\n\t            }\n\t            // Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t            var length = arguments.length;\n\t            if (!length) {\n\t                return '';\n\t            }\n\t            var fromCharCode = String.fromCharCode;\n\t            var MAX_SIZE = 0x4000;\n\t            var codeUnits = [];\n\t            var index = -1;\n\t            var result = '';\n\t            while (++index < length) {\n\t                var codePoint = Number(arguments[index]);\n\t                // Code points must be finite integers within the valid range\n\t                var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n\t                    codePoint >= 0 && codePoint <= 0x10FFFF;\n\t                if (!isValid) {\n\t                    throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t                }\n\t                if (codePoint <= 0xFFFF) {\n\t                    // BMP code point\n\t                    codeUnits.push(codePoint);\n\t                }\n\t                else {\n\t                    // Astral code point; split in surrogate halves\n\t                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t                    codePoint -= 0x10000;\n\t                    var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;\n\t                    var lowSurrogate = (codePoint % 0x400) + exports.LOW_SURROGATE_MIN;\n\t                    codeUnits.push(highSurrogate, lowSurrogate);\n\t                }\n\t                if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t                    result += fromCharCode.apply(null, codeUnits);\n\t                    codeUnits.length = 0;\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t        Shim.fromCodePoint = fromCodePoint;\n\t        function codePointAt(text, position) {\n\t            if (position === void 0) { position = 0; }\n\t            // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t            if (text == null) {\n\t                throw new TypeError('string.codePointAt requries a valid string.');\n\t            }\n\t            var length = text.length;\n\t            if (position !== position) {\n\t                position = 0;\n\t            }\n\t            if (position < 0 || position >= length) {\n\t                return undefined;\n\t            }\n\t            // Get the first code unit\n\t            var first = text.charCodeAt(position);\n\t            if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {\n\t                // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t                var second = text.charCodeAt(position + 1);\n\t                if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {\n\t                    return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;\n\t                }\n\t            }\n\t            return first;\n\t        }\n\t        Shim.codePointAt = codePointAt;\n\t        /* TODO: Missing normalize */\n\t        function repeat(text, count) {\n\t            if (count === void 0) { count = 0; }\n\t            // Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t            if (text == null) {\n\t                throw new TypeError('string.repeat requires a valid string.');\n\t            }\n\t            if (count !== count) {\n\t                count = 0;\n\t            }\n\t            if (count < 0 || count === Infinity) {\n\t                throw new RangeError('string.repeat requires a non-negative finite count.');\n\t            }\n\t            var result = '';\n\t            while (count) {\n\t                if (count % 2) {\n\t                    result += text;\n\t                }\n\t                if (count > 1) {\n\t                    text += text;\n\t                }\n\t                count >>= 1;\n\t            }\n\t            return result;\n\t        }\n\t        Shim.repeat = repeat;\n\t        function startsWith(text, search, position) {\n\t            if (position === void 0) { position = 0; }\n\t            search = String(search);\n\t            _a = normalizeSubstringArgs('startsWith', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t            var end = position + search.length;\n\t            if (end > text.length) {\n\t                return false;\n\t            }\n\t            return text.slice(position, end) === search;\n\t            var _a;\n\t        }\n\t        Shim.startsWith = startsWith;\n\t        function endsWith(text, search, endPosition) {\n\t            if (endPosition == null) {\n\t                endPosition = text.length;\n\t            }\n\t            _a = normalizeSubstringArgs('endsWith', text, search, endPosition, true), text = _a[0], search = _a[1], endPosition = _a[2];\n\t            var start = endPosition - search.length;\n\t            if (start < 0) {\n\t                return false;\n\t            }\n\t            return text.slice(start, endPosition) === search;\n\t            var _a;\n\t        }\n\t        Shim.endsWith = endsWith;\n\t        function includes(text, search, position) {\n\t            if (position === void 0) { position = 0; }\n\t            _a = normalizeSubstringArgs('includes', text, search, position), text = _a[0], search = _a[1], position = _a[2];\n\t            return text.indexOf(search, position) !== -1;\n\t            var _a;\n\t        }\n\t        Shim.includes = includes;\n\t    })(Shim = exports.Shim || (exports.Shim = {}));\n\t    /**\n\t     * A tag function for template strings to get the template string's raw string form.\n\t     *\n\t     * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n\t     * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n\t     * @return String containing the raw template string with variables substituted\n\t     *\n\t     * @example\n\t     * // Within TypeScript; logs 'The answer is:\\\\n42'\n\t     * let answer = 42;\n\t     * console.log(string.raw`The answer is:\\n${answer}`);\n\t     *\n\t     * @example\n\t     * // The same example as above, but directly specifying a JavaScript object and substitution\n\t     * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n\t     */\n\t    exports.raw = has_1.default('es6-string-raw')\n\t        ? String.raw\n\t        : Shim.raw;\n\t    /**\n\t     * Returns the UTF-16 encoded code point value of a given position in a string.\n\t     *\n\t     * @param text The string containing the element whose code point is to be determined\n\t     * @param position Position of an element within the string to retrieve the code point value from\n\t     * @return A non-negative integer representing the UTF-16 encoded code point value\n\t     */\n\t    exports.fromCodePoint = has_1.default('es6-string-fromcodepoint')\n\t        ? String.fromCodePoint\n\t        : Shim.fromCodePoint;\n\t    /**\n\t     * Returns the UTF-16 encoded code point value of a given position in a string.\n\t     *\n\t     * @param text The string containing the element whose code point is to be determined\n\t     * @param position Position of an element within the string to retrieve the code point value from\n\t     * @return A non-negative integer representing the UTF-16 encoded code point value\n\t     */\n\t    exports.codePointAt = has_1.default('es6-string-codepointat')\n\t        ? util_1.wrapNative(String.prototype.codePointAt)\n\t        : Shim.codePointAt;\n\t    /**\n\t     * Returns a string containing the given string repeated the specified number of times.\n\t     *\n\t     * @param text The string to repeat\n\t     * @param count The number of times to repeat the string\n\t     * @return A string containing the input string repeated count times\n\t     */\n\t    exports.repeat = has_1.default('es6-string-repeat')\n\t        ? util_1.wrapNative(String.prototype.repeat)\n\t        : Shim.repeat;\n\t    /**\n\t     * Determines whether a string begins with the given substring (optionally starting from a given index).\n\t     *\n\t     * @param text The string to look for the search string within\n\t     * @param search The string to search for\n\t     * @param position The index to begin searching at\n\t     * @return Boolean indicating if the search string was found at the beginning of the given string\n\t     */\n\t    exports.startsWith = has_1.default('es6-string-startswith')\n\t        ? util_1.wrapNative(String.prototype.startsWith)\n\t        : Shim.startsWith;\n\t    /**\n\t     * Determines whether a string ends with the given substring.\n\t     *\n\t     * @param text The string to look for the search string within\n\t     * @param search The string to search for\n\t     * @param endPosition The index searching should stop before (defaults to text.length)\n\t     * @return Boolean indicating if the search string was found at the end of the given string\n\t     */\n\t    exports.endsWith = has_1.default('es6-string-endswith')\n\t        ? util_1.wrapNative(String.prototype.endsWith)\n\t        : Shim.endsWith;\n\t    /**\n\t     * Determines whether a string includes the given substring (optionally starting from a given index).\n\t     *\n\t     * @param text The string to look for the search string within\n\t     * @param search The string to search for\n\t     * @param position The index to begin searching at\n\t     * @return Boolean indicating if the search string was found within the given string\n\t     */\n\t    exports.includes = has_1.default('es6-string-includes')\n\t        ? util_1.wrapNative(String.prototype.includes)\n\t        : Shim.includes;\n\t});\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var has_1 = __webpack_require__(12);\n\t    /**\n\t     * A class decorator that provides either a native class or a shimmed class based on a feature\n\t     * test\n\t     * @param feature The has feature to check\n\t     * @param trueClass The class to use if feature test returns `true`\n\t     * @param falseClass The class to use if the feature test returns `false` or is not defined\n\t     */\n\t    function hasClass(feature, trueClass, falseClass) {\n\t        return function (target) {\n\t            return has_1.default(feature) ? trueClass : falseClass;\n\t        };\n\t    }\n\t    exports.hasClass = hasClass;\n\t});\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(33), __webpack_require__(31), __webpack_require__(22), __webpack_require__(20), __webpack_require__(19)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var aspect_1 = __webpack_require__(33);\n\t    var Map_1 = __webpack_require__(31);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var compose_1 = __webpack_require__(20);\n\t    var createDestroyable_1 = __webpack_require__(19);\n\t    /**\n\t     * A weak map that contains a map of the listeners for an `Evented`\n\t     */\n\t    var listenersMap = new WeakMap_1.default();\n\t    /**\n\t     * A guard which determines if the value is `Actionable`\n\t     *\n\t     * @param value The value to guard against\n\t     */\n\t    function isActionable(value) {\n\t        return Boolean(value && typeof value.do === 'function');\n\t    }\n\t    /**\n\t     * An internal function that always returns an EventedCallback\n\t     *\n\t     * @param listener Either a `EventedCallback` or an `Actionable`\n\t     */\n\t    function resolveListener(listener) {\n\t        return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;\n\t    }\n\t    exports.resolveListener = resolveListener;\n\t    /**\n\t     * Internal function to convert an array of handles to a single handle\n\t     *\n\t     * @param handles The array of handles to convert into a signle handle\n\t     * @return The single handle\n\t     */\n\t    function handlesArraytoHandle(handles) {\n\t        return {\n\t            destroy: function () {\n\t                handles.forEach(function (handle) { return handle.destroy(); });\n\t            }\n\t        };\n\t    }\n\t    /**\n\t     * Creates a new instance of an `Evented`\n\t     */\n\t    var createEvented = compose_1.default({\n\t        emit: function (event) {\n\t            var method = listenersMap.get(this).get(event.type);\n\t            if (method) {\n\t                method.call(this, event);\n\t            }\n\t        },\n\t        on: function () {\n\t            var _this = this;\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            var listenerMap = listenersMap.get(this);\n\t            if (args.length === 2) {\n\t                var _a = args, type_1 = _a[0], listeners = _a[1];\n\t                if (Array.isArray(listeners)) {\n\t                    var handles = listeners.map(function (listener) { return aspect_1.on(listenerMap, type_1, resolveListener(listener)); });\n\t                    return handlesArraytoHandle(handles);\n\t                }\n\t                else {\n\t                    return aspect_1.on(listenerMap, type_1, resolveListener(listeners));\n\t                }\n\t            }\n\t            else if (args.length === 1) {\n\t                var listenerMapArg_1 = args[0];\n\t                var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });\n\t                return handlesArraytoHandle(handles);\n\t            }\n\t            else {\n\t                throw new TypeError('Invalid arguments');\n\t            }\n\t        }\n\t    })\n\t        .mixin({\n\t        className: 'Evented',\n\t        mixin: createDestroyable_1.default,\n\t        initialize: function (instance, options) {\n\t            /* Initialise listener map */\n\t            listenersMap.set(instance, new Map_1.default());\n\t            if (options && options.listeners) {\n\t                instance.own(instance.on(options.listeners));\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createEvented;\n\t});\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(28), __webpack_require__(22), __webpack_require__(20)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var Promise_1 = __webpack_require__(28);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var compose_1 = __webpack_require__(20);\n\t    /**\n\t     * A reference to a function that always returns a promise which resolves to false\n\t     */\n\t    function noop() {\n\t        return Promise_1.default.resolve(false);\n\t    }\n\t    ;\n\t    /**\n\t     * A reference to a function that throws, used to replace the `own()` method after\n\t     * destruction\n\t     */\n\t    function destroyed() {\n\t        throw new Error('Call made to destroyed method');\n\t    }\n\t    ;\n\t    /**\n\t     * A weak map for *owning* handles on instances\n\t     */\n\t    var handlesWeakMap = new WeakMap_1.default();\n\t    /**\n\t     * A type guard that determines if the value is a Destroyable\n\t     *\n\t     * @param value The value to guard for\n\t     */\n\t    function isDestroyable(value) {\n\t        return Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n\t    }\n\t    exports.isDestroyable = isDestroyable;\n\t    /**\n\t     * A mixin which adds the concepts of being able to *destroy* handles which the instance\n\t     * *owns*\n\t     */\n\t    var createDestroyable = compose_1.default('Destroyable', {\n\t        own: function (handle) {\n\t            var handles = handlesWeakMap.get(this);\n\t            handles.push(handle);\n\t            return {\n\t                destroy: function () {\n\t                    handles.splice(handles.indexOf(handle));\n\t                    handle.destroy();\n\t                }\n\t            };\n\t        },\n\t        destroy: function () {\n\t            var _this = this;\n\t            return new Promise_1.default(function (resolve) {\n\t                handlesWeakMap.get(_this).forEach(function (handle) {\n\t                    handle && handle.destroy && handle.destroy();\n\t                });\n\t                _this.destroy = noop;\n\t                _this.own = destroyed;\n\t                resolve(true);\n\t            });\n\t        }\n\t    }, function (instance) {\n\t        handlesWeakMap.set(instance, []);\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createDestroyable;\n\t});\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(25), __webpack_require__(23), __webpack_require__(22), __webpack_require__(9), __webpack_require__(21)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var lang_1 = __webpack_require__(25);\n\t    var array_1 = __webpack_require__(23);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var Symbol_1 = __webpack_require__(9);\n\t    var aspect_1 = __webpack_require__(21);\n\t    /**\n\t     * The default factory label if no label can be derived during the factory creation process\n\t     */\n\t    var DEFAULT_FACTORY_LABEL = 'Compose';\n\t    /* References to support minification */\n\t    var defineProperty = Object.defineProperty;\n\t    var isArray = Array.isArray;\n\t    var objectCreate = Object.create;\n\t    var objectKeys = Object.keys;\n\t    /**\n\t     * A weakmap that stores all the private data for a factory\n\t     */\n\t    var privateFactoryData = new WeakMap_1.default();\n\t    /**\n\t     * An internal function which stubs out a method which, when called at runtime, throws.\n\t     *\n\t     * @param method The name of \"abstract\" method being called\n\t     */\n\t    function missingMethod(method) {\n\t        return function throwOnMissingMethod() {\n\t            throw new TypeError(\"Advice being applied to missing method named: \" + method);\n\t        };\n\t    }\n\t    /**\n\t     * Internal function which can label a factory with a name and also sets\n\t     * the `toString()` method on the prototype to return the approriate\n\t     * name for instances.\n\t     *\n\t     * @param fn The name of the factory to label\n\t     * @param value The name to supply for the label\n\t     */\n\t    function assignFactoryName(factory, value) {\n\t        if (typeof factory === 'function' && factory.prototype) {\n\t            assignFunctionName(factory, value);\n\t            defineProperty(factory.prototype, Symbol_1.default.toStringTag, {\n\t                get: function () {\n\t                    return value;\n\t                },\n\t                configurable: true\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * Internal function which can label a function with a name\n\t     */\n\t    function assignFunctionName(fn, value) {\n\t        var nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n\t        if (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n\t            defineProperty(fn, 'name', {\n\t                value: value,\n\t                writable: true,\n\t                configurable: true\n\t            });\n\t        }\n\t    }\n\t    /**\n\t     * A helper function that copies own properties and their descriptors\n\t     * from one or more sources to a target object. Includes non-enumerable properties\n\t     *\n\t     * @param target The target that properties should be copied onto\n\t     * @param sources The rest of the parameters treated as sources to apply\n\t     */\n\t    function assignProperties(target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        sources.forEach(function (source) {\n\t            if (!source) {\n\t                return;\n\t            }\n\t            Object.defineProperties(target, Object.getOwnPropertyNames(source).reduce(function (descriptors, key) {\n\t                if (key !== 'constructor') {\n\t                    var sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\t                    var sourceValue = sourceDescriptor && sourceDescriptor.value;\n\t                    var targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n\t                    var targetValue = targetDescriptor && targetDescriptor.value;\n\t                    /* Special handling to merge array proprties */\n\t                    if (isArray(sourceValue) && isArray(targetValue)) {\n\t                        sourceDescriptor.value = sourceValue.reduce(function (value, current) {\n\t                            if (!array_1.includes(target[key], current)) {\n\t                                value.push(current);\n\t                            }\n\t                            return value;\n\t                        }, array_1.from(targetValue));\n\t                    }\n\t                    descriptors[key] = sourceDescriptor;\n\t                }\n\t                return descriptors;\n\t            }, objectCreate(null)));\n\t        });\n\t        return target;\n\t    }\n\t    /**\n\t     * A helper funtion to return a function that is rebased to infer that the\n\t     * first argument of the passed function will be the `this` when the function\n\t     * is executed.\n\t     *\n\t     * @param  fn The function to be rebased\n\t     * @return    The rebased function\n\t     */\n\t    function rebase(fn) {\n\t        return function () {\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            return fn.apply(this, [this].concat(args));\n\t        };\n\t    }\n\t    /**\n\t     * For a given factory, return the names of the initialization functions that will be\n\t     * invoked upon construction.\n\t     *\n\t     * @param factory The factory that the array of function names should be returned for\n\t     */\n\t    function getInitFunctionNames(factory) {\n\t        var initFns = privateFactoryData.get(factory).initFns;\n\t        if (initFns) {\n\t            return initFns.map(function (fn) { return fn.name; });\n\t        }\n\t    }\n\t    exports.getInitFunctionNames = getInitFunctionNames;\n\t    /* The rebased functions we need to decorate compose constructors with */\n\t    /**\n\t     * Perform an extension of a class\n\t     */\n\t    var doExtend = rebase(extend);\n\t    /**\n\t     * Perform a mixin of a class\n\t     */\n\t    var doMixin = rebase(mixin);\n\t    /**\n\t     * Perform an overlay of a class\n\t     */\n\t    var doOverlay = rebase(overlay);\n\t    /**\n\t     * Apply aspect advice to a class\n\t     */\n\t    var doAspect = rebase(aspect);\n\t    /**\n\t     * Add static method/properties to a class\n\t     */\n\t    var doStatic = rebase(_static);\n\t    /**\n\t     * Take a mixin and return a factory descriptor for the mixin\n\t     *\n\t     * @param mixin The factory to return the descriptor for\n\t     * @template T The outer type of the descriptor\n\t     * @template O The outer factory options of the descriptor\n\t     * @template U The inner type of the descriptor\n\t     * @template P The inner factory options of the descriptor\n\t     */\n\t    function factoryDescriptor(mixin) {\n\t        return {\n\t            mixin: mixin,\n\t            className: mixin.name\n\t        };\n\t    }\n\t    ;\n\t    /**\n\t     * Generate a factory descriptor for a class\n\t     */\n\t    var doFactoryDescriptor = rebase(factoryDescriptor);\n\t    /**\n\t     * A set of functions that are used to decorate the compose factories\n\t     */\n\t    var staticMethods = {\n\t        extend: doExtend,\n\t        mixin: doMixin,\n\t        overlay: doOverlay,\n\t        from: doFrom,\n\t        before: doBefore,\n\t        after: doAfter,\n\t        around: doAround,\n\t        aspect: doAspect,\n\t        factoryDescriptor: doFactoryDescriptor,\n\t        static: doStatic\n\t    };\n\t    /**\n\t     * Internal function that merges (or creates) an advice map\n\t     *\n\t     * @param sources The advice maps to be merged into a single one\n\t     */\n\t    function assignAdviceMap() {\n\t        var sources = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            sources[_i - 0] = arguments[_i];\n\t        }\n\t        var result = {};\n\t        sources.forEach(function (source) {\n\t            if (source) {\n\t                for (var method in source) {\n\t                    result[method] = result[method] ? result[method].concat(source[method]) : source[method].slice();\n\t                }\n\t            }\n\t        });\n\t        return result;\n\t    }\n\t    /**\n\t     * An internal function that takes a set of create widget options and returns a set of private factory data\n\t     *\n\t     * @param options The set of factory options to use in creating the private factory data\n\t     */\n\t    function createPrivateFactoryData(_a) {\n\t        var optionsAdvice = _a.advice, factories = _a.factories, initFunction = _a.initFunction, proto = _a.proto, staticProperties = _a.staticProperties;\n\t        var factoryData = (factories || []).reduce(function (factoryData, factory) {\n\t            var _a = privateFactoryData.get(factory), advice = _a.advice, base = _a.base, initFns = _a.initFns;\n\t            if (advice) {\n\t                factoryData.advice = assignAdviceMap(factoryData.advice, advice);\n\t            }\n\t            if (base) {\n\t                assignProperties(factoryData.base, base);\n\t            }\n\t            var optionsInitFns = factoryData.initFns;\n\t            initFns.forEach(function (initFn) {\n\t                if (!array_1.includes(optionsInitFns, initFn)) {\n\t                    optionsInitFns.push(initFn);\n\t                }\n\t            });\n\t            return factoryData;\n\t        }, {\n\t            base: {},\n\t            initFns: [],\n\t            staticProperties: staticProperties ? lang_1.assign({}, staticProperties) : undefined\n\t        });\n\t        if (initFunction) {\n\t            factoryData.initFns.push(initFunction);\n\t        }\n\t        if (optionsAdvice) {\n\t            factoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n\t        }\n\t        assignProperties(factoryData.base, proto);\n\t        return factoryData;\n\t    }\n\t    function createFactory(options) {\n\t        /**\n\t         * A compose factory\n\t         */\n\t        function factory() {\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            if (this && this.constructor === factory) {\n\t                throw new SyntaxError('Factories cannot be called with \"new\".');\n\t            }\n\t            var instance = objectCreate(factory.prototype);\n\t            /* clone any arrays in the instance */\n\t            for (var key in instance) {\n\t                if (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n\t                    instance[key] = array_1.from(instance[key]);\n\t                }\n\t            }\n\t            args.unshift(instance);\n\t            privateFactoryData.get(factory).initFns.forEach(function (fn) {\n\t                fn.apply(null, args);\n\t            });\n\t            return instance;\n\t        }\n\t        var factoryData = createPrivateFactoryData(options);\n\t        privateFactoryData.set(factory, factoryData);\n\t        var factoryPrototype = factory.prototype;\n\t        /* mixin base properties into the prototype */\n\t        assignProperties(factoryPrototype, factoryData.base);\n\t        /* apply any advice to the prototype */\n\t        if (factoryData.advice) {\n\t            var _loop_1 = function(method) {\n\t                factoryData.advice[method].forEach(function (_a) {\n\t                    var aspect = _a[0], advice = _a[1];\n\t                    var sourceMethod = factoryPrototype[method] || missingMethod(method);\n\t                    switch (aspect) {\n\t                        case 'before':\n\t                            factoryPrototype[method] = aspect_1.before(sourceMethod, advice);\n\t                            break;\n\t                        case 'after':\n\t                            factoryPrototype[method] = aspect_1.after(sourceMethod, advice);\n\t                            break;\n\t                        case 'around':\n\t                            factoryPrototype[method] = aspect_1.around(sourceMethod, advice);\n\t                    }\n\t                });\n\t            };\n\t            for (var method in factoryData.advice) {\n\t                _loop_1(method);\n\t            }\n\t        }\n\t        /* assign a constructor to the prototype */\n\t        factoryPrototype.constructor = factory;\n\t        /* assign static methods/properties */\n\t        lang_1.assign(factory, staticMethods, factoryData.staticProperties);\n\t        /* assign factory name */\n\t        var className = options.className ||\n\t            (options.factories && options.factories[0] && options.factories[0].name) ||\n\t            DEFAULT_FACTORY_LABEL;\n\t        assignFactoryName(factory, className);\n\t        /* freeze the factory, so it cannot be accidently modified */\n\t        Object.freeze(factory);\n\t        return factory;\n\t    }\n\t    /**\n\t     * A custom type guard that determines if the value is a ComposeFactory\n\t     *\n\t     * @param   value The target to check\n\t     * @returns       Return true if it is a ComposeFactory, otherwise false\n\t     */\n\t    function isComposeFactory(value) {\n\t        return Boolean(value && privateFactoryData.get(value));\n\t    }\n\t    exports.isComposeFactory = isComposeFactory;\n\t    function extend(base, className, extension) {\n\t        if (typeof className !== 'string') {\n\t            extension = className;\n\t            className = undefined;\n\t        }\n\t        return createFactory({\n\t            className: className,\n\t            proto: typeof extension === 'function' ? extension.prototype : extension,\n\t            factories: [base]\n\t        });\n\t    }\n\t    /**\n\t     * Internal implementation of the overlay functionality, to allow a function to modify a\n\t     * compose factory prototype\n\t     *\n\t     * @param base The target compose factory\n\t     * @param overlayFunction The callback function that will modify the prototype of the factory\n\t     */\n\t    function overlay(base, overlayFunction) {\n\t        var factory = createFactory({\n\t            factories: [base]\n\t        });\n\t        overlayFunction(factory.prototype);\n\t        return factory;\n\t    }\n\t    /**\n\t     * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n\t     * creating a factory\n\t     *\n\t     * @param aspectAdvice The aspect advice to convert into an advice map\n\t     */\n\t    function aspectAdviceToAdviceMap(aspectAdvice) {\n\t        if (!aspectAdvice) {\n\t            return;\n\t        }\n\t        var adviceMap = {};\n\t        var beforeAdvice = aspectAdvice.before;\n\t        var afterAdvice = aspectAdvice.after;\n\t        var aroundAdvice = aspectAdvice.around;\n\t        function mapAdvice(type, key, advice) {\n\t            var adviceTuple = [type, advice[key]];\n\t            if (adviceMap[key]) {\n\t                adviceMap[key].push(adviceTuple);\n\t            }\n\t            else {\n\t                adviceMap[key] = [adviceTuple];\n\t            }\n\t        }\n\t        if (beforeAdvice) {\n\t            objectKeys(beforeAdvice).forEach(function (key) {\n\t                /* TODO: Remove ! in 2.1 */\n\t                mapAdvice('before', key, beforeAdvice);\n\t            });\n\t        }\n\t        if (afterAdvice) {\n\t            objectKeys(afterAdvice).forEach(function (key) {\n\t                /* TODO: Remove ! in 2.1 */\n\t                mapAdvice('after', key, afterAdvice);\n\t            });\n\t        }\n\t        if (aroundAdvice) {\n\t            objectKeys(aroundAdvice).forEach(function (key) {\n\t                /* TODO: Remove ! in 2.1 */\n\t                mapAdvice('around', key, aroundAdvice);\n\t            });\n\t        }\n\t        return adviceMap;\n\t    }\n\t    /**\n\t     * A custom type guard that determines if a value is ComposeMixinable\n\t     *\n\t     * @param value The value to guard for\n\t     */\n\t    function isComposeMixinable(value) {\n\t        return Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n\t    }\n\t    /**\n\t     * The internal implementation of mixin in values into a compose factory\n\t     *\n\t     * @param base The base compose factory that is the target for being mixed in\n\t     * @param toMixin The value to be mixed in\n\t     */\n\t    function mixin(base, toMixin) {\n\t        /* ensure we are dealing with a mixinDescriptor */\n\t        var mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\t        /* destructure out most of the factory creation options */\n\t        var mixin = mixinDescriptor.mixin, initFunction = mixinDescriptor.initialize, aspectAdvice = mixinDescriptor.aspectAdvice, className = mixinDescriptor.className;\n\t        /* we will at least be using the base factory to create the new one */\n\t        var factories = [base];\n\t        var proto;\n\t        /* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n\t        if (isComposeFactory(mixin)) {\n\t            factories.push(mixin);\n\t        }\n\t        else {\n\t            /* of which, we can have a constructor function/class, or an object literal (or undefined) */\n\t            proto = isComposeFactory(mixin) ? undefined : typeof mixin === 'function' ? mixin.prototype : mixin;\n\t        }\n\t        /* convert the advice, if any, to the format used by createFactory */\n\t        var advice = aspectAdviceToAdviceMap(aspectAdvice);\n\t        /* label the initFn */\n\t        if (initFunction) {\n\t            assignFunctionName(initFunction, \"mixin\" + (className || (isComposeFactory(mixin) && mixin.name) || base.name));\n\t        }\n\t        /* return the newly created factory */\n\t        return createFactory({\n\t            advice: advice,\n\t            factories: factories,\n\t            initFunction: initFunction,\n\t            className: className,\n\t            proto: proto\n\t        });\n\t    }\n\t    /**\n\t     * Internal implementation of extracting methods from another object\n\t     *\n\t     * @param base The target that the method should be extracted from\n\t     * @param method The name of the method\n\t     */\n\t    function from(base, method) {\n\t        return base.prototype[method];\n\t    }\n\t    /**\n\t     * Internal implementation to apply from when `this` represents the base\n\t     *\n\t     * @param base The target that the method should be extracted from\n\t     * @param method The name of the method\n\t     */\n\t    function doFrom(base, method) {\n\t        return createFactory({\n\t            factories: [this],\n\t            proto: (_a = {},\n\t                _a[method] = base.prototype[method],\n\t                _a\n\t            )\n\t        });\n\t        var _a;\n\t    }\n\t    function before() {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        var base;\n\t        var method;\n\t        var advice;\n\t        if (args.length >= 3) {\n\t            base = args[0], method = args[1], advice = args[2];\n\t            method = base.prototype[method];\n\t        }\n\t        else {\n\t            method = args[0], advice = args[1];\n\t        }\n\t        return aspect_1.before(method, advice);\n\t    }\n\t    /**\n\t     * The internal implementation to apply before advice when `this` is scoped as the base factory\n\t     *\n\t     * @param method The name of the method that the advice should be applied to\n\t     * @param advice The advice to apply\n\t     */\n\t    function doBefore(method, advice) {\n\t        return createFactory({\n\t            factories: [this],\n\t            advice: (_a = {},\n\t                _a[method] = [['before', advice]],\n\t                _a\n\t            )\n\t        });\n\t        var _a;\n\t    }\n\t    function after() {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        var base;\n\t        var method;\n\t        var advice;\n\t        if (args.length >= 3) {\n\t            base = args[0], method = args[1], advice = args[2];\n\t            method = base.prototype[method];\n\t        }\n\t        else {\n\t            method = args[0], advice = args[1];\n\t        }\n\t        return aspect_1.after(method, advice);\n\t    }\n\t    /**\n\t     * The internal implementation to apply after advice when `this` is scoped as the base factory\n\t     *\n\t     * @param method The name of the method that the advice should be applied to\n\t     * @param advice The advice to apply\n\t     */\n\t    function doAfter(method, advice) {\n\t        return createFactory({\n\t            factories: [this],\n\t            advice: (_a = {},\n\t                _a[method] = [['after', advice]],\n\t                _a\n\t            )\n\t        });\n\t        var _a;\n\t    }\n\t    function around() {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i - 0] = arguments[_i];\n\t        }\n\t        var base;\n\t        var method;\n\t        var advice;\n\t        if (args.length >= 3) {\n\t            base = args[0], method = args[1], advice = args[2];\n\t            method = base.prototype[method];\n\t        }\n\t        else {\n\t            method = args[0], advice = args[1];\n\t        }\n\t        return aspect_1.around(method, advice);\n\t    }\n\t    /**\n\t     * The internal implementation to apply around advice when `this` is scoped as the base factory\n\t     *\n\t     * @param method The name of the method that the advice should be applied to\n\t     * @param advice The advice to apply\n\t     */\n\t    function doAround(method, advice) {\n\t        return createFactory({\n\t            factories: [this],\n\t            advice: (_a = {},\n\t                _a[method] = [['around', advice]],\n\t                _a\n\t            )\n\t        });\n\t        var _a;\n\t    }\n\t    /**\n\t     * The internal implementation of applying aspect advice to a factory\n\t     *\n\t     * @param base The base factory the advice should be applied to\n\t     * @param advice The advice map to apply to the factory\n\t     */\n\t    function aspect(base, advice) {\n\t        return createFactory({\n\t            factories: [base],\n\t            advice: aspectAdviceToAdviceMap(advice)\n\t        });\n\t    }\n\t    function create(className, base, initFunction) {\n\t        /* disambugate arguments */\n\t        if (typeof className !== 'string') {\n\t            initFunction = base;\n\t            base = className;\n\t            className = undefined;\n\t        }\n\t        /* Label the initFunction */\n\t        if (initFunction && className) {\n\t            assignFunctionName(initFunction, \"init\" + className);\n\t        }\n\t        var factories;\n\t        var proto;\n\t        /* If base is a compose factory, set it as the factory array */\n\t        if (base && isComposeFactory(base)) {\n\t            factories = [base];\n\t        }\n\t        else {\n\t            proto = typeof base === 'function' ? base.prototype : base;\n\t        }\n\t        return createFactory({\n\t            className: className,\n\t            factories: factories,\n\t            initFunction: initFunction,\n\t            proto: proto\n\t        });\n\t    }\n\t    /**\n\t     * Internal implementation of applying static properties to a compose factory\n\t     *\n\t     * @param factory The factory that the static properties should be applied to\n\t     * @param staticProperties The properties to be applied to the factory\n\t     */\n\t    function _static(base, staticProperties) {\n\t        return createFactory({\n\t            factories: [base],\n\t            staticProperties: staticProperties\n\t        });\n\t    }\n\t    /**\n\t     * A factory construction utility\n\t     *\n\t     * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n\t     * @param initFunction An optional initialization function for the factory\n\t     */\n\t    var compose = create;\n\t    /* Add static methods to compose */\n\t    lang_1.assign(compose, {\n\t        create: create,\n\t        static: _static,\n\t        extend: extend,\n\t        mixin: mixin,\n\t        overlay: overlay,\n\t        from: from,\n\t        before: before,\n\t        after: after,\n\t        around: around,\n\t        aspect: aspect\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = compose;\n\t});\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(22)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    /**\n\t     * Types of advice\n\t     */\n\t    (function (AdviceType) {\n\t        AdviceType[AdviceType[\"Before\"] = 0] = \"Before\";\n\t        AdviceType[AdviceType[\"After\"] = 1] = \"After\";\n\t        AdviceType[AdviceType[\"Around\"] = 2] = \"Around\";\n\t    })(exports.AdviceType || (exports.AdviceType = {}));\n\t    var AdviceType = exports.AdviceType;\n\t    ;\n\t    /**\n\t     * A weak map of dispatchers used to apply the advice\n\t     */\n\t    var dispatchAdviceMap = new WeakMap_1.default();\n\t    /**\n\t     * Returns the dispatcher function for a given joinPoint (method/function)\n\t     *\n\t     * @param joinPoint The function that is to be advised\n\t     */\n\t    function getDispatcher(joinPoint) {\n\t        function dispatcher() {\n\t            var _this = this;\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            var _a = dispatchAdviceMap.get(dispatcher), before = _a.before, after = _a.after, joinPoint = _a.joinPoint;\n\t            if (before) {\n\t                args = before.reduce(function (previousArgs, advice) {\n\t                    var currentArgs = advice.apply(_this, previousArgs);\n\t                    return currentArgs || previousArgs;\n\t                }, args);\n\t            }\n\t            var result = joinPoint.apply(this, args);\n\t            if (after) {\n\t                result = after.reduce(function (previousResult, advice) {\n\t                    return advice.apply(_this, [previousResult].concat(args));\n\t                }, result);\n\t            }\n\t            return result;\n\t        }\n\t        /* We want to \"clone\" the advice that has been applied already, if this\n\t         * joinPoint is already advised */\n\t        if (dispatchAdviceMap.has(joinPoint)) {\n\t            var adviceMap = dispatchAdviceMap.get(joinPoint);\n\t            var before_1 = adviceMap.before, after_1 = adviceMap.after;\n\t            if (before_1) {\n\t                before_1 = before_1.slice(0);\n\t            }\n\t            if (after_1) {\n\t                after_1 = after_1.slice(0);\n\t            }\n\t            dispatchAdviceMap.set(dispatcher, {\n\t                joinPoint: adviceMap.joinPoint,\n\t                before: before_1,\n\t                after: after_1\n\t            });\n\t        }\n\t        else {\n\t            dispatchAdviceMap.set(dispatcher, { joinPoint: joinPoint });\n\t        }\n\t        return dispatcher;\n\t    }\n\t    /**\n\t     * Advise a join point (function) with supplied advice\n\t     *\n\t     * @param joinPoint The function to be advised\n\t     * @param type The type of advice to be applied\n\t     * @param advice The advice to apply\n\t     */\n\t    function advise(joinPoint, type, advice) {\n\t        var dispatcher;\n\t        if (type === AdviceType.Around) {\n\t            dispatcher = getDispatcher(advice.apply(this, [joinPoint]));\n\t        }\n\t        else {\n\t            dispatcher = getDispatcher(joinPoint);\n\t            var adviceMap = dispatchAdviceMap.get(dispatcher);\n\t            if (type === AdviceType.Before) {\n\t                (adviceMap.before || (adviceMap.before = [])).unshift(advice);\n\t            }\n\t            else {\n\t                (adviceMap.after || (adviceMap.after = [])).push(advice);\n\t            }\n\t        }\n\t        return dispatcher;\n\t    }\n\t    /**\n\t     * Apply advice *before* the supplied joinPoint (function)\n\t     *\n\t     * @param joinPoint A function that should have advice applied to\n\t     * @param advice The before advice\n\t     */\n\t    function before(joinPoint, advice) {\n\t        return advise(joinPoint, AdviceType.Before, advice);\n\t    }\n\t    exports.before = before;\n\t    /**\n\t     * Apply advice *after* the supplied joinPoint (function)\n\t     *\n\t     * @param joinPoint A function that should have advice applied to\n\t     * @param advice The after advice\n\t     */\n\t    function after(joinPoint, advice) {\n\t        return advise(joinPoint, AdviceType.After, advice);\n\t    }\n\t    exports.after = after;\n\t    /**\n\t     * Apply advice *around* the supplied joinPoint (function)\n\t     *\n\t     * @param joinPoint A function that should have advice applied to\n\t     * @param advice The around advice\n\t     */\n\t    function around(joinPoint, advice) {\n\t        return advise(joinPoint, AdviceType.Around, advice);\n\t    }\n\t    exports.around = around;\n\t});\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(17), __webpack_require__(11), __webpack_require__(15), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var decorators_1 = __webpack_require__(17);\n\t    var global_1 = __webpack_require__(11);\n\t    var iterator_1 = __webpack_require__(15);\n\t    __webpack_require__(9);\n\t    var Shim;\n\t    (function (Shim) {\n\t        var DELETED = {};\n\t        function getUID() {\n\t            return Math.floor(Math.random() * 100000000);\n\t        }\n\t        var generateName = (function () {\n\t            var startId = Math.floor(Date.now() % 100000000);\n\t            return function generateName() {\n\t                return '__wm' + getUID() + (startId++ + '__');\n\t            };\n\t        })();\n\t        var WeakMap = (function () {\n\t            function WeakMap(iterable) {\n\t                var _this = this;\n\t                this[Symbol.toStringTag] = 'WeakMap';\n\t                Object.defineProperty(this, '_name', {\n\t                    value: generateName()\n\t                });\n\t                this._frozenEntries = [];\n\t                if (iterable) {\n\t                    iterator_1.forOf(iterable, function (_a) {\n\t                        var key = _a[0], value = _a[1];\n\t                        return _this.set(key, value);\n\t                    });\n\t                }\n\t            }\n\t            WeakMap.prototype._getFrozenEntryIndex = function (key) {\n\t                for (var i = 0; i < this._frozenEntries.length; i++) {\n\t                    if (this._frozenEntries[i].key === key) {\n\t                        return i;\n\t                    }\n\t                }\n\t                return -1;\n\t            };\n\t            WeakMap.prototype.delete = function (key) {\n\t                if (key === undefined || key === null) {\n\t                    return false;\n\t                }\n\t                var entry = key[this._name];\n\t                if (entry && entry.key === key && entry.value !== DELETED) {\n\t                    entry.value = DELETED;\n\t                    return true;\n\t                }\n\t                var frozenIndex = this._getFrozenEntryIndex(key);\n\t                if (frozenIndex >= 0) {\n\t                    this._frozenEntries.splice(frozenIndex, 1);\n\t                    return true;\n\t                }\n\t                return false;\n\t            };\n\t            WeakMap.prototype.get = function (key) {\n\t                if (key === undefined || key === null) {\n\t                    return undefined;\n\t                }\n\t                var entry = key[this._name];\n\t                if (entry && entry.key === key && entry.value !== DELETED) {\n\t                    return entry.value;\n\t                }\n\t                var frozenIndex = this._getFrozenEntryIndex(key);\n\t                if (frozenIndex >= 0) {\n\t                    return this._frozenEntries[frozenIndex].value;\n\t                }\n\t            };\n\t            WeakMap.prototype.has = function (key) {\n\t                if (key === undefined || key === null) {\n\t                    return false;\n\t                }\n\t                var entry = key[this._name];\n\t                if (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n\t                    return true;\n\t                }\n\t                var frozenIndex = this._getFrozenEntryIndex(key);\n\t                if (frozenIndex >= 0) {\n\t                    return true;\n\t                }\n\t                return false;\n\t            };\n\t            WeakMap.prototype.set = function (key, value) {\n\t                if (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n\t                    throw new TypeError('Invalid value used as weak map key');\n\t                }\n\t                var entry = key[this._name];\n\t                if (!entry || entry.key !== key) {\n\t                    entry = Object.create(null, {\n\t                        key: { value: key }\n\t                    });\n\t                    if (Object.isFrozen(key)) {\n\t                        this._frozenEntries.push(entry);\n\t                    }\n\t                    else {\n\t                        Object.defineProperty(key, this._name, {\n\t                            value: entry\n\t                        });\n\t                    }\n\t                }\n\t                entry.value = value;\n\t                return this;\n\t            };\n\t            return WeakMap;\n\t        }());\n\t        Shim.WeakMap = WeakMap;\n\t    })(Shim || (Shim = {}));\n\t    var WeakMap = (function () {\n\t        /* istanbul ignore next */\n\t        function WeakMap(iterable) {\n\t            /* istanbul ignore next */\n\t            this[Symbol.toStringTag] = 'WeakMap';\n\t        }\n\t        /* istanbul ignore next */\n\t        WeakMap.prototype.delete = function (key) { throw new Error(); };\n\t        /* istanbul ignore next */\n\t        WeakMap.prototype.get = function (key) { throw new Error(); };\n\t        /* istanbul ignore next */\n\t        WeakMap.prototype.has = function (key) { throw new Error(); };\n\t        /* istanbul ignore next */\n\t        WeakMap.prototype.set = function (key, value) { throw new Error(); };\n\t        WeakMap = __decorate([\n\t            decorators_1.hasClass('es6-weakmap', global_1.default.WeakMap, Shim.WeakMap)\n\t        ], WeakMap);\n\t        return WeakMap;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = WeakMap;\n\t});\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(12), __webpack_require__(10), __webpack_require__(15), __webpack_require__(24)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var has_1 = __webpack_require__(12);\n\t    var util_1 = __webpack_require__(10);\n\t    var iterator_1 = __webpack_require__(15);\n\t    var number_1 = __webpack_require__(24);\n\t    /**\n\t     * Ensures a non-negative, non-infinite, safe integer.\n\t     *\n\t     * @param length The number to validate\n\t     * @return A proper length\n\t     */\n\t    function toLength(length) {\n\t        length = Number(length);\n\t        if (isNaN(length)) {\n\t            return 0;\n\t        }\n\t        if (isFinite(length)) {\n\t            length = Math.floor(length);\n\t        }\n\t        // Ensure a non-negative, real, safe integer\n\t        return Math.min(Math.max(length, 0), number_1.MAX_SAFE_INTEGER);\n\t    }\n\t    /**\n\t     * From ES6 7.1.4 ToInteger()\n\t     *\n\t     * @param value A value to convert\n\t     * @return An integer\n\t     */\n\t    function toInteger(value) {\n\t        value = Number(value);\n\t        if (isNaN(value)) {\n\t            return 0;\n\t        }\n\t        if (value === 0 || !isFinite(value)) {\n\t            return value;\n\t        }\n\t        return (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n\t    }\n\t    /**\n\t     * Normalizes an offset against a given length, wrapping it if negative.\n\t     *\n\t     * @param value The original offset\n\t     * @param length The total length to normalize against\n\t     * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n\t     */\n\t    function normalizeOffset(value, length) {\n\t        return value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n\t    }\n\t    /**\n\t     * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n\t     * the functionality is required or not.\n\t     */\n\t    var Shim;\n\t    (function (Shim) {\n\t        function from(arrayLike, mapFunction, thisArg) {\n\t            if (arrayLike == null) {\n\t                throw new TypeError('from: requires an array-like object');\n\t            }\n\t            if (mapFunction && thisArg) {\n\t                mapFunction = mapFunction.bind(thisArg);\n\t            }\n\t            /* tslint:disable-next-line:variable-name */\n\t            var Constructor = this;\n\t            var length = toLength(arrayLike.length);\n\t            // Support extension\n\t            var array = (typeof Constructor === 'function') ? Object(new Constructor(length)) : new Array(length);\n\t            if (!iterator_1.isArrayLike(arrayLike) && !iterator_1.isIterable(arrayLike)) {\n\t                return array;\n\t            }\n\t            var i = 0;\n\t            iterator_1.forOf(arrayLike, function (value) {\n\t                array[i] = mapFunction ? mapFunction(value, i) : value;\n\t                i++;\n\t            });\n\t            if (arrayLike.length !== undefined) {\n\t                array.length = length;\n\t            }\n\t            return array;\n\t        }\n\t        Shim.from = from;\n\t        function of() {\n\t            var items = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                items[_i - 0] = arguments[_i];\n\t            }\n\t            return Array.prototype.slice.call(items);\n\t        }\n\t        Shim.of = of;\n\t        function copyWithin(target, offset, start, end) {\n\t            if (target == null) {\n\t                throw new TypeError('copyWithin: target must be an array-like object');\n\t            }\n\t            var length = toLength(target.length);\n\t            offset = normalizeOffset(toInteger(offset), length);\n\t            start = normalizeOffset(toInteger(start), length);\n\t            end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t            var count = Math.min(end - start, length - offset);\n\t            var direction = 1;\n\t            if (offset > start && offset < (start + count)) {\n\t                direction = -1;\n\t                start += count - 1;\n\t                offset += count - 1;\n\t            }\n\t            while (count > 0) {\n\t                if (start in target) {\n\t                    target[offset] = target[start];\n\t                }\n\t                else {\n\t                    delete target[offset];\n\t                }\n\t                offset += direction;\n\t                start += direction;\n\t                count--;\n\t            }\n\t            return target;\n\t        }\n\t        Shim.copyWithin = copyWithin;\n\t        function fill(target, value, start, end) {\n\t            var length = toLength(target.length);\n\t            var i = normalizeOffset(toInteger(start), length);\n\t            end = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t            while (i < end) {\n\t                target[i++] = value;\n\t            }\n\t            return target;\n\t        }\n\t        Shim.fill = fill;\n\t        function find(target, callback, thisArg) {\n\t            var index = findIndex(target, callback, thisArg);\n\t            return index !== -1 ? target[index] : undefined;\n\t        }\n\t        Shim.find = find;\n\t        function findIndex(target, callback, thisArg) {\n\t            var length = toLength(target.length);\n\t            if (!callback) {\n\t                throw new TypeError('find: second argument must be a function');\n\t            }\n\t            if (thisArg) {\n\t                callback = callback.bind(thisArg);\n\t            }\n\t            for (var i = 0; i < length; i++) {\n\t                if (callback(target[i], i, target)) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        }\n\t        Shim.findIndex = findIndex;\n\t        function includes(target, searchElement, fromIndex) {\n\t            if (fromIndex === void 0) { fromIndex = 0; }\n\t            var len = toLength(target.length);\n\t            for (var i = fromIndex; i < len; ++i) {\n\t                var currentElement = target[i];\n\t                if (searchElement === currentElement ||\n\t                    (searchElement !== searchElement && currentElement !== currentElement)) {\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t        Shim.includes = includes;\n\t    })(Shim = exports.Shim || (exports.Shim = {}));\n\t    exports.from = has_1.default('es6-array-from')\n\t        ? Array.from\n\t        : Shim.from;\n\t    /**\n\t     * Creates a new array from the function parameters.\n\t     *\n\t     * @param arguments Any number of arguments for the array\n\t     * @return An array from the given arguments\n\t     */\n\t    exports.of = has_1.default('es6-array-of')\n\t        ? Array.of\n\t        : Shim.of;\n\t    /* ES6 Array instance methods */\n\t    /**\n\t     * Copies data internally within an array or array-like object.\n\t     *\n\t     * @param target The target array-like object\n\t     * @param offset The index to start copying values to; if negative, it counts backwards from length\n\t     * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n\t     * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n\t     * @return The target\n\t     */\n\t    exports.copyWithin = has_1.default('es6-array-copywithin')\n\t        ? util_1.wrapNative(Array.prototype.copyWithin)\n\t        : Shim.copyWithin;\n\t    /**\n\t     * Fills elements of an array-like object with the specified value.\n\t     *\n\t     * @param target The target to fill\n\t     * @param value The value to fill each element of the target with\n\t     * @param start The first index to fill\n\t     * @param end The (exclusive) index at which to stop filling\n\t     * @return The filled target\n\t     */\n\t    exports.fill = has_1.default('es6-array-fill')\n\t        ? util_1.wrapNative(Array.prototype.fill)\n\t        : Shim.fill;\n\t    /**\n\t     * Finds and returns the first instance matching the callback or undefined if one is not found.\n\t     *\n\t     * @param target An array-like object\n\t     * @param callback A function returning if the current value matches a criteria\n\t     * @param [thisArg] The execution context for the find function\n\t     * @return The first element matching the callback, or undefined if one does not exist\n\t     */\n\t    exports.find = has_1.default('es6-array-find')\n\t        ? util_1.wrapNative(Array.prototype.find)\n\t        : Shim.find;\n\t    /**\n\t     * Performs a linear search and returns the first index whose value satisfies the passed callback,\n\t     * or -1 if no values satisfy it.\n\t     *\n\t     * @param target An array-like object\n\t     * @param callback A function returning true if the current value satisfies its criteria\n\t     * @param [thisArg] The execution context for the find function\n\t     * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n\t     */\n\t    exports.findIndex = has_1.default('es6-array-findindex')\n\t        ? util_1.wrapNative(Array.prototype.findIndex)\n\t        : Shim.findIndex;\n\t    /* ES7 Array instance methods */\n\t    /**\n\t     * Determines whether an array includes a given value\n\t     *\n\t     * @param target the target array-like object\n\t     * @param searchElement the item to search for\n\t     * @param fromIndex the starting index to search from\n\t     * @return `true` if the array includes the element, otherwise `false`\n\t     */\n\t    exports.includes = has_1.default('es7-array-includes')\n\t        ? util_1.wrapNative(Array.prototype.includes)\n\t        : Shim.includes;\n\t});\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(11)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var global_1 = __webpack_require__(11);\n\t    /**\n\t     * The smallest interval between two representable numbers.\n\t     */\n\t    exports.EPSILON = 1;\n\t    /**\n\t     * The maximum safe integer in JavaScript\n\t     */\n\t    exports.MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t    /**\n\t     * The minimum safe integer in JavaScript\n\t     */\n\t    exports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\n\t    /**\n\t     * Determines whether the passed value is NaN without coersion.\n\t     *\n\t     * @param value The value to test\n\t     * @return true if the value is NaN, false if it is not\n\t     */\n\t    function isNaN(value) {\n\t        return typeof value === 'number' && global_1.default.isNaN(value);\n\t    }\n\t    exports.isNaN = isNaN;\n\t    /**\n\t     * Determines whether the passed value is a finite number without coersion.\n\t     *\n\t     * @param value The value to test\n\t     * @return true if the value is finite, false if it is not\n\t     */\n\t    function isFinite(value) {\n\t        return typeof value === 'number' && global_1.default.isFinite(value);\n\t    }\n\t    exports.isFinite = isFinite;\n\t    /**\n\t     * Determines whether the passed value is an integer.\n\t     *\n\t     * @param value The value to test\n\t     * @return true if the value is an integer, false if it is not\n\t     */\n\t    function isInteger(value) {\n\t        return isFinite(value) && Math.floor(value) === value;\n\t    }\n\t    exports.isInteger = isInteger;\n\t    /**\n\t     * Determines whether the passed value is an integer that is 'safe,' meaning:\n\t     *   1. it can be expressed as an IEEE-754 double precision number\n\t     *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n\t     *      IEEE-754 representation cannot be the result of rounding any other\n\t     *      integer to fit the IEEE-754 representation\n\t     *\n\t     * @param value The value to test\n\t     * @return true if the value is an integer, false if it is not\n\t     */\n\t    function isSafeInteger(value) {\n\t        return isInteger(value) && Math.abs(value) <= exports.MAX_SAFE_INTEGER;\n\t    }\n\t    exports.isSafeInteger = isSafeInteger;\n\t});\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(26)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var has_1 = __webpack_require__(26);\n\t    var slice = Array.prototype.slice;\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t    /**\n\t     * Type guard that ensures that the value can be coerced to Object\n\t     * to weed out host objects that do not derive from Object.\n\t     * This function is used to check if we want to deep copy an object or not.\n\t     * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n\t     * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n\t     * so it is not handled here.\n\t     * @param  value The value to check\n\t     * @return       If the value is coercible into an Object\n\t     */\n\t    function shouldDeepCopyObject(value) {\n\t        return Object.prototype.toString.call(value) === '[object Object]';\n\t    }\n\t    function copyArray(array, inherited) {\n\t        return array.map(function (item) {\n\t            if (Array.isArray(item)) {\n\t                return copyArray(item, inherited);\n\t            }\n\t            return !shouldDeepCopyObject(item) ?\n\t                item :\n\t                _mixin({\n\t                    deep: true,\n\t                    inherited: inherited,\n\t                    sources: [item],\n\t                    target: {}\n\t                });\n\t        });\n\t    }\n\t    function _mixin(kwArgs) {\n\t        var deep = kwArgs.deep;\n\t        var inherited = kwArgs.inherited;\n\t        var target = kwArgs.target;\n\t        for (var _i = 0, _a = kwArgs.sources; _i < _a.length; _i++) {\n\t            var source = _a[_i];\n\t            if (source === null || source === undefined) {\n\t                continue;\n\t            }\n\t            for (var key in source) {\n\t                if (inherited || hasOwnProperty.call(source, key)) {\n\t                    var value = source[key];\n\t                    if (deep) {\n\t                        if (Array.isArray(value)) {\n\t                            value = copyArray(value, inherited);\n\t                        }\n\t                        else if (shouldDeepCopyObject(value)) {\n\t                            value = _mixin({\n\t                                deep: true,\n\t                                inherited: inherited,\n\t                                sources: [value],\n\t                                target: {}\n\t                            });\n\t                        }\n\t                    }\n\t                    target[key] = value;\n\t                }\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t    /**\n\t     * Copies the values of all enumerable own properties of one or more source objects to the target object.\n\t     *\n\t     * @param target The target object to receive values from source objects\n\t     * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n\t     * @return The modified target object\n\t     */\n\t    exports.assign = has_1.default('object-assign') ?\n\t        Object.assign :\n\t        function (target) {\n\t            var sources = [];\n\t            for (var _i = 1; _i < arguments.length; _i++) {\n\t                sources[_i - 1] = arguments[_i];\n\t            }\n\t            return _mixin({\n\t                deep: false,\n\t                inherited: false,\n\t                sources: sources,\n\t                target: target\n\t            });\n\t        };\n\t    function create(prototype) {\n\t        var mixins = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            mixins[_i - 1] = arguments[_i];\n\t        }\n\t        if (!mixins.length) {\n\t            throw new RangeError('lang.create requires at least one mixin object.');\n\t        }\n\t        var args = mixins.slice();\n\t        args.unshift(Object.create(prototype));\n\t        return exports.assign.apply(null, args);\n\t    }\n\t    exports.create = create;\n\t    function deepAssign(target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        return _mixin({\n\t            deep: true,\n\t            inherited: false,\n\t            sources: sources,\n\t            target: target\n\t        });\n\t    }\n\t    exports.deepAssign = deepAssign;\n\t    function deepMixin(target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        return _mixin({\n\t            deep: true,\n\t            inherited: true,\n\t            sources: sources,\n\t            target: target\n\t        });\n\t    }\n\t    exports.deepMixin = deepMixin;\n\t    /**\n\t     * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n\t     * deep copies the provided source's values into the new target.\n\t     *\n\t     * @param source The object to duplicate\n\t     * @return The new object\n\t     */\n\t    function duplicate(source) {\n\t        var target = Object.create(Object.getPrototypeOf(source));\n\t        return deepMixin(target, source);\n\t    }\n\t    exports.duplicate = duplicate;\n\t    /**\n\t     * Determines whether two values are the same value.\n\t     *\n\t     * @param a First value to compare\n\t     * @param b Second value to compare\n\t     * @return true if the values are the same; false otherwise\n\t     */\n\t    function isIdentical(a, b) {\n\t        return a === b ||\n\t            /* both values are NaN */\n\t            (a !== a && b !== b);\n\t    }\n\t    exports.isIdentical = isIdentical;\n\t    /**\n\t     * Returns a function that binds a method to the specified object at runtime. This is similar to\n\t     * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n\t     * As a result, the function returned by `lateBind` will always call the function currently assigned to\n\t     * the specified property on the object as of the moment the function it returns is called.\n\t     *\n\t     * @param instance The context object\n\t     * @param method The name of the method on the context object to bind to itself\n\t     * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n\t     * @return The bound function\n\t     */\n\t    function lateBind(instance, method) {\n\t        var suppliedArgs = [];\n\t        for (var _i = 2; _i < arguments.length; _i++) {\n\t            suppliedArgs[_i - 2] = arguments[_i];\n\t        }\n\t        return suppliedArgs.length ?\n\t            function () {\n\t                var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t                // TS7017\n\t                return instance[method].apply(instance, args);\n\t            } :\n\t            function () {\n\t                // TS7017\n\t                return instance[method].apply(instance, arguments);\n\t            };\n\t    }\n\t    exports.lateBind = lateBind;\n\t    function mixin(target) {\n\t        var sources = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            sources[_i - 1] = arguments[_i];\n\t        }\n\t        return _mixin({\n\t            deep: false,\n\t            inherited: true,\n\t            sources: sources,\n\t            target: target\n\t        });\n\t    }\n\t    exports.mixin = mixin;\n\t    /**\n\t     * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n\t     * Like `Function.prototype.bind`, but does not alter execution context.\n\t     *\n\t     * @param targetFunction The function that needs to be bound\n\t     * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n\t     * @return The bound function\n\t     */\n\t    function partial(targetFunction) {\n\t        var suppliedArgs = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            suppliedArgs[_i - 1] = arguments[_i];\n\t        }\n\t        return function () {\n\t            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\t            return targetFunction.apply(this, args);\n\t        };\n\t    }\n\t    exports.partial = partial;\n\t    /**\n\t     * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n\t     * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n\t     * event listeners, timers, etc.\n\t     *\n\t     * @param destructor A function that will be called when the handle's `destroy` method is invoked\n\t     * @return The handle object\n\t     */\n\t    function createHandle(destructor) {\n\t        return {\n\t            destroy: function () {\n\t                this.destroy = function () { };\n\t                destructor.call(this);\n\t            }\n\t        };\n\t    }\n\t    exports.createHandle = createHandle;\n\t    /**\n\t     * Returns a single handle that can be used to destroy multiple handles simultaneously.\n\t     *\n\t     * @param handles An array of handles with `destroy` methods\n\t     * @return The handle object\n\t     */\n\t    function createCompositeHandle() {\n\t        var handles = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            handles[_i - 0] = arguments[_i];\n\t        }\n\t        return createHandle(function () {\n\t            for (var _i = 0, handles_1 = handles; _i < handles_1.length; _i++) {\n\t                var handle = handles_1[_i];\n\t                handle.destroy();\n\t            }\n\t        });\n\t    }\n\t    exports.createCompositeHandle = createCompositeHandle;\n\t});\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(27), __webpack_require__(12), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    function __export(m) {\n\t        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t    }\n\t    var global_1 = __webpack_require__(27);\n\t    var has_1 = __webpack_require__(12);\n\t    __export(__webpack_require__(12));\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = has_1.default;\n\t    has_1.add('object-assign', typeof global_1.default.Object.assign === 'function');\n\t    has_1.add('raf', typeof requestAnimationFrame === 'function');\n\t    has_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined');\n\t    has_1.add('formdata', typeof global_1.default.FormData !== 'undefined');\n\t    has_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined');\n\t    has_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype);\n\t    has_1.add('xhr2-blob', function () {\n\t        if (!has_1.default('xhr2')) {\n\t            return false;\n\t        }\n\t        var request = new XMLHttpRequest();\n\t        request.open('GET', '/', true);\n\t        request.responseType = 'blob';\n\t        request.abort();\n\t        return request.responseType === 'blob';\n\t    });\n\t});\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var globalObject = (function () {\n\t        if (typeof window !== 'undefined') {\n\t            // Browsers\n\t            return window;\n\t        }\n\t        else if (typeof global !== 'undefined') {\n\t            // Node\n\t            return global;\n\t        }\n\t        else if (typeof self !== 'undefined') {\n\t            // Web workers\n\t            return self;\n\t        }\n\t        return {};\n\t    })();\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = globalObject;\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(11), __webpack_require__(29), __webpack_require__(15), __webpack_require__(9), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var global_1 = __webpack_require__(11);\n\t    var queue_1 = __webpack_require__(29);\n\t    var iterator_1 = __webpack_require__(15);\n\t    __webpack_require__(9);\n\t    var decorators_1 = __webpack_require__(17);\n\t    var Shim;\n\t    (function (Shim) {\n\t        /**\n\t         * Returns true if a given value has a `then` method.\n\t         * @param {any} value The value to check if is Thenable\n\t         * @returns {is Thenable<T>} A type guard if the value is thenable\n\t         */\n\t        function isThenable(value) {\n\t            return value && typeof value.then === 'function';\n\t        }\n\t        Shim.isThenable = isThenable;\n\t        /**\n\t         * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t         * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t         * not intended to be used directly.\n\t         *\n\t         * @borrows Promise.all as Promise.all\n\t         * @borrows Promise.race as Promise.race\n\t         * @borrows Promise.reject as Promise.reject\n\t         * @borrows Promise.resolve as Promise.resolve\n\t         * @borrows Promise#catch as Promise#catch\n\t         * @borrows Promise#then as Promise#then\n\t         */\n\t        var Promise = (function () {\n\t            /**\n\t             * Creates a new Promise.\n\t             *\n\t             * @constructor\n\t             *\n\t             * @param executor\n\t             * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t             * starting the asynchronous operation when it is invoked.\n\t             *\n\t             * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t             * successfully, or the `reject` function when the operation fails.\n\t             */\n\t            function Promise(executor) {\n\t                var _this = this;\n\t                /**\n\t                 * The current state of this promise.\n\t                 */\n\t                this.state = 1 /* Pending */;\n\t                this[Symbol.toStringTag] = 'Promise';\n\t                /**\n\t                 * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t                 */\n\t                var isChained = false;\n\t                /**\n\t                 * Whether or not this promise is in a resolved state.\n\t                 */\n\t                var isResolved = function () {\n\t                    return _this.state !== 1 /* Pending */ || isChained;\n\t                };\n\t                /**\n\t                 * Callbacks that should be invoked once the asynchronous operation has completed.\n\t                 */\n\t                var callbacks = [];\n\t                /**\n\t                 * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t                 * enqueues callbacks for execution on the next event loop turn.\n\t                 */\n\t                var whenFinished = function (callback) {\n\t                    if (callbacks) {\n\t                        callbacks.push(callback);\n\t                    }\n\t                };\n\t                /**\n\t                 * Settles this promise.\n\t                 *\n\t                 * @param newState The resolved state for this promise.\n\t                 * @param {T|Error} value The resolved value for this promise.\n\t                 */\n\t                var settle = function (newState, value) {\n\t                    // A promise can only be settled once.\n\t                    if (_this.state !== 1 /* Pending */) {\n\t                        return;\n\t                    }\n\t                    _this.state = newState;\n\t                    _this.resolvedValue = value;\n\t                    whenFinished = queue_1.queueMicroTask;\n\t                    // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t                    // wait an extra turn.\n\t                    if (callbacks && callbacks.length > 0) {\n\t                        queue_1.queueMicroTask(function () {\n\t                            if (callbacks) {\n\t                                var count = callbacks.length;\n\t                                for (var i = 0; i < count; ++i) {\n\t                                    callbacks[i].call(null);\n\t                                }\n\t                                callbacks = null;\n\t                            }\n\t                        });\n\t                    }\n\t                };\n\t                /**\n\t                 * Resolves this promise.\n\t                 *\n\t                 * @param newState The resolved state for this promise.\n\t                 * @param {T|Error} value The resolved value for this promise.\n\t                 */\n\t                var resolve = function (newState, value) {\n\t                    if (isResolved()) {\n\t                        return;\n\t                    }\n\t                    if (isThenable(value)) {\n\t                        value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));\n\t                        isChained = true;\n\t                    }\n\t                    else {\n\t                        settle(newState, value);\n\t                    }\n\t                };\n\t                this.then = function (onFulfilled, onRejected) {\n\t                    return new Promise(function (resolve, reject) {\n\t                        // whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t                        // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t                        // event loop.\n\t                        whenFinished(function () {\n\t                            var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;\n\t                            if (typeof callback === 'function') {\n\t                                try {\n\t                                    resolve(callback(_this.resolvedValue));\n\t                                }\n\t                                catch (error) {\n\t                                    reject(error);\n\t                                }\n\t                            }\n\t                            else if (_this.state === 2 /* Rejected */) {\n\t                                reject(_this.resolvedValue);\n\t                            }\n\t                            else {\n\t                                resolve(_this.resolvedValue);\n\t                            }\n\t                        });\n\t                    });\n\t                };\n\t                try {\n\t                    executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));\n\t                }\n\t                catch (error) {\n\t                    settle(2 /* Rejected */, error);\n\t                }\n\t            }\n\t            Promise.all = function (iterable) {\n\t                return new this(function (resolve, reject) {\n\t                    var values = [];\n\t                    var complete = 0;\n\t                    var total = 0;\n\t                    var populating = true;\n\t                    function fulfill(index, value) {\n\t                        values[index] = value;\n\t                        ++complete;\n\t                        finish();\n\t                    }\n\t                    function finish() {\n\t                        if (populating || complete < total) {\n\t                            return;\n\t                        }\n\t                        resolve(values);\n\t                    }\n\t                    function processItem(index, item) {\n\t                        ++total;\n\t                        if (item instanceof Promise) {\n\t                            // If an item Promise rejects, this Promise is immediately rejected with the item\n\t                            // Promise's rejection error.\n\t                            item.then(fulfill.bind(null, index), reject);\n\t                        }\n\t                        else {\n\t                            Promise.resolve(item).then(fulfill.bind(null, index));\n\t                        }\n\t                    }\n\t                    var i = 0;\n\t                    iterator_1.forOf(iterable, function (value) {\n\t                        processItem(i, value);\n\t                        i++;\n\t                    });\n\t                    populating = false;\n\t                    finish();\n\t                });\n\t            };\n\t            Promise.race = function (iterable) {\n\t                return new this(function (resolve, reject) {\n\t                    iterator_1.forOf(iterable, function (item) {\n\t                        if (item instanceof Promise) {\n\t                            // If a Promise item rejects, this Promise is immediately rejected with the item\n\t                            // Promise's rejection error.\n\t                            item.then(resolve, reject);\n\t                        }\n\t                        else {\n\t                            Promise.resolve(item).then(resolve);\n\t                        }\n\t                    });\n\t                });\n\t            };\n\t            Promise.reject = function (reason) {\n\t                return new this(function (resolve, reject) {\n\t                    reject(reason);\n\t                });\n\t            };\n\t            Promise.resolve = function (value) {\n\t                return new this(function (resolve) {\n\t                    resolve(value);\n\t                });\n\t            };\n\t            Promise.prototype.catch = function (onRejected) {\n\t                return this.then(undefined, onRejected);\n\t            };\n\t            return Promise;\n\t        }());\n\t        Shim.Promise = Promise;\n\t    })(Shim || (Shim = {}));\n\t    var Promise = (function () {\n\t        /**\n\t         * Creates a new Promise.\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param executor\n\t         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t         * starting the asynchronous operation when it is invoked.\n\t         *\n\t         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t         * successfully, or the `reject` function when the operation fails.\n\t         */\n\t        /* istanbul ignore next */\n\t        function Promise(executor) {\n\t        }\n\t        /**\n\t         * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t         * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t         * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t         *\n\t         * @example\n\t         * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t         *     value[0] === 'foo'; // true\n\t         *     value[1] === 'bar'; // true\n\t         * });\n\t         *\n\t         * @example\n\t         * Promise.all({\n\t         *     foo: Promise.resolve('foo'),\n\t         *     bar: 'bar'\n\t         * }).then((value) => {\n\t         *     value.foo === 'foo'; // true\n\t         *     value.bar === 'bar'; // true\n\t         * });\n\t         */\n\t        /* istanbul ignore next */\n\t        Promise.all = function (iterable) {\n\t            throw new Error();\n\t        };\n\t        ;\n\t        /**\n\t         * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t         * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t         * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t         *\n\t         * @example\n\t         * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t         *     value === 'foo'; // true\n\t         * });\n\t         *\n\t         * @example\n\t         * Promise.race({\n\t         *     foo: Promise.resolve('foo'),\n\t         *     bar: Promise.resolve('bar')\n\t         * }).then((value) => {\n\t         *     value === 'foo'; // true\n\t         * });\n\t         */\n\t        /* istanbul ignore next */\n\t        Promise.race = function (iterable) {\n\t            throw new Error();\n\t        };\n\t        /**\n\t         * Creates a new promise that is rejected with the given error.\n\t         */\n\t        /* istanbul ignore next */\n\t        Promise.reject = function (reason) {\n\t            throw new Error();\n\t        };\n\t        /* istanbul ignore next */\n\t        Promise.resolve = function (value) {\n\t            throw new Error();\n\t        };\n\t        /* istanbul ignore next */\n\t        Promise.prototype.catch = function (onRejected) {\n\t            throw new Error();\n\t        };\n\t        /* istanbul ignore next */\n\t        Promise.prototype.then = function (onFulfilled, onRejected) {\n\t            throw new Error();\n\t        };\n\t        Promise = __decorate([\n\t            decorators_1.hasClass('es6-promise', global_1.default.Promise, Shim.Promise)\n\t        ], Promise);\n\t        return Promise;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = Promise;\n\t});\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate, process) {(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(11), __webpack_require__(12)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var global_1 = __webpack_require__(11);\n\t    var has_1 = __webpack_require__(12);\n\t    /**\n\t     * Executes a task\n\t     * @param item The task to execute\n\t     */\n\t    function executeTask(item) {\n\t        if (item && item.isActive) {\n\t            item.callback();\n\t        }\n\t    }\n\t    /**\n\t     * Get a handle to be able to remove an item from the queue\n\t     */\n\t    function getQueueHandle(item, destructor) {\n\t        return {\n\t            destroy: function () {\n\t                this.destroy = function () { };\n\t                if (item) {\n\t                    item.isActive = false;\n\t                }\n\t                if (destructor) {\n\t                    destructor();\n\t                }\n\t            }\n\t        };\n\t    }\n\t    var microTasks = [];\n\t    var microTaskQueued = false;\n\t    var checkMicroTaskQueue = function () { };\n\t    /**\n\t     * Schedules a callback to the macrotask queue.\n\t     *\n\t     * @param callback the function to be queued and later executed.\n\t     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t     */\n\t    exports.queueTask = (function () {\n\t        var destructor;\n\t        var enqueue;\n\t        /* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n\t        if (has_1.default('postmessage')) {\n\t            var queue_1 = [];\n\t            addEventListener('message', function (event) {\n\t                // Confirm that the event was triggered by the current window and by this particular implementation.\n\t                if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n\t                    event.stopPropagation();\n\t                    if (queue_1.length) {\n\t                        executeTask(queue_1.shift());\n\t                    }\n\t                }\n\t            });\n\t            enqueue = function (item) {\n\t                queue_1.push(item);\n\t                postMessage('dojo-queue-message', '*');\n\t            };\n\t        }\n\t        else if (has_1.default('setimmediate')) {\n\t            destructor = clearImmediate;\n\t            enqueue = function (item) {\n\t                return setImmediate(executeTask.bind(null, item));\n\t            };\n\t        }\n\t        else {\n\t            destructor = clearTimeout;\n\t            enqueue = function (item) {\n\t                return setTimeout(executeTask.bind(null, item), 0);\n\t            };\n\t        }\n\t        function queueTask(callback) {\n\t            var item = {\n\t                isActive: true,\n\t                callback: callback\n\t            };\n\t            var id = enqueue(item);\n\t            return getQueueHandle(item, destructor && function () {\n\t                destructor(id);\n\t            });\n\t        }\n\t        ;\n\t        // TODO: Use aspect.before when it is available.\n\t        return has_1.default('microtasks') ? queueTask : function (callback) {\n\t            checkMicroTaskQueue();\n\t            return queueTask(callback);\n\t        };\n\t    })();\n\t    checkMicroTaskQueue = !has_1.default('microtasks')\n\t        ? function () {\n\t            if (!microTaskQueued) {\n\t                microTaskQueued = true;\n\t                exports.queueTask(function () {\n\t                    microTaskQueued = false;\n\t                    if (microTasks.length) {\n\t                        var item = void 0;\n\t                        while (item = microTasks.shift()) {\n\t                            executeTask(item);\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        } : checkMicroTaskQueue;\n\t    /**\n\t     * Schedules a callback to the microtask queue.\n\t     *\n\t     * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n\t     * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n\t     * registered with `queueTask` or `queueAnimationTask`.\n\t     *\n\t     * @param callback the function to be queued and later executed.\n\t     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t     */\n\t    exports.queueMicroTask = (function () {\n\t        var enqueue;\n\t        if (has_1.default('host-node')) {\n\t            enqueue = function (item) {\n\t                process.nextTick(executeTask.bind(null, item));\n\t            };\n\t        }\n\t        else if (has_1.default('es6-promise') && !has_1.default('setimmediate') && !has_1.default('host-node')) {\n\t            enqueue = function (item) {\n\t                global_1.default.Promise.resolve(item).then(executeTask);\n\t            };\n\t        }\n\t        else if (has_1.default('dom-mutationobserver')) {\n\t            /* tslint:disable-next-line:variable-name */\n\t            var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n\t            var node_1 = document.createElement('div');\n\t            var queue_2 = [];\n\t            var observer = new HostMutationObserver(function () {\n\t                while (queue_2.length > 0) {\n\t                    var item = queue_2.shift();\n\t                    if (item && item.isActive) {\n\t                        item.callback();\n\t                    }\n\t                }\n\t            });\n\t            observer.observe(node_1, { attributes: true });\n\t            enqueue = function (item) {\n\t                queue_2.push(item);\n\t                node_1.setAttribute('queueStatus', '1');\n\t            };\n\t        }\n\t        else {\n\t            enqueue = function (item) {\n\t                checkMicroTaskQueue();\n\t                microTasks.push(item);\n\t            };\n\t        }\n\t        return function (callback) {\n\t            var item = {\n\t                isActive: true,\n\t                callback: callback\n\t            };\n\t            enqueue(item);\n\t            return getQueueHandle(item);\n\t        };\n\t    })();\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30).clearImmediate, __webpack_require__(30).setImmediate, __webpack_require__(14)))\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(14).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30).setImmediate, __webpack_require__(30).clearImmediate))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\t(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(17), __webpack_require__(11), __webpack_require__(15), __webpack_require__(32), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var decorators_1 = __webpack_require__(17);\n\t    var global_1 = __webpack_require__(11);\n\t    var iterator_1 = __webpack_require__(15);\n\t    var object_1 = __webpack_require__(32);\n\t    __webpack_require__(9);\n\t    var Shim;\n\t    (function (Shim) {\n\t        /**\n\t         * An implementation analogous to the Map specification in ES2015.\n\t         */\n\t        var Map = (function () {\n\t            /**\n\t             * Creates a new Map\n\t             *\n\t             * @constructor\n\t             *\n\t             * @param iterator\n\t             * Array or iterator containing two-item tuples used to initially populate the map.\n\t             * The first item in each tuple corresponds to the key of the map entry.\n\t             * The second item corresponds to the value of the map entry.\n\t             */\n\t            function Map(iterable) {\n\t                var _this = this;\n\t                this._keys = [];\n\t                this._values = [];\n\t                this[Symbol.toStringTag] = 'Map';\n\t                if (iterable) {\n\t                    iterator_1.forOf(iterable, function (value) {\n\t                        _this.set(value[0], value[1]);\n\t                    });\n\t                }\n\t            }\n\t            /**\n\t             * An alternative to Array.prototype.indexOf using Object.is\n\t             * to check for equality. See http://mzl.la/1zuKO2V\n\t             */\n\t            Map.prototype._indexOfKey = function (keys, key) {\n\t                for (var i = 0, length_1 = keys.length; i < length_1; i++) {\n\t                    if (object_1.is(keys[i], key)) {\n\t                        return i;\n\t                    }\n\t                }\n\t                return -1;\n\t            };\n\t            Object.defineProperty(Map.prototype, \"size\", {\n\t                /**\n\t                 * Returns the number of key / value pairs in the Map.\n\t                 *\n\t                 * @return the number of key / value pairs in the Map\n\t                 */\n\t                get: function () {\n\t                    return this._keys.length;\n\t                },\n\t                enumerable: true,\n\t                configurable: true\n\t            });\n\t            /**\n\t             * Deletes all keys and their associated values.\n\t             */\n\t            Map.prototype.clear = function () {\n\t                this._keys.length = this._values.length = 0;\n\t            };\n\t            /**\n\t             * Deletes a given key and its associated value.\n\t             *\n\t             * @param key The key to delete\n\t             * @return true if the key exists, false if it does not\n\t             */\n\t            Map.prototype.delete = function (key) {\n\t                var index = this._indexOfKey(this._keys, key);\n\t                if (index < 0) {\n\t                    return false;\n\t                }\n\t                this._keys.splice(index, 1);\n\t                this._values.splice(index, 1);\n\t                return true;\n\t            };\n\t            /**\n\t             * Returns an iterator that yields each key/value pair as an array.\n\t             *\n\t             * @return An iterator for each key/value pair in the instance.\n\t             */\n\t            Map.prototype.entries = function () {\n\t                var _this = this;\n\t                var values = this._keys.map(function (key, i) {\n\t                    return [key, _this._values[i]];\n\t                });\n\t                return new iterator_1.ShimIterator(values);\n\t            };\n\t            /**\n\t             * Executes a given function for each map entry. The function\n\t             * is invoked with three arguments: the element value, the\n\t             * element key, and the associated Map instance.\n\t             *\n\t             * @param callback The function to execute for each map entry,\n\t             * @param context The value to use for `this` for each execution of the calback\n\t             */\n\t            Map.prototype.forEach = function (callback, context) {\n\t                var keys = this._keys;\n\t                var values = this._values;\n\t                for (var i = 0, length_2 = keys.length; i < length_2; i++) {\n\t                    callback.call(context, values[i], keys[i], this);\n\t                }\n\t            };\n\t            /**\n\t             * Returns the value associated with a given key.\n\t             *\n\t             * @param key The key to look up\n\t             * @return The value if one exists or undefined\n\t             */\n\t            Map.prototype.get = function (key) {\n\t                var index = this._indexOfKey(this._keys, key);\n\t                return index < 0 ? undefined : this._values[index];\n\t            };\n\t            /**\n\t             * Checks for the presence of a given key.\n\t             *\n\t             * @param key The key to check for\n\t             * @return true if the key exists, false if it does not\n\t             */\n\t            Map.prototype.has = function (key) {\n\t                return this._indexOfKey(this._keys, key) > -1;\n\t            };\n\t            /**\n\t             * Returns an iterator that yields each key in the map.\n\t             *\n\t             * @return An iterator containing the instance's keys.\n\t             */\n\t            Map.prototype.keys = function () {\n\t                return new iterator_1.ShimIterator(this._keys);\n\t            };\n\t            /**\n\t             * Sets the value associated with a given key.\n\t             *\n\t             * @param key The key to define a value to\n\t             * @param value The value to assign\n\t             * @return The Map instance\n\t             */\n\t            Map.prototype.set = function (key, value) {\n\t                var index = this._indexOfKey(this._keys, key);\n\t                index = index < 0 ? this._keys.length : index;\n\t                this._keys[index] = key;\n\t                this._values[index] = value;\n\t                return this;\n\t            };\n\t            /**\n\t             * Returns an iterator that yields each value in the map.\n\t             *\n\t             * @return An iterator containing the instance's values.\n\t             */\n\t            Map.prototype.values = function () {\n\t                return new iterator_1.ShimIterator(this._values);\n\t            };\n\t            Map.prototype[Symbol.iterator] = function () {\n\t                return this.entries();\n\t            };\n\t            return Map;\n\t        }());\n\t        Shim.Map = Map;\n\t    })(Shim = exports.Shim || (exports.Shim = {}));\n\t    var Map = (function () {\n\t        /* istanbul ignore next */\n\t        function Map(iterable) {\n\t            /* istanbul ignore next */\n\t            this[Symbol.toStringTag] = 'Map';\n\t        }\n\t        ;\n\t        Object.defineProperty(Map.prototype, \"size\", {\n\t            /* istanbul ignore next */\n\t            get: function () { throw new Error('Abstract method'); },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.clear = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.delete = function (key) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.entries = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.forEach = function (callback, context) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.get = function (key) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.has = function (key) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.keys = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.set = function (key, value) { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype.values = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        /* istanbul ignore next */\n\t        Map.prototype[Symbol.iterator] = function () { throw new Error('Abstract method'); };\n\t        ;\n\t        Map = __decorate([\n\t            decorators_1.hasClass('es6-map', global_1.default.Map, Shim.Map)\n\t        ], Map);\n\t        return Map;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = Map;\n\t});\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    __webpack_require__(9);\n\t    var Shim;\n\t    (function (Shim) {\n\t        function is(value1, value2) {\n\t            if (value1 === value2) {\n\t                return value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t            }\n\t            return value1 !== value1 && value2 !== value2; // NaN\n\t        }\n\t        Shim.is = is;\n\t        function getOwnPropertySymbols(o) {\n\t            return Object.getOwnPropertyNames(o).filter(function (key) { return Boolean(key.match(/^@@.+/)); })\n\t                .map(function (key) { return Symbol.for(key.substring(2)); });\n\t        }\n\t        Shim.getOwnPropertySymbols = getOwnPropertySymbols;\n\t        function getOwnPropertyNames(o) {\n\t            return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });\n\t        }\n\t        Shim.getOwnPropertyNames = getOwnPropertyNames;\n\t    })(Shim || (Shim = {}));\n\t    /**\n\t     * Determines whether two values are the same value.\n\t     *\n\t     * @param value1 The first value to compare\n\t     * @param value2 The second value to compare\n\t     * @return true if the values are the same; false otherwise\n\t     */\n\t    exports.is = 'is' in Object\n\t        ? Object.is\n\t        : Shim.is;\n\t    /**\n\t     * Returns an array of own properties who key is a symbol\n\t     *\n\t     * @param o The object to return the properties for\n\t     */\n\t    exports.getOwnPropertySymbols = 'getOwnPropertySymbols' in Object\n\t        ? Object.getOwnPropertySymbols\n\t        : Shim.getOwnPropertySymbols;\n\t    /**\n\t     * Returns an array of own properties who key is a string\n\t     *\n\t     * @param o The object to return the properties for\n\t     */\n\t    /* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n\t     * when there is no support for symbols */\n\t    exports.getOwnPropertyNames = 'getOwnPropertySymbols' in Object\n\t        ? Object.getOwnPropertyNames\n\t        : Shim.getOwnPropertyNames;\n\t});\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(25)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var lang_1 = __webpack_require__(25);\n\t    /**\n\t     * An internal type guard that determines if an value is MapLike or not\n\t     *\n\t     * @param value The value to guard against\n\t     */\n\t    function isMapLike(value) {\n\t        return value && typeof value.get === 'function' && typeof value.set === 'function';\n\t    }\n\t    /**\n\t     * A UID for tracking advice ordering\n\t     */\n\t    var nextId = 0;\n\t    /**\n\t     * Internal function that advises a join point\n\t     *\n\t     * @param dispatcher The current advice dispatcher\n\t     * @param type The type of before or after advice to apply\n\t     * @param advice The advice to apply\n\t     * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n\t     * @return The handle that will remove the advice\n\t     */\n\t    function advise(dispatcher, type, advice, receiveArguments) {\n\t        var previous = dispatcher && dispatcher[type];\n\t        var advised = {\n\t            id: nextId++,\n\t            advice: advice,\n\t            receiveArguments: receiveArguments\n\t        };\n\t        if (previous) {\n\t            if (type === 'after') {\n\t                // add the listener to the end of the list\n\t                // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t                while (previous.next && (previous = previous.next)) { }\n\t                previous.next = advised;\n\t                advised.previous = previous;\n\t            }\n\t            else {\n\t                // add to the beginning\n\t                if (dispatcher) {\n\t                    dispatcher.before = advised;\n\t                }\n\t                advised.next = previous;\n\t                previous.previous = advised;\n\t            }\n\t        }\n\t        else {\n\t            dispatcher && (dispatcher[type] = advised);\n\t        }\n\t        advice = previous = undefined;\n\t        return lang_1.createHandle(function () {\n\t            var _a = (advised || {}), _b = _a.previous, previous = _b === void 0 ? undefined : _b, _c = _a.next, next = _c === void 0 ? undefined : _c;\n\t            if (dispatcher && !previous && !next) {\n\t                dispatcher[type] = undefined;\n\t            }\n\t            else {\n\t                if (previous) {\n\t                    previous.next = next;\n\t                }\n\t                else {\n\t                    dispatcher && (dispatcher[type] = next);\n\t                }\n\t                if (next) {\n\t                    next.previous = previous;\n\t                }\n\t            }\n\t            if (advised) {\n\t                delete advised.advice;\n\t            }\n\t            dispatcher = advised = undefined;\n\t        });\n\t    }\n\t    /**\n\t     * An internal function that resolves or creates the dispatcher for a given join point\n\t     *\n\t     * @param target The target object or map\n\t     * @param methodName The name of the method that the dispatcher should be resolved for\n\t     * @return The dispatcher\n\t     */\n\t    function getDispatcher(target, methodName) {\n\t        var existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\t        var dispatcher;\n\t        if (!existing || existing.target !== target) {\n\t            /* There is no existing dispatcher, therefore we will create one */\n\t            dispatcher = function () {\n\t                var executionId = nextId;\n\t                var args = arguments;\n\t                var results;\n\t                var before = dispatcher.before;\n\t                while (before) {\n\t                    if (before.advice) {\n\t                        args = before.advice.apply(this, args) || args;\n\t                    }\n\t                    before = before.next;\n\t                }\n\t                if (dispatcher.around && dispatcher.around.advice) {\n\t                    results = dispatcher.around.advice(this, args);\n\t                }\n\t                var after = dispatcher.after;\n\t                while (after && after.id < executionId) {\n\t                    if (after.advice) {\n\t                        if (after.receiveArguments) {\n\t                            var newResults = after.advice.apply(this, args);\n\t                            results = newResults === undefined ? results : newResults;\n\t                        }\n\t                        else {\n\t                            results = after.advice.call(this, results, args);\n\t                        }\n\t                    }\n\t                    after = after.next;\n\t                }\n\t                return results;\n\t            };\n\t            if (isMapLike(target)) {\n\t                target.set(methodName, dispatcher);\n\t            }\n\t            else {\n\t                target && (target[methodName] = dispatcher);\n\t            }\n\t            if (existing) {\n\t                dispatcher.around = {\n\t                    advice: function (target, args) {\n\t                        return existing.apply(target, args);\n\t                    }\n\t                };\n\t            }\n\t            dispatcher.target = target;\n\t        }\n\t        else {\n\t            dispatcher = existing;\n\t        }\n\t        return dispatcher;\n\t    }\n\t    /**\n\t     * Attaches \"after\" advice to be executed after the original method.\n\t     * The advising function will receive the original method's return value and arguments object.\n\t     * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n\t     *\n\t     * @param target Object whose method will be aspected\n\t     * @param methodName Name of method to aspect\n\t     * @param advice Advising function which will receive the original method's return value and arguments object\n\t     * @return A handle which will remove the aspect when destroy is called\n\t     */\n\t    function after(target, methodName, advice) {\n\t        return advise(getDispatcher(target, methodName), 'after', advice);\n\t    }\n\t    exports.after = after;\n\t    /**\n\t     * Attaches \"around\" advice around the original method.\n\t     *\n\t     * @param target Object whose method will be aspected\n\t     * @param methodName Name of method to aspect\n\t     * @param advice Advising function which will receive the original function\n\t     * @return A handle which will remove the aspect when destroy is called\n\t     */\n\t    function around(target, methodName, advice) {\n\t        var dispatcher = getDispatcher(target, methodName);\n\t        var previous = dispatcher.around;\n\t        var advised;\n\t        if (advice) {\n\t            advised = advice(function () {\n\t                if (previous && previous.advice) {\n\t                    return previous.advice(this, arguments);\n\t                }\n\t            });\n\t        }\n\t        dispatcher.around = {\n\t            advice: function (target, args) {\n\t                return advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t            }\n\t        };\n\t        return lang_1.createHandle(function () {\n\t            advised = dispatcher = undefined;\n\t        });\n\t    }\n\t    exports.around = around;\n\t    /**\n\t     * Attaches \"before\" advice to be executed before the original method.\n\t     *\n\t     * @param target Object whose method will be aspected\n\t     * @param methodName Name of method to aspect\n\t     * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n\t     * @return A handle which will remove the aspect when destroy is called\n\t     */\n\t    function before(target, methodName, advice) {\n\t        return advise(getDispatcher(target, methodName), 'before', advice);\n\t    }\n\t    exports.before = before;\n\t    /**\n\t     * Attaches advice to be executed after the original method.\n\t     * The advising function will receive the same arguments as the original method.\n\t     * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n\t     *\n\t     * @param target Object whose method will be aspected\n\t     * @param methodName Name of method to aspect\n\t     * @param advice Advising function which will receive the same arguments as the original method\n\t     * @return A handle which will remove the aspect when destroy is called\n\t     */\n\t    function on(target, methodName, advice) {\n\t        return advise(getDispatcher(target, methodName), 'after', advice, true);\n\t    }\n\t    exports.on = on;\n\t});\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(38), __webpack_require__(37), __webpack_require__(25), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createStateful_1 = __webpack_require__(38);\n\t    var createCancelableEvent_1 = __webpack_require__(37);\n\t    var lang_1 = __webpack_require__(25);\n\t    var lang_2 = __webpack_require__(35);\n\t    var createFormMixin = createStateful_1.default\n\t        .mixin({\n\t        mixin: {\n\t            get value() {\n\t                return lang_2.valueToString(this.state.value);\n\t            },\n\t            set value(value) {\n\t                if (value !== this.state.value) {\n\t                    var event_1 = lang_1.assign(createCancelableEvent_1.default({\n\t                        type: 'valuechange',\n\t                        target: this\n\t                    }), {\n\t                        oldValue: lang_2.valueToString(this.state.value),\n\t                        value: value\n\t                    });\n\t                    this.emit(event_1);\n\t                    if (!event_1.defaultPrevented) {\n\t                        this.setState({ value: lang_2.stringToValue(event_1.value) });\n\t                    }\n\t                }\n\t            },\n\t            nodeAttributes: [\n\t                function () {\n\t                    var _a = this, type = _a.type, value = _a.value, state = _a.state;\n\t                    var disabled = state.disabled, name = state.name;\n\t                    return { type: type, value: value, name: name, disabled: Boolean(disabled) };\n\t                }\n\t            ]\n\t        },\n\t        initialize: function (instance, _a) {\n\t            var _b = _a === void 0 ? {} : _a, value = _b.value, type = _b.type;\n\t            if (value) {\n\t                instance.setState({ value: value });\n\t            }\n\t            if (type) {\n\t                instance.type = type;\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createFormMixin;\n\t});\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(36)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var immutable_1 = __webpack_require__(36);\n\t    function getIndex(list, item, position, reference) {\n\t        var idx;\n\t        if (typeof position === 'number') {\n\t            idx = position;\n\t            var size = Array.isArray(list) ? list.length : list.size;\n\t            if (idx < 0 || idx > size) {\n\t                throw new Error('position is out of range');\n\t            }\n\t        }\n\t        else {\n\t            switch (position) {\n\t                case 'first':\n\t                    idx = 0;\n\t                    break;\n\t                case 'last':\n\t                    idx = Array.isArray(list) ? list.length : list.size;\n\t                    break;\n\t                case 'before':\n\t                    idx = reference === undefined ? -1 : list.indexOf(reference);\n\t                    if (idx === -1) {\n\t                        throw new Error('reference not contained in this list');\n\t                    }\n\t                    break;\n\t                case 'after':\n\t                    idx = reference === undefined ? 0 : list.indexOf(reference) + 1;\n\t                    if (idx === 0) {\n\t                        throw new Error('reference not contained in this list');\n\t                    }\n\t                    break;\n\t                default:\n\t                    throw Error(\"Invalid position \\\"\" + position + \"\\\"\");\n\t            }\n\t        }\n\t        return idx;\n\t    }\n\t    function insertInList(list, item, position, reference) {\n\t        return list.insert(getIndex(list, item, position, reference), item);\n\t    }\n\t    exports.insertInList = insertInList;\n\t    function insertInArray(array, item, position, reference) {\n\t        array.splice(getIndex(array, item, position, reference), 0, item);\n\t        return array;\n\t    }\n\t    exports.insertInArray = insertInArray;\n\t    function valueReplacer(key, value) {\n\t        if (value instanceof RegExp) {\n\t            return (\"__RegExp(\" + value.toString() + \")\");\n\t        }\n\t        return value;\n\t    }\n\t    function valueReviver(key, value) {\n\t        if (value.toString().indexOf('__RegExp(') === 0) {\n\t            var _a = value.match(/__RegExp\\(([^\\)]*)\\)/), regExpStr = _a[1];\n\t            var _b = regExpStr.match(/^\\/(.*?)\\/([gimy]*)$/), regExp = _b[1], flags = _b[2];\n\t            return new RegExp(regExp, flags);\n\t        }\n\t        return value;\n\t    }\n\t    /**\n\t     * Internal function to convert a state value to a string\n\t     * @param value The value to be converted\n\t     */\n\t    function valueToString(value) {\n\t        return value\n\t            ? Array.isArray(value) || typeof value === 'object'\n\t                ? JSON.stringify(value, valueReplacer) : String(value)\n\t            : value === 0\n\t                ? '0' : value === false\n\t                ? 'false' : '';\n\t    }\n\t    exports.valueToString = valueToString;\n\t    /**\n\t     * Internal function to convert a string to the likely more complex value stored in\n\t     * state\n\t     * @param str The string to convert to a state value\n\t     */\n\t    function stringToValue(str) {\n\t        try {\n\t            var value = JSON.parse(str, valueReviver);\n\t            return value;\n\t        }\n\t        catch (e) {\n\t            if (/^(\\-|\\+)?([0-9]+(\\.[0-9]+)?|Infinity)$/.test(str)) {\n\t                return Number(str);\n\t            }\n\t            if (str) {\n\t                return str;\n\t            }\n\t            return undefined;\n\t        }\n\t    }\n\t    exports.stringToValue = stringToValue;\n\t    /**\n\t     * A type guard that deterimines if a value is an immutable List or not\n\t     */\n\t    function isList(value) {\n\t        return value instanceof immutable_1.List;\n\t    }\n\t    exports.isList = isList;\n\t    /**\n\t     * A type guard that checks to see if the value is a Child\n\t     * @param value the value to guard for\n\t     */\n\t    function isChild(value) {\n\t        return value && typeof value === 'object' && typeof value.render === 'function';\n\t    }\n\t    exports.isChild = isChild;\n\t    /**\n\t     * A utility function that generates a handle that destroys any children\n\t     * @param parent The parent that the handle relates to\n\t     * @param child The child (or array of children) that the handle relates to\n\t     */\n\t    function getRemoveHandle(parent, child) {\n\t        function getDestroyHandle(c) {\n\t            var destroyed = false;\n\t            return c.own({\n\t                destroy: function () {\n\t                    if (destroyed) {\n\t                        return;\n\t                    }\n\t                    var children = parent.children;\n\t                    if (children.includes(c)) {\n\t                        parent.children = isList(children) ? children.delete(children.lastIndexOf(c)) : children.delete(children.keyOf(c));\n\t                    }\n\t                    destroyed = true;\n\t                    if (c.parent === parent) {\n\t                        c.parent = null;\n\t                    }\n\t                }\n\t            });\n\t        }\n\t        var destroyed = false;\n\t        if (Array.isArray(child)) {\n\t            var handles_1 = child.map(function (c) { return getDestroyHandle(c); });\n\t            return {\n\t                destroy: function () {\n\t                    if (destroyed) {\n\t                        return;\n\t                    }\n\t                    handles_1.forEach(function (_a) {\n\t                        var destroy = _a.destroy;\n\t                        return destroy();\n\t                    });\n\t                    destroyed = true;\n\t                }\n\t            };\n\t        }\n\t        else if (isChild(child)) {\n\t            var handle_1 = getDestroyHandle(child);\n\t            return {\n\t                destroy: function () {\n\t                    handle_1.destroy();\n\t                }\n\t            };\n\t        }\n\t        else {\n\t            var handles_2 = [];\n\t            for (var key in child) {\n\t                handles_2.push(getDestroyHandle(child[key]));\n\t            }\n\t            return {\n\t                destroy: function () {\n\t                    if (destroyed) {\n\t                        return;\n\t                    }\n\t                    handles_2.forEach(function (_a) {\n\t                        var destroy = _a.destroy;\n\t                        return destroy();\n\t                    });\n\t                    destroyed = true;\n\t                }\n\t            };\n\t        }\n\t    }\n\t    exports.getRemoveHandle = getRemoveHandle;\n\t});\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *  Copyright (c) 2014-2015, Facebook, Inc.\n\t *  All rights reserved.\n\t *\n\t *  This source code is licensed under the BSD-style license found in the\n\t *  LICENSE file in the root directory of this source tree. An additional grant\n\t *  of patent rights can be found in the PATENTS file in the same directory.\n\t */\n\t\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  (global.Immutable = factory());\n\t}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\t\n\t  function createClass(ctor, superClass) {\n\t    if (superClass) {\n\t      ctor.prototype = Object.create(superClass.prototype);\n\t    }\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\t\n\t  function Iterable(value) {\n\t      return isIterable(value) ? value : Seq(value);\n\t    }\n\t\n\t\n\t  createClass(KeyedIterable, Iterable);\n\t    function KeyedIterable(value) {\n\t      return isKeyed(value) ? value : KeyedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(IndexedIterable, Iterable);\n\t    function IndexedIterable(value) {\n\t      return isIndexed(value) ? value : IndexedSeq(value);\n\t    }\n\t\n\t\n\t  createClass(SetIterable, Iterable);\n\t    function SetIterable(value) {\n\t      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n\t    }\n\t\n\t\n\t\n\t  function isIterable(maybeIterable) {\n\t    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n\t  }\n\t\n\t  function isKeyed(maybeKeyed) {\n\t    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n\t  }\n\t\n\t  function isIndexed(maybeIndexed) {\n\t    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n\t  }\n\t\n\t  function isAssociative(maybeAssociative) {\n\t    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n\t  }\n\t\n\t  function isOrdered(maybeOrdered) {\n\t    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n\t  }\n\t\n\t  Iterable.isIterable = isIterable;\n\t  Iterable.isKeyed = isKeyed;\n\t  Iterable.isIndexed = isIndexed;\n\t  Iterable.isAssociative = isAssociative;\n\t  Iterable.isOrdered = isOrdered;\n\t\n\t  Iterable.Keyed = KeyedIterable;\n\t  Iterable.Indexed = IndexedIterable;\n\t  Iterable.Set = SetIterable;\n\t\n\t\n\t  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  // Used for setting prototype methods that IE8 chokes on.\n\t  var DELETE = 'delete';\n\t\n\t  // Constants describing the size of trie nodes.\n\t  var SHIFT = 5; // Resulted in best performance after ______?\n\t  var SIZE = 1 << SHIFT;\n\t  var MASK = SIZE - 1;\n\t\n\t  // A consistent shared value representing \"not set\" which equals nothing other\n\t  // than itself, and nothing that could be provided externally.\n\t  var NOT_SET = {};\n\t\n\t  // Boolean references, Rough equivalent of `bool &`.\n\t  var CHANGE_LENGTH = { value: false };\n\t  var DID_ALTER = { value: false };\n\t\n\t  function MakeRef(ref) {\n\t    ref.value = false;\n\t    return ref;\n\t  }\n\t\n\t  function SetRef(ref) {\n\t    ref && (ref.value = true);\n\t  }\n\t\n\t  // A function which returns a value representing an \"owner\" for transient writes\n\t  // to tries. The return value will only ever equal itself, and will not equal\n\t  // the return of any subsequent call of this function.\n\t  function OwnerID() {}\n\t\n\t  // http://jsperf.com/copy-array-inline\n\t  function arrCopy(arr, offset) {\n\t    offset = offset || 0;\n\t    var len = Math.max(0, arr.length - offset);\n\t    var newArr = new Array(len);\n\t    for (var ii = 0; ii < len; ii++) {\n\t      newArr[ii] = arr[ii + offset];\n\t    }\n\t    return newArr;\n\t  }\n\t\n\t  function ensureSize(iter) {\n\t    if (iter.size === undefined) {\n\t      iter.size = iter.__iterate(returnTrue);\n\t    }\n\t    return iter.size;\n\t  }\n\t\n\t  function wrapIndex(iter, index) {\n\t    // This implements \"is array index\" which the ECMAString spec defines as:\n\t    //\n\t    //     A String property name P is an array index if and only if\n\t    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n\t    //     to 2^321.\n\t    //\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n\t    if (typeof index !== 'number') {\n\t      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n\t      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n\t        return NaN;\n\t      }\n\t      index = uint32Index;\n\t    }\n\t    return index < 0 ? ensureSize(iter) + index : index;\n\t  }\n\t\n\t  function returnTrue() {\n\t    return true;\n\t  }\n\t\n\t  function wholeSlice(begin, end, size) {\n\t    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n\t      (end === undefined || (size !== undefined && end >= size));\n\t  }\n\t\n\t  function resolveBegin(begin, size) {\n\t    return resolveIndex(begin, size, 0);\n\t  }\n\t\n\t  function resolveEnd(end, size) {\n\t    return resolveIndex(end, size, size);\n\t  }\n\t\n\t  function resolveIndex(index, size, defaultIndex) {\n\t    return index === undefined ?\n\t      defaultIndex :\n\t      index < 0 ?\n\t        Math.max(0, size + index) :\n\t        size === undefined ?\n\t          index :\n\t          Math.min(size, index);\n\t  }\n\t\n\t  /* global Symbol */\n\t\n\t  var ITERATE_KEYS = 0;\n\t  var ITERATE_VALUES = 1;\n\t  var ITERATE_ENTRIES = 2;\n\t\n\t  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n\t  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\t  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\t\n\t\n\t  function Iterator(next) {\n\t      this.next = next;\n\t    }\n\t\n\t    Iterator.prototype.toString = function() {\n\t      return '[Iterator]';\n\t    };\n\t\n\t\n\t  Iterator.KEYS = ITERATE_KEYS;\n\t  Iterator.VALUES = ITERATE_VALUES;\n\t  Iterator.ENTRIES = ITERATE_ENTRIES;\n\t\n\t  Iterator.prototype.inspect =\n\t  Iterator.prototype.toSource = function () { return this.toString(); }\n\t  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n\t    return this;\n\t  };\n\t\n\t\n\t  function iteratorValue(type, k, v, iteratorResult) {\n\t    var value = type === 0 ? k : type === 1 ? v : [k, v];\n\t    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n\t      value: value, done: false\n\t    });\n\t    return iteratorResult;\n\t  }\n\t\n\t  function iteratorDone() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  function hasIterator(maybeIterable) {\n\t    return !!getIteratorFn(maybeIterable);\n\t  }\n\t\n\t  function isIterator(maybeIterator) {\n\t    return maybeIterator && typeof maybeIterator.next === 'function';\n\t  }\n\t\n\t  function getIterator(iterable) {\n\t    var iteratorFn = getIteratorFn(iterable);\n\t    return iteratorFn && iteratorFn.call(iterable);\n\t  }\n\t\n\t  function getIteratorFn(iterable) {\n\t    var iteratorFn = iterable && (\n\t      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n\t      iterable[FAUX_ITERATOR_SYMBOL]\n\t    );\n\t    if (typeof iteratorFn === 'function') {\n\t      return iteratorFn;\n\t    }\n\t  }\n\t\n\t  function isArrayLike(value) {\n\t    return value && typeof value.length === 'number';\n\t  }\n\t\n\t  createClass(Seq, Iterable);\n\t    function Seq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        isIterable(value) ? value.toSeq() : seqFromValue(value);\n\t    }\n\t\n\t    Seq.of = function(/*...values*/) {\n\t      return Seq(arguments);\n\t    };\n\t\n\t    Seq.prototype.toSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    Seq.prototype.toString = function() {\n\t      return this.__toString('Seq {', '}');\n\t    };\n\t\n\t    Seq.prototype.cacheResult = function() {\n\t      if (!this._cache && this.__iterateUncached) {\n\t        this._cache = this.entrySeq().toArray();\n\t        this.size = this._cache.length;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    // abstract __iterateUncached(fn, reverse)\n\t\n\t    Seq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, true);\n\t    };\n\t\n\t    // abstract __iteratorUncached(type, reverse)\n\t\n\t    Seq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, true);\n\t    };\n\t\n\t\n\t\n\t  createClass(KeyedSeq, Seq);\n\t    function KeyedSeq(value) {\n\t      return value === null || value === undefined ?\n\t        emptySequence().toKeyedSeq() :\n\t        isIterable(value) ?\n\t          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n\t          keyedSeqFromValue(value);\n\t    }\n\t\n\t    KeyedSeq.prototype.toKeyedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  createClass(IndexedSeq, Seq);\n\t    function IndexedSeq(value) {\n\t      return value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n\t    }\n\t\n\t    IndexedSeq.of = function(/*...values*/) {\n\t      return IndexedSeq(arguments);\n\t    };\n\t\n\t    IndexedSeq.prototype.toIndexedSeq = function() {\n\t      return this;\n\t    };\n\t\n\t    IndexedSeq.prototype.toString = function() {\n\t      return this.__toString('Seq [', ']');\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n\t      return seqIterate(this, fn, reverse, false);\n\t    };\n\t\n\t    IndexedSeq.prototype.__iterator = function(type, reverse) {\n\t      return seqIterator(this, type, reverse, false);\n\t    };\n\t\n\t\n\t\n\t  createClass(SetSeq, Seq);\n\t    function SetSeq(value) {\n\t      return (\n\t        value === null || value === undefined ? emptySequence() :\n\t        !isIterable(value) ? indexedSeqFromValue(value) :\n\t        isKeyed(value) ? value.entrySeq() : value\n\t      ).toSetSeq();\n\t    }\n\t\n\t    SetSeq.of = function(/*...values*/) {\n\t      return SetSeq(arguments);\n\t    };\n\t\n\t    SetSeq.prototype.toSetSeq = function() {\n\t      return this;\n\t    };\n\t\n\t\n\t\n\t  Seq.isSeq = isSeq;\n\t  Seq.Keyed = KeyedSeq;\n\t  Seq.Set = SetSeq;\n\t  Seq.Indexed = IndexedSeq;\n\t\n\t  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\t\n\t  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\t\n\t\n\t\n\t  createClass(ArraySeq, IndexedSeq);\n\t    function ArraySeq(array) {\n\t      this._array = array;\n\t      this.size = array.length;\n\t    }\n\t\n\t    ArraySeq.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterate = function(fn, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ArraySeq.prototype.__iterator = function(type, reverse) {\n\t      var array = this._array;\n\t      var maxIndex = array.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n\t      );\n\t    };\n\t\n\t\n\t\n\t  createClass(ObjectSeq, KeyedSeq);\n\t    function ObjectSeq(object) {\n\t      var keys = Object.keys(object);\n\t      this._object = object;\n\t      this._keys = keys;\n\t      this.size = keys.length;\n\t    }\n\t\n\t    ObjectSeq.prototype.get = function(key, notSetValue) {\n\t      if (notSetValue !== undefined && !this.has(key)) {\n\t        return notSetValue;\n\t      }\n\t      return this._object[key];\n\t    };\n\t\n\t    ObjectSeq.prototype.has = function(key) {\n\t      return this._object.hasOwnProperty(key);\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        if (fn(object[key], key, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    ObjectSeq.prototype.__iterator = function(type, reverse) {\n\t      var object = this._object;\n\t      var keys = this._keys;\n\t      var maxIndex = keys.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var key = keys[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, key, object[key]);\n\t      });\n\t    };\n\t\n\t  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(IterableSeq, IndexedSeq);\n\t    function IterableSeq(iterable) {\n\t      this._iterable = iterable;\n\t      this.size = iterable.length || iterable.size;\n\t    }\n\t\n\t    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      var iterations = 0;\n\t      if (isIterator(iterator)) {\n\t        var step;\n\t        while (!(step = iterator.next()).done) {\n\t          if (fn(step.value, iterations++, this) === false) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterable = this._iterable;\n\t      var iterator = getIterator(iterable);\n\t      if (!isIterator(iterator)) {\n\t        return new Iterator(iteratorDone);\n\t      }\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step : iteratorValue(type, iterations++, step.value);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(IteratorSeq, IndexedSeq);\n\t    function IteratorSeq(iterator) {\n\t      this._iterator = iterator;\n\t      this._iteratorCache = [];\n\t    }\n\t\n\t    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      while (iterations < cache.length) {\n\t        if (fn(cache[iterations], iterations++, this) === false) {\n\t          return iterations;\n\t        }\n\t      }\n\t      var step;\n\t      while (!(step = iterator.next()).done) {\n\t        var val = step.value;\n\t        cache[iterations] = val;\n\t        if (fn(val, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iterator;\n\t      var cache = this._iteratorCache;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        if (iterations >= cache.length) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          cache[iterations] = step.value;\n\t        }\n\t        return iteratorValue(type, iterations, cache[iterations++]);\n\t      });\n\t    };\n\t\n\t\n\t\n\t\n\t  // # pragma Helper functions\n\t\n\t  function isSeq(maybeSeq) {\n\t    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n\t  }\n\t\n\t  var EMPTY_SEQ;\n\t\n\t  function emptySequence() {\n\t    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n\t  }\n\t\n\t  function keyedSeqFromValue(value) {\n\t    var seq =\n\t      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n\t      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n\t      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n\t      typeof value === 'object' ? new ObjectSeq(value) :\n\t      undefined;\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of [k, v] entries, '+\n\t        'or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function indexedSeqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value);\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function seqFromValue(value) {\n\t    var seq = maybeIndexedSeqFromValue(value) ||\n\t      (typeof value === 'object' && new ObjectSeq(value));\n\t    if (!seq) {\n\t      throw new TypeError(\n\t        'Expected Array or iterable object of values, or keyed object: ' + value\n\t      );\n\t    }\n\t    return seq;\n\t  }\n\t\n\t  function maybeIndexedSeqFromValue(value) {\n\t    return (\n\t      isArrayLike(value) ? new ArraySeq(value) :\n\t      isIterator(value) ? new IteratorSeq(value) :\n\t      hasIterator(value) ? new IterableSeq(value) :\n\t      undefined\n\t    );\n\t  }\n\t\n\t  function seqIterate(seq, fn, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    }\n\t    return seq.__iterateUncached(fn, reverse);\n\t  }\n\t\n\t  function seqIterator(seq, type, reverse, useKeys) {\n\t    var cache = seq._cache;\n\t    if (cache) {\n\t      var maxIndex = cache.length - 1;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var entry = cache[reverse ? maxIndex - ii : ii];\n\t        return ii++ > maxIndex ?\n\t          iteratorDone() :\n\t          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n\t      });\n\t    }\n\t    return seq.__iteratorUncached(type, reverse);\n\t  }\n\t\n\t  function fromJS(json, converter) {\n\t    return converter ?\n\t      fromJSWith(converter, json, '', {'': json}) :\n\t      fromJSDefault(json);\n\t  }\n\t\n\t  function fromJSWith(converter, json, key, parentJSON) {\n\t    if (Array.isArray(json)) {\n\t      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function fromJSDefault(json) {\n\t    if (Array.isArray(json)) {\n\t      return IndexedSeq(json).map(fromJSDefault).toList();\n\t    }\n\t    if (isPlainObj(json)) {\n\t      return KeyedSeq(json).map(fromJSDefault).toMap();\n\t    }\n\t    return json;\n\t  }\n\t\n\t  function isPlainObj(value) {\n\t    return value && (value.constructor === Object || value.constructor === undefined);\n\t  }\n\t\n\t  /**\n\t   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n\t   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n\t   *\n\t   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n\t   * value, which is different from the algorithm described by\n\t   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n\t   *\n\t   * This is extended further to allow Objects to describe the values they\n\t   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n\t   *\n\t   * Note: because of this extension, the key equality of Immutable.Map and the\n\t   * value equality of Immutable.Set will differ from ES6 Map and Set.\n\t   *\n\t   * ### Defining custom values\n\t   *\n\t   * The easiest way to describe the value an object represents is by implementing\n\t   * `valueOf`. For example, `Date` represents a value by returning a unix\n\t   * timestamp for `valueOf`:\n\t   *\n\t   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n\t   *     var date2 = new Date(1234567890000);\n\t   *     date1.valueOf(); // 1234567890000\n\t   *     assert( date1 !== date2 );\n\t   *     assert( Immutable.is( date1, date2 ) );\n\t   *\n\t   * Note: overriding `valueOf` may have other implications if you use this object\n\t   * where JavaScript expects a primitive, such as implicit string coercion.\n\t   *\n\t   * For more complex types, especially collections, implementing `valueOf` may\n\t   * not be performant. An alternative is to implement `equals` and `hashCode`.\n\t   *\n\t   * `equals` takes another object, presumably of similar type, and returns true\n\t   * if the it is equal. Equality is symmetrical, so the same result should be\n\t   * returned if this and the argument are flipped.\n\t   *\n\t   *     assert( a.equals(b) === b.equals(a) );\n\t   *\n\t   * `hashCode` returns a 32bit integer number representing the object which will\n\t   * be used to determine how to store the value object in a Map or Set. You must\n\t   * provide both or neither methods, one must not exist without the other.\n\t   *\n\t   * Also, an important relationship between these methods must be upheld: if two\n\t   * values are equal, they *must* return the same hashCode. If the values are not\n\t   * equal, they might have the same hashCode; this is called a hash collision,\n\t   * and while undesirable for performance reasons, it is acceptable.\n\t   *\n\t   *     if (a.equals(b)) {\n\t   *       assert( a.hashCode() === b.hashCode() );\n\t   *     }\n\t   *\n\t   * All Immutable collections implement `equals` and `hashCode`.\n\t   *\n\t   */\n\t  function is(valueA, valueB) {\n\t    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t      return true;\n\t    }\n\t    if (!valueA || !valueB) {\n\t      return false;\n\t    }\n\t    if (typeof valueA.valueOf === 'function' &&\n\t        typeof valueB.valueOf === 'function') {\n\t      valueA = valueA.valueOf();\n\t      valueB = valueB.valueOf();\n\t      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n\t        return true;\n\t      }\n\t      if (!valueA || !valueB) {\n\t        return false;\n\t      }\n\t    }\n\t    if (typeof valueA.equals === 'function' &&\n\t        typeof valueB.equals === 'function' &&\n\t        valueA.equals(valueB)) {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function deepEqual(a, b) {\n\t    if (a === b) {\n\t      return true;\n\t    }\n\t\n\t    if (\n\t      !isIterable(b) ||\n\t      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n\t      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n\t      isKeyed(a) !== isKeyed(b) ||\n\t      isIndexed(a) !== isIndexed(b) ||\n\t      isOrdered(a) !== isOrdered(b)\n\t    ) {\n\t      return false;\n\t    }\n\t\n\t    if (a.size === 0 && b.size === 0) {\n\t      return true;\n\t    }\n\t\n\t    var notAssociative = !isAssociative(a);\n\t\n\t    if (isOrdered(a)) {\n\t      var entries = a.entries();\n\t      return b.every(function(v, k)  {\n\t        var entry = entries.next().value;\n\t        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n\t      }) && entries.next().done;\n\t    }\n\t\n\t    var flipped = false;\n\t\n\t    if (a.size === undefined) {\n\t      if (b.size === undefined) {\n\t        if (typeof a.cacheResult === 'function') {\n\t          a.cacheResult();\n\t        }\n\t      } else {\n\t        flipped = true;\n\t        var _ = a;\n\t        a = b;\n\t        b = _;\n\t      }\n\t    }\n\t\n\t    var allEqual = true;\n\t    var bSize = b.__iterate(function(v, k)  {\n\t      if (notAssociative ? !a.has(v) :\n\t          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n\t        allEqual = false;\n\t        return false;\n\t      }\n\t    });\n\t\n\t    return allEqual && a.size === bSize;\n\t  }\n\t\n\t  createClass(Repeat, IndexedSeq);\n\t\n\t    function Repeat(value, times) {\n\t      if (!(this instanceof Repeat)) {\n\t        return new Repeat(value, times);\n\t      }\n\t      this._value = value;\n\t      this.size = times === undefined ? Infinity : Math.max(0, times);\n\t      if (this.size === 0) {\n\t        if (EMPTY_REPEAT) {\n\t          return EMPTY_REPEAT;\n\t        }\n\t        EMPTY_REPEAT = this;\n\t      }\n\t    }\n\t\n\t    Repeat.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Repeat []';\n\t      }\n\t      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n\t    };\n\t\n\t    Repeat.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ? this._value : notSetValue;\n\t    };\n\t\n\t    Repeat.prototype.includes = function(searchValue) {\n\t      return is(this._value, searchValue);\n\t    };\n\t\n\t    Repeat.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      return wholeSlice(begin, end, size) ? this :\n\t        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n\t    };\n\t\n\t    Repeat.prototype.reverse = function() {\n\t      return this;\n\t    };\n\t\n\t    Repeat.prototype.indexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return 0;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.lastIndexOf = function(searchValue) {\n\t      if (is(this._value, searchValue)) {\n\t        return this.size;\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Repeat.prototype.__iterate = function(fn, reverse) {\n\t      for (var ii = 0; ii < this.size; ii++) {\n\t        if (fn(this._value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      var ii = 0;\n\t      return new Iterator(function() \n\t        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n\t      );\n\t    };\n\t\n\t    Repeat.prototype.equals = function(other) {\n\t      return other instanceof Repeat ?\n\t        is(this._value, other._value) :\n\t        deepEqual(other);\n\t    };\n\t\n\t\n\t  var EMPTY_REPEAT;\n\t\n\t  function invariant(condition, error) {\n\t    if (!condition) throw new Error(error);\n\t  }\n\t\n\t  createClass(Range, IndexedSeq);\n\t\n\t    function Range(start, end, step) {\n\t      if (!(this instanceof Range)) {\n\t        return new Range(start, end, step);\n\t      }\n\t      invariant(step !== 0, 'Cannot step a Range by 0');\n\t      start = start || 0;\n\t      if (end === undefined) {\n\t        end = Infinity;\n\t      }\n\t      step = step === undefined ? 1 : Math.abs(step);\n\t      if (end < start) {\n\t        step = -step;\n\t      }\n\t      this._start = start;\n\t      this._end = end;\n\t      this._step = step;\n\t      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\t      if (this.size === 0) {\n\t        if (EMPTY_RANGE) {\n\t          return EMPTY_RANGE;\n\t        }\n\t        EMPTY_RANGE = this;\n\t      }\n\t    }\n\t\n\t    Range.prototype.toString = function() {\n\t      if (this.size === 0) {\n\t        return 'Range []';\n\t      }\n\t      return 'Range [ ' +\n\t        this._start + '...' + this._end +\n\t        (this._step !== 1 ? ' by ' + this._step : '') +\n\t      ' ]';\n\t    };\n\t\n\t    Range.prototype.get = function(index, notSetValue) {\n\t      return this.has(index) ?\n\t        this._start + wrapIndex(this, index) * this._step :\n\t        notSetValue;\n\t    };\n\t\n\t    Range.prototype.includes = function(searchValue) {\n\t      var possibleIndex = (searchValue - this._start) / this._step;\n\t      return possibleIndex >= 0 &&\n\t        possibleIndex < this.size &&\n\t        possibleIndex === Math.floor(possibleIndex);\n\t    };\n\t\n\t    Range.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      begin = resolveBegin(begin, this.size);\n\t      end = resolveEnd(end, this.size);\n\t      if (end <= begin) {\n\t        return new Range(0, 0);\n\t      }\n\t      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n\t    };\n\t\n\t    Range.prototype.indexOf = function(searchValue) {\n\t      var offsetValue = searchValue - this._start;\n\t      if (offsetValue % this._step === 0) {\n\t        var index = offsetValue / this._step;\n\t        if (index >= 0 && index < this.size) {\n\t          return index\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    Range.prototype.lastIndexOf = function(searchValue) {\n\t      return this.indexOf(searchValue);\n\t    };\n\t\n\t    Range.prototype.__iterate = function(fn, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      for (var ii = 0; ii <= maxIndex; ii++) {\n\t        if (fn(value, ii, this) === false) {\n\t          return ii + 1;\n\t        }\n\t        value += reverse ? -step : step;\n\t      }\n\t      return ii;\n\t    };\n\t\n\t    Range.prototype.__iterator = function(type, reverse) {\n\t      var maxIndex = this.size - 1;\n\t      var step = this._step;\n\t      var value = reverse ? this._start + maxIndex * step : this._start;\n\t      var ii = 0;\n\t      return new Iterator(function()  {\n\t        var v = value;\n\t        value += reverse ? -step : step;\n\t        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n\t      });\n\t    };\n\t\n\t    Range.prototype.equals = function(other) {\n\t      return other instanceof Range ?\n\t        this._start === other._start &&\n\t        this._end === other._end &&\n\t        this._step === other._step :\n\t        deepEqual(this, other);\n\t    };\n\t\n\t\n\t  var EMPTY_RANGE;\n\t\n\t  createClass(Collection, Iterable);\n\t    function Collection() {\n\t      throw TypeError('Abstract');\n\t    }\n\t\n\t\n\t  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\t\n\t  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\t\n\t  createClass(SetCollection, Collection);function SetCollection() {}\n\t\n\t\n\t  Collection.Keyed = KeyedCollection;\n\t  Collection.Indexed = IndexedCollection;\n\t  Collection.Set = SetCollection;\n\t\n\t  var imul =\n\t    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n\t    Math.imul :\n\t    function imul(a, b) {\n\t      a = a | 0; // int\n\t      b = b | 0; // int\n\t      var c = a & 0xffff;\n\t      var d = b & 0xffff;\n\t      // Shift by 0 fixes the sign on the high part.\n\t      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n\t    };\n\t\n\t  // v8 has an optimization for storing 31-bit signed numbers.\n\t  // Values which have either 00 or 11 as the high order bits qualify.\n\t  // This function drops the highest order bit in a signed number, maintaining\n\t  // the sign bit.\n\t  function smi(i32) {\n\t    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n\t  }\n\t\n\t  function hash(o) {\n\t    if (o === false || o === null || o === undefined) {\n\t      return 0;\n\t    }\n\t    if (typeof o.valueOf === 'function') {\n\t      o = o.valueOf();\n\t      if (o === false || o === null || o === undefined) {\n\t        return 0;\n\t      }\n\t    }\n\t    if (o === true) {\n\t      return 1;\n\t    }\n\t    var type = typeof o;\n\t    if (type === 'number') {\n\t      if (o !== o || o === Infinity) {\n\t        return 0;\n\t      }\n\t      var h = o | 0;\n\t      if (h !== o) {\n\t        h ^= o * 0xFFFFFFFF;\n\t      }\n\t      while (o > 0xFFFFFFFF) {\n\t        o /= 0xFFFFFFFF;\n\t        h ^= o;\n\t      }\n\t      return smi(h);\n\t    }\n\t    if (type === 'string') {\n\t      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\t    }\n\t    if (typeof o.hashCode === 'function') {\n\t      return o.hashCode();\n\t    }\n\t    if (type === 'object') {\n\t      return hashJSObj(o);\n\t    }\n\t    if (typeof o.toString === 'function') {\n\t      return hashString(o.toString());\n\t    }\n\t    throw new Error('Value type ' + type + ' cannot be hashed.');\n\t  }\n\t\n\t  function cachedHashString(string) {\n\t    var hash = stringHashCache[string];\n\t    if (hash === undefined) {\n\t      hash = hashString(string);\n\t      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n\t        STRING_HASH_CACHE_SIZE = 0;\n\t        stringHashCache = {};\n\t      }\n\t      STRING_HASH_CACHE_SIZE++;\n\t      stringHashCache[string] = hash;\n\t    }\n\t    return hash;\n\t  }\n\t\n\t  // http://jsperf.com/hashing-strings\n\t  function hashString(string) {\n\t    // This is the hash from JVM\n\t    // The hash code for a string is computed as\n\t    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n\t    // where s[i] is the ith character of the string and n is the length of\n\t    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n\t    // (exclusive) by dropping high bits.\n\t    var hash = 0;\n\t    for (var ii = 0; ii < string.length; ii++) {\n\t      hash = 31 * hash + string.charCodeAt(ii) | 0;\n\t    }\n\t    return smi(hash);\n\t  }\n\t\n\t  function hashJSObj(obj) {\n\t    var hash;\n\t    if (usingWeakMap) {\n\t      hash = weakMap.get(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = obj[UID_HASH_KEY];\n\t    if (hash !== undefined) {\n\t      return hash;\n\t    }\n\t\n\t    if (!canDefineProperty) {\n\t      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t\n\t      hash = getIENodeHash(obj);\n\t      if (hash !== undefined) {\n\t        return hash;\n\t      }\n\t    }\n\t\n\t    hash = ++objHashUID;\n\t    if (objHashUID & 0x40000000) {\n\t      objHashUID = 0;\n\t    }\n\t\n\t    if (usingWeakMap) {\n\t      weakMap.set(obj, hash);\n\t    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n\t      throw new Error('Non-extensible objects are not allowed as keys.');\n\t    } else if (canDefineProperty) {\n\t      Object.defineProperty(obj, UID_HASH_KEY, {\n\t        'enumerable': false,\n\t        'configurable': false,\n\t        'writable': false,\n\t        'value': hash\n\t      });\n\t    } else if (obj.propertyIsEnumerable !== undefined &&\n\t               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n\t      // Since we can't define a non-enumerable property on the object\n\t      // we'll hijack one of the less-used non-enumerable properties to\n\t      // save our hash on it. Since this is a function it will not show up in\n\t      // `JSON.stringify` which is what we want.\n\t      obj.propertyIsEnumerable = function() {\n\t        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n\t      };\n\t      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n\t    } else if (obj.nodeType !== undefined) {\n\t      // At this point we couldn't get the IE `uniqueID` to use as a hash\n\t      // and we couldn't use a non-enumerable property to exploit the\n\t      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n\t      // itself.\n\t      obj[UID_HASH_KEY] = hash;\n\t    } else {\n\t      throw new Error('Unable to set a non-enumerable property on object.');\n\t    }\n\t\n\t    return hash;\n\t  }\n\t\n\t  // Get references to ES5 object methods.\n\t  var isExtensible = Object.isExtensible;\n\t\n\t  // True if Object.defineProperty works as expected. IE8 fails this test.\n\t  var canDefineProperty = (function() {\n\t    try {\n\t      Object.defineProperty({}, '@', {});\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }());\n\t\n\t  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n\t  // and avoid memory leaks from the IE cloneNode bug.\n\t  function getIENodeHash(node) {\n\t    if (node && node.nodeType > 0) {\n\t      switch (node.nodeType) {\n\t        case 1: // Element\n\t          return node.uniqueID;\n\t        case 9: // Document\n\t          return node.documentElement && node.documentElement.uniqueID;\n\t      }\n\t    }\n\t  }\n\t\n\t  // If possible, use a WeakMap.\n\t  var usingWeakMap = typeof WeakMap === 'function';\n\t  var weakMap;\n\t  if (usingWeakMap) {\n\t    weakMap = new WeakMap();\n\t  }\n\t\n\t  var objHashUID = 0;\n\t\n\t  var UID_HASH_KEY = '__immutablehash__';\n\t  if (typeof Symbol === 'function') {\n\t    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n\t  }\n\t\n\t  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n\t  var STRING_HASH_CACHE_MAX_SIZE = 255;\n\t  var STRING_HASH_CACHE_SIZE = 0;\n\t  var stringHashCache = {};\n\t\n\t  function assertNotInfinite(size) {\n\t    invariant(\n\t      size !== Infinity,\n\t      'Cannot perform this action with an infinite size.'\n\t    );\n\t  }\n\t\n\t  createClass(Map, KeyedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Map(value) {\n\t      return value === null || value === undefined ? emptyMap() :\n\t        isMap(value) && !isOrdered(value) ? value :\n\t        emptyMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n\t      return emptyMap().withMutations(function(map ) {\n\t        for (var i = 0; i < keyValues.length; i += 2) {\n\t          if (i + 1 >= keyValues.length) {\n\t            throw new Error('Missing value for key: ' + keyValues[i]);\n\t          }\n\t          map.set(keyValues[i], keyValues[i + 1]);\n\t        }\n\t      });\n\t    };\n\t\n\t    Map.prototype.toString = function() {\n\t      return this.__toString('Map {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Map.prototype.get = function(k, notSetValue) {\n\t      return this._root ?\n\t        this._root.get(0, undefined, k, notSetValue) :\n\t        notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Map.prototype.set = function(k, v) {\n\t      return updateMap(this, k, v);\n\t    };\n\t\n\t    Map.prototype.setIn = function(keyPath, v) {\n\t      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n\t    };\n\t\n\t    Map.prototype.remove = function(k) {\n\t      return updateMap(this, k, NOT_SET);\n\t    };\n\t\n\t    Map.prototype.deleteIn = function(keyPath) {\n\t      return this.updateIn(keyPath, function()  {return NOT_SET});\n\t    };\n\t\n\t    Map.prototype.update = function(k, notSetValue, updater) {\n\t      return arguments.length === 1 ?\n\t        k(this) :\n\t        this.updateIn([k], notSetValue, updater);\n\t    };\n\t\n\t    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n\t      if (!updater) {\n\t        updater = notSetValue;\n\t        notSetValue = undefined;\n\t      }\n\t      var updatedValue = updateInDeepMap(\n\t        this,\n\t        forceIterator(keyPath),\n\t        notSetValue,\n\t        updater\n\t      );\n\t      return updatedValue === NOT_SET ? undefined : updatedValue;\n\t    };\n\t\n\t    Map.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._root = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyMap();\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Map.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, undefined, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, merger, iters);\n\t    };\n\t\n\t    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.merge === 'function' ?\n\t          m.merge.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoMapWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.updateIn(\n\t        keyPath,\n\t        emptyMap(),\n\t        function(m ) {return typeof m.mergeDeep === 'function' ?\n\t          m.mergeDeep.apply(m, iters) :\n\t          iters[iters.length - 1]}\n\t      );\n\t    };\n\t\n\t    Map.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator));\n\t    };\n\t\n\t    Map.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedMap(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Map.prototype.withMutations = function(fn) {\n\t      var mutable = this.asMutable();\n\t      fn(mutable);\n\t      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n\t    };\n\t\n\t    Map.prototype.asMutable = function() {\n\t      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n\t    };\n\t\n\t    Map.prototype.asImmutable = function() {\n\t      return this.__ensureOwner();\n\t    };\n\t\n\t    Map.prototype.wasAltered = function() {\n\t      return this.__altered;\n\t    };\n\t\n\t    Map.prototype.__iterator = function(type, reverse) {\n\t      return new MapIterator(this, type, reverse);\n\t    };\n\t\n\t    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      this._root && this._root.iterate(function(entry ) {\n\t        iterations++;\n\t        return fn(entry[1], entry[0], this$0);\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t\n\t    Map.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeMap(this.size, this._root, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isMap(maybeMap) {\n\t    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n\t  }\n\t\n\t  Map.isMap = isMap;\n\t\n\t  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\t\n\t  var MapPrototype = Map.prototype;\n\t  MapPrototype[IS_MAP_SENTINEL] = true;\n\t  MapPrototype[DELETE] = MapPrototype.remove;\n\t  MapPrototype.removeIn = MapPrototype.deleteIn;\n\t\n\t\n\t  // #pragma Trie Nodes\n\t\n\t\n\t\n\t    function ArrayMapNode(ownerID, entries) {\n\t      this.ownerID = ownerID;\n\t      this.entries = entries;\n\t    }\n\t\n\t    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && entries.length === 1) {\n\t        return; // undefined\n\t      }\n\t\n\t      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n\t        return createNodes(ownerID, entries, key, value);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new ArrayMapNode(ownerID, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.bitmap = bitmap;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n\t      var bitmap = this.bitmap;\n\t      return (bitmap & bit) === 0 ? notSetValue :\n\t        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n\t    };\n\t\n\t    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var bit = 1 << keyHashFrag;\n\t      var bitmap = this.bitmap;\n\t      var exists = (bitmap & bit) !== 0;\n\t\n\t      if (!exists && value === NOT_SET) {\n\t        return this;\n\t      }\n\t\n\t      var idx = popCount(bitmap & (bit - 1));\n\t      var nodes = this.nodes;\n\t      var node = exists ? nodes[idx] : undefined;\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n\t        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n\t      }\n\t\n\t      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n\t        return nodes[idx ^ 1];\n\t      }\n\t\n\t      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n\t        return newNode;\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n\t      var newNodes = exists ? newNode ?\n\t        setIn(nodes, idx, newNode, isEditable) :\n\t        spliceOut(nodes, idx, isEditable) :\n\t        spliceIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.bitmap = newBitmap;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashArrayMapNode(ownerID, count, nodes) {\n\t      this.ownerID = ownerID;\n\t      this.count = count;\n\t      this.nodes = nodes;\n\t    }\n\t\n\t    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var node = this.nodes[idx];\n\t      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n\t    };\n\t\n\t    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t      var removed = value === NOT_SET;\n\t      var nodes = this.nodes;\n\t      var node = nodes[idx];\n\t\n\t      if (removed && !node) {\n\t        return this;\n\t      }\n\t\n\t      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\t      if (newNode === node) {\n\t        return this;\n\t      }\n\t\n\t      var newCount = this.count;\n\t      if (!node) {\n\t        newCount++;\n\t      } else if (!newNode) {\n\t        newCount--;\n\t        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n\t          return packNodes(ownerID, nodes, newCount, idx);\n\t        }\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\t\n\t      if (isEditable) {\n\t        this.count = newCount;\n\t        this.nodes = newNodes;\n\t        return this;\n\t      }\n\t\n\t      return new HashArrayMapNode(ownerID, newCount, newNodes);\n\t    };\n\t\n\t\n\t\n\t\n\t    function HashCollisionNode(ownerID, keyHash, entries) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entries = entries;\n\t    }\n\t\n\t    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      var entries = this.entries;\n\t      for (var ii = 0, len = entries.length; ii < len; ii++) {\n\t        if (is(key, entries[ii][0])) {\n\t          return entries[ii][1];\n\t        }\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      if (keyHash === undefined) {\n\t        keyHash = hash(key);\n\t      }\n\t\n\t      var removed = value === NOT_SET;\n\t\n\t      if (keyHash !== this.keyHash) {\n\t        if (removed) {\n\t          return this;\n\t        }\n\t        SetRef(didAlter);\n\t        SetRef(didChangeSize);\n\t        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n\t      }\n\t\n\t      var entries = this.entries;\n\t      var idx = 0;\n\t      for (var len = entries.length; idx < len; idx++) {\n\t        if (is(key, entries[idx][0])) {\n\t          break;\n\t        }\n\t      }\n\t      var exists = idx < len;\n\t\n\t      if (exists ? entries[idx][1] === value : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t      (removed || !exists) && SetRef(didChangeSize);\n\t\n\t      if (removed && len === 2) {\n\t        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n\t      }\n\t\n\t      var isEditable = ownerID && ownerID === this.ownerID;\n\t      var newEntries = isEditable ? entries : arrCopy(entries);\n\t\n\t      if (exists) {\n\t        if (removed) {\n\t          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n\t        } else {\n\t          newEntries[idx] = [key, value];\n\t        }\n\t      } else {\n\t        newEntries.push([key, value]);\n\t      }\n\t\n\t      if (isEditable) {\n\t        this.entries = newEntries;\n\t        return this;\n\t      }\n\t\n\t      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n\t    };\n\t\n\t\n\t\n\t\n\t    function ValueNode(ownerID, keyHash, entry) {\n\t      this.ownerID = ownerID;\n\t      this.keyHash = keyHash;\n\t      this.entry = entry;\n\t    }\n\t\n\t    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n\t      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n\t    };\n\t\n\t    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t      var removed = value === NOT_SET;\n\t      var keyMatch = is(key, this.entry[0]);\n\t      if (keyMatch ? value === this.entry[1] : removed) {\n\t        return this;\n\t      }\n\t\n\t      SetRef(didAlter);\n\t\n\t      if (removed) {\n\t        SetRef(didChangeSize);\n\t        return; // undefined\n\t      }\n\t\n\t      if (keyMatch) {\n\t        if (ownerID && ownerID === this.ownerID) {\n\t          this.entry[1] = value;\n\t          return this;\n\t        }\n\t        return new ValueNode(ownerID, this.keyHash, [key, value]);\n\t      }\n\t\n\t      SetRef(didChangeSize);\n\t      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n\t    };\n\t\n\t\n\t\n\t  // #pragma Iterators\n\t\n\t  ArrayMapNode.prototype.iterate =\n\t  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n\t    var entries = this.entries;\n\t    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n\t      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  BitmapIndexedNode.prototype.iterate =\n\t  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n\t    var nodes = this.nodes;\n\t    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n\t      var node = nodes[reverse ? maxIndex - ii : ii];\n\t      if (node && node.iterate(fn, reverse) === false) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t\n\t  ValueNode.prototype.iterate = function (fn, reverse) {\n\t    return fn(this.entry);\n\t  }\n\t\n\t  createClass(MapIterator, Iterator);\n\t\n\t    function MapIterator(map, type, reverse) {\n\t      this._type = type;\n\t      this._reverse = reverse;\n\t      this._stack = map._root && mapIteratorFrame(map._root);\n\t    }\n\t\n\t    MapIterator.prototype.next = function() {\n\t      var type = this._type;\n\t      var stack = this._stack;\n\t      while (stack) {\n\t        var node = stack.node;\n\t        var index = stack.index++;\n\t        var maxIndex;\n\t        if (node.entry) {\n\t          if (index === 0) {\n\t            return mapIteratorValue(type, node.entry);\n\t          }\n\t        } else if (node.entries) {\n\t          maxIndex = node.entries.length - 1;\n\t          if (index <= maxIndex) {\n\t            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n\t          }\n\t        } else {\n\t          maxIndex = node.nodes.length - 1;\n\t          if (index <= maxIndex) {\n\t            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\t            if (subNode) {\n\t              if (subNode.entry) {\n\t                return mapIteratorValue(type, subNode.entry);\n\t              }\n\t              stack = this._stack = mapIteratorFrame(subNode, stack);\n\t            }\n\t            continue;\n\t          }\n\t        }\n\t        stack = this._stack = this._stack.__prev;\n\t      }\n\t      return iteratorDone();\n\t    };\n\t\n\t\n\t  function mapIteratorValue(type, entry) {\n\t    return iteratorValue(type, entry[0], entry[1]);\n\t  }\n\t\n\t  function mapIteratorFrame(node, prev) {\n\t    return {\n\t      node: node,\n\t      index: 0,\n\t      __prev: prev\n\t    };\n\t  }\n\t\n\t  function makeMap(size, root, ownerID, hash) {\n\t    var map = Object.create(MapPrototype);\n\t    map.size = size;\n\t    map._root = root;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_MAP;\n\t  function emptyMap() {\n\t    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n\t  }\n\t\n\t  function updateMap(map, k, v) {\n\t    var newRoot;\n\t    var newSize;\n\t    if (!map._root) {\n\t      if (v === NOT_SET) {\n\t        return map;\n\t      }\n\t      newSize = 1;\n\t      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n\t    } else {\n\t      var didChangeSize = MakeRef(CHANGE_LENGTH);\n\t      var didAlter = MakeRef(DID_ALTER);\n\t      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\t      if (!didAlter.value) {\n\t        return map;\n\t      }\n\t      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n\t    }\n\t    if (map.__ownerID) {\n\t      map.size = newSize;\n\t      map._root = newRoot;\n\t      map.__hash = undefined;\n\t      map.__altered = true;\n\t      return map;\n\t    }\n\t    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n\t  }\n\t\n\t  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n\t    if (!node) {\n\t      if (value === NOT_SET) {\n\t        return node;\n\t      }\n\t      SetRef(didAlter);\n\t      SetRef(didChangeSize);\n\t      return new ValueNode(ownerID, keyHash, [key, value]);\n\t    }\n\t    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n\t  }\n\t\n\t  function isLeafNode(node) {\n\t    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n\t  }\n\t\n\t  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n\t    if (node.keyHash === keyHash) {\n\t      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n\t    }\n\t\n\t    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n\t    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\t\n\t    var newNode;\n\t    var nodes = idx1 === idx2 ?\n\t      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n\t      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\t\n\t    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n\t  }\n\t\n\t  function createNodes(ownerID, entries, key, value) {\n\t    if (!ownerID) {\n\t      ownerID = new OwnerID();\n\t    }\n\t    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\t    for (var ii = 0; ii < entries.length; ii++) {\n\t      var entry = entries[ii];\n\t      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n\t    }\n\t    return node;\n\t  }\n\t\n\t  function packNodes(ownerID, nodes, count, excluding) {\n\t    var bitmap = 0;\n\t    var packedII = 0;\n\t    var packedNodes = new Array(count);\n\t    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n\t      var node = nodes[ii];\n\t      if (node !== undefined && ii !== excluding) {\n\t        bitmap |= bit;\n\t        packedNodes[packedII++] = node;\n\t      }\n\t    }\n\t    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n\t  }\n\t\n\t  function expandNodes(ownerID, nodes, bitmap, including, node) {\n\t    var count = 0;\n\t    var expandedNodes = new Array(SIZE);\n\t    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n\t      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n\t    }\n\t    expandedNodes[including] = node;\n\t    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n\t  }\n\t\n\t  function mergeIntoMapWith(map, merger, iterables) {\n\t    var iters = [];\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = KeyedIterable(value);\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    return mergeIntoCollectionWith(map, merger, iters);\n\t  }\n\t\n\t  function deepMerger(existing, value, key) {\n\t    return existing && existing.mergeDeep && isIterable(value) ?\n\t      existing.mergeDeep(value) :\n\t      is(existing, value) ? existing : value;\n\t  }\n\t\n\t  function deepMergerWith(merger) {\n\t    return function(existing, value, key)  {\n\t      if (existing && existing.mergeDeepWith && isIterable(value)) {\n\t        return existing.mergeDeepWith(merger, value);\n\t      }\n\t      var nextValue = merger(existing, value, key);\n\t      return is(existing, nextValue) ? existing : nextValue;\n\t    };\n\t  }\n\t\n\t  function mergeIntoCollectionWith(collection, merger, iters) {\n\t    iters = iters.filter(function(x ) {return x.size !== 0});\n\t    if (iters.length === 0) {\n\t      return collection;\n\t    }\n\t    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n\t      return collection.constructor(iters[0]);\n\t    }\n\t    return collection.withMutations(function(collection ) {\n\t      var mergeIntoMap = merger ?\n\t        function(value, key)  {\n\t          collection.update(key, NOT_SET, function(existing )\n\t            {return existing === NOT_SET ? value : merger(existing, value, key)}\n\t          );\n\t        } :\n\t        function(value, key)  {\n\t          collection.set(key, value);\n\t        }\n\t      for (var ii = 0; ii < iters.length; ii++) {\n\t        iters[ii].forEach(mergeIntoMap);\n\t      }\n\t    });\n\t  }\n\t\n\t  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n\t    var isNotSet = existing === NOT_SET;\n\t    var step = keyPathIter.next();\n\t    if (step.done) {\n\t      var existingValue = isNotSet ? notSetValue : existing;\n\t      var newValue = updater(existingValue);\n\t      return newValue === existingValue ? existing : newValue;\n\t    }\n\t    invariant(\n\t      isNotSet || (existing && existing.set),\n\t      'invalid keyPath'\n\t    );\n\t    var key = step.value;\n\t    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n\t    var nextUpdated = updateInDeepMap(\n\t      nextExisting,\n\t      keyPathIter,\n\t      notSetValue,\n\t      updater\n\t    );\n\t    return nextUpdated === nextExisting ? existing :\n\t      nextUpdated === NOT_SET ? existing.remove(key) :\n\t      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n\t  }\n\t\n\t  function popCount(x) {\n\t    x = x - ((x >> 1) & 0x55555555);\n\t    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n\t    x = (x + (x >> 4)) & 0x0f0f0f0f;\n\t    x = x + (x >> 8);\n\t    x = x + (x >> 16);\n\t    return x & 0x7f;\n\t  }\n\t\n\t  function setIn(array, idx, val, canEdit) {\n\t    var newArray = canEdit ? array : arrCopy(array);\n\t    newArray[idx] = val;\n\t    return newArray;\n\t  }\n\t\n\t  function spliceIn(array, idx, val, canEdit) {\n\t    var newLen = array.length + 1;\n\t    if (canEdit && idx + 1 === newLen) {\n\t      array[idx] = val;\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        newArray[ii] = val;\n\t        after = -1;\n\t      } else {\n\t        newArray[ii] = array[ii + after];\n\t      }\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  function spliceOut(array, idx, canEdit) {\n\t    var newLen = array.length - 1;\n\t    if (canEdit && idx === newLen) {\n\t      array.pop();\n\t      return array;\n\t    }\n\t    var newArray = new Array(newLen);\n\t    var after = 0;\n\t    for (var ii = 0; ii < newLen; ii++) {\n\t      if (ii === idx) {\n\t        after = 1;\n\t      }\n\t      newArray[ii] = array[ii + after];\n\t    }\n\t    return newArray;\n\t  }\n\t\n\t  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n\t  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n\t  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\t\n\t  createClass(List, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function List(value) {\n\t      var empty = emptyList();\n\t      if (value === null || value === undefined) {\n\t        return empty;\n\t      }\n\t      if (isList(value)) {\n\t        return value;\n\t      }\n\t      var iter = IndexedIterable(value);\n\t      var size = iter.size;\n\t      if (size === 0) {\n\t        return empty;\n\t      }\n\t      assertNotInfinite(size);\n\t      if (size > 0 && size < SIZE) {\n\t        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n\t      }\n\t      return empty.withMutations(function(list ) {\n\t        list.setSize(size);\n\t        iter.forEach(function(v, i)  {return list.set(i, v)});\n\t      });\n\t    }\n\t\n\t    List.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    List.prototype.toString = function() {\n\t      return this.__toString('List [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    List.prototype.get = function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      if (index >= 0 && index < this.size) {\n\t        index += this._origin;\n\t        var node = listNodeFor(this, index);\n\t        return node && node.array[index & MASK];\n\t      }\n\t      return notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    List.prototype.set = function(index, value) {\n\t      return updateList(this, index, value);\n\t    };\n\t\n\t    List.prototype.remove = function(index) {\n\t      return !this.has(index) ? this :\n\t        index === 0 ? this.shift() :\n\t        index === this.size - 1 ? this.pop() :\n\t        this.splice(index, 1);\n\t    };\n\t\n\t    List.prototype.insert = function(index, value) {\n\t      return this.splice(index, 0, value);\n\t    };\n\t\n\t    List.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = this._origin = this._capacity = 0;\n\t        this._level = SHIFT;\n\t        this._root = this._tail = null;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyList();\n\t    };\n\t\n\t    List.prototype.push = function(/*...values*/) {\n\t      var values = arguments;\n\t      var oldSize = this.size;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, 0, oldSize + values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(oldSize + ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.pop = function() {\n\t      return setListBounds(this, 0, -1);\n\t    };\n\t\n\t    List.prototype.unshift = function(/*...values*/) {\n\t      var values = arguments;\n\t      return this.withMutations(function(list ) {\n\t        setListBounds(list, -values.length);\n\t        for (var ii = 0; ii < values.length; ii++) {\n\t          list.set(ii, values[ii]);\n\t        }\n\t      });\n\t    };\n\t\n\t    List.prototype.shift = function() {\n\t      return setListBounds(this, 1);\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    List.prototype.merge = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, undefined, arguments);\n\t    };\n\t\n\t    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, merger, iters);\n\t    };\n\t\n\t    List.prototype.mergeDeep = function(/*...iters*/) {\n\t      return mergeIntoListWith(this, deepMerger, arguments);\n\t    };\n\t\n\t    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n\t    };\n\t\n\t    List.prototype.setSize = function(size) {\n\t      return setListBounds(this, 0, size);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    List.prototype.slice = function(begin, end) {\n\t      var size = this.size;\n\t      if (wholeSlice(begin, end, size)) {\n\t        return this;\n\t      }\n\t      return setListBounds(\n\t        this,\n\t        resolveBegin(begin, size),\n\t        resolveEnd(end, size)\n\t      );\n\t    };\n\t\n\t    List.prototype.__iterator = function(type, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      return new Iterator(function()  {\n\t        var value = values();\n\t        return value === DONE ?\n\t          iteratorDone() :\n\t          iteratorValue(type, index++, value);\n\t      });\n\t    };\n\t\n\t    List.prototype.__iterate = function(fn, reverse) {\n\t      var index = 0;\n\t      var values = iterateList(this, reverse);\n\t      var value;\n\t      while ((value = values()) !== DONE) {\n\t        if (fn(value, index++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return index;\n\t    };\n\t\n\t    List.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        return this;\n\t      }\n\t      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isList(maybeList) {\n\t    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n\t  }\n\t\n\t  List.isList = isList;\n\t\n\t  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\t\n\t  var ListPrototype = List.prototype;\n\t  ListPrototype[IS_LIST_SENTINEL] = true;\n\t  ListPrototype[DELETE] = ListPrototype.remove;\n\t  ListPrototype.setIn = MapPrototype.setIn;\n\t  ListPrototype.deleteIn =\n\t  ListPrototype.removeIn = MapPrototype.removeIn;\n\t  ListPrototype.update = MapPrototype.update;\n\t  ListPrototype.updateIn = MapPrototype.updateIn;\n\t  ListPrototype.mergeIn = MapPrototype.mergeIn;\n\t  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  ListPrototype.withMutations = MapPrototype.withMutations;\n\t  ListPrototype.asMutable = MapPrototype.asMutable;\n\t  ListPrototype.asImmutable = MapPrototype.asImmutable;\n\t  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t\n\t    function VNode(array, ownerID) {\n\t      this.array = array;\n\t      this.ownerID = ownerID;\n\t    }\n\t\n\t    // TODO: seems like these methods are very similar\n\t\n\t    VNode.prototype.removeBefore = function(ownerID, level, index) {\n\t      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var originIndex = (index >>> level) & MASK;\n\t      if (originIndex >= this.array.length) {\n\t        return new VNode([], ownerID);\n\t      }\n\t      var removingFirst = originIndex === 0;\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[originIndex];\n\t        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && removingFirst) {\n\t          return this;\n\t        }\n\t      }\n\t      if (removingFirst && !newChild) {\n\t        return this;\n\t      }\n\t      var editable = editableVNode(this, ownerID);\n\t      if (!removingFirst) {\n\t        for (var ii = 0; ii < originIndex; ii++) {\n\t          editable.array[ii] = undefined;\n\t        }\n\t      }\n\t      if (newChild) {\n\t        editable.array[originIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t    VNode.prototype.removeAfter = function(ownerID, level, index) {\n\t      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n\t        return this;\n\t      }\n\t      var sizeIndex = ((index - 1) >>> level) & MASK;\n\t      if (sizeIndex >= this.array.length) {\n\t        return this;\n\t      }\n\t\n\t      var newChild;\n\t      if (level > 0) {\n\t        var oldChild = this.array[sizeIndex];\n\t        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\t        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n\t          return this;\n\t        }\n\t      }\n\t\n\t      var editable = editableVNode(this, ownerID);\n\t      editable.array.splice(sizeIndex + 1);\n\t      if (newChild) {\n\t        editable.array[sizeIndex] = newChild;\n\t      }\n\t      return editable;\n\t    };\n\t\n\t\n\t\n\t  var DONE = {};\n\t\n\t  function iterateList(list, reverse) {\n\t    var left = list._origin;\n\t    var right = list._capacity;\n\t    var tailPos = getTailOffset(right);\n\t    var tail = list._tail;\n\t\n\t    return iterateNodeOrLeaf(list._root, list._level, 0);\n\t\n\t    function iterateNodeOrLeaf(node, level, offset) {\n\t      return level === 0 ?\n\t        iterateLeaf(node, offset) :\n\t        iterateNode(node, level, offset);\n\t    }\n\t\n\t    function iterateLeaf(node, offset) {\n\t      var array = offset === tailPos ? tail && tail.array : node && node.array;\n\t      var from = offset > left ? 0 : left - offset;\n\t      var to = right - offset;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        if (from === to) {\n\t          return DONE;\n\t        }\n\t        var idx = reverse ? --to : from++;\n\t        return array && array[idx];\n\t      };\n\t    }\n\t\n\t    function iterateNode(node, level, offset) {\n\t      var values;\n\t      var array = node && node.array;\n\t      var from = offset > left ? 0 : (left - offset) >> level;\n\t      var to = ((right - offset) >> level) + 1;\n\t      if (to > SIZE) {\n\t        to = SIZE;\n\t      }\n\t      return function()  {\n\t        do {\n\t          if (values) {\n\t            var value = values();\n\t            if (value !== DONE) {\n\t              return value;\n\t            }\n\t            values = null;\n\t          }\n\t          if (from === to) {\n\t            return DONE;\n\t          }\n\t          var idx = reverse ? --to : from++;\n\t          values = iterateNodeOrLeaf(\n\t            array && array[idx], level - SHIFT, offset + (idx << level)\n\t          );\n\t        } while (true);\n\t      };\n\t    }\n\t  }\n\t\n\t  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n\t    var list = Object.create(ListPrototype);\n\t    list.size = capacity - origin;\n\t    list._origin = origin;\n\t    list._capacity = capacity;\n\t    list._level = level;\n\t    list._root = root;\n\t    list._tail = tail;\n\t    list.__ownerID = ownerID;\n\t    list.__hash = hash;\n\t    list.__altered = false;\n\t    return list;\n\t  }\n\t\n\t  var EMPTY_LIST;\n\t  function emptyList() {\n\t    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n\t  }\n\t\n\t  function updateList(list, index, value) {\n\t    index = wrapIndex(list, index);\n\t\n\t    if (index !== index) {\n\t      return list;\n\t    }\n\t\n\t    if (index >= list.size || index < 0) {\n\t      return list.withMutations(function(list ) {\n\t        index < 0 ?\n\t          setListBounds(list, index).set(0, value) :\n\t          setListBounds(list, 0, index + 1).set(index, value)\n\t      });\n\t    }\n\t\n\t    index += list._origin;\n\t\n\t    var newTail = list._tail;\n\t    var newRoot = list._root;\n\t    var didAlter = MakeRef(DID_ALTER);\n\t    if (index >= getTailOffset(list._capacity)) {\n\t      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n\t    } else {\n\t      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n\t    }\n\t\n\t    if (!didAlter.value) {\n\t      return list;\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n\t  }\n\t\n\t  function updateVNode(node, ownerID, level, index, value, didAlter) {\n\t    var idx = (index >>> level) & MASK;\n\t    var nodeHas = node && idx < node.array.length;\n\t    if (!nodeHas && value === undefined) {\n\t      return node;\n\t    }\n\t\n\t    var newNode;\n\t\n\t    if (level > 0) {\n\t      var lowerNode = node && node.array[idx];\n\t      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\t      if (newLowerNode === lowerNode) {\n\t        return node;\n\t      }\n\t      newNode = editableVNode(node, ownerID);\n\t      newNode.array[idx] = newLowerNode;\n\t      return newNode;\n\t    }\n\t\n\t    if (nodeHas && node.array[idx] === value) {\n\t      return node;\n\t    }\n\t\n\t    SetRef(didAlter);\n\t\n\t    newNode = editableVNode(node, ownerID);\n\t    if (value === undefined && idx === newNode.array.length - 1) {\n\t      newNode.array.pop();\n\t    } else {\n\t      newNode.array[idx] = value;\n\t    }\n\t    return newNode;\n\t  }\n\t\n\t  function editableVNode(node, ownerID) {\n\t    if (ownerID && node && ownerID === node.ownerID) {\n\t      return node;\n\t    }\n\t    return new VNode(node ? node.array.slice() : [], ownerID);\n\t  }\n\t\n\t  function listNodeFor(list, rawIndex) {\n\t    if (rawIndex >= getTailOffset(list._capacity)) {\n\t      return list._tail;\n\t    }\n\t    if (rawIndex < 1 << (list._level + SHIFT)) {\n\t      var node = list._root;\n\t      var level = list._level;\n\t      while (node && level > 0) {\n\t        node = node.array[(rawIndex >>> level) & MASK];\n\t        level -= SHIFT;\n\t      }\n\t      return node;\n\t    }\n\t  }\n\t\n\t  function setListBounds(list, begin, end) {\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      end = end | 0;\n\t    }\n\t    var owner = list.__ownerID || new OwnerID();\n\t    var oldOrigin = list._origin;\n\t    var oldCapacity = list._capacity;\n\t    var newOrigin = oldOrigin + begin;\n\t    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\t    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n\t      return list;\n\t    }\n\t\n\t    // If it's going to end after it starts, it's empty.\n\t    if (newOrigin >= newCapacity) {\n\t      return list.clear();\n\t    }\n\t\n\t    var newLevel = list._level;\n\t    var newRoot = list._root;\n\t\n\t    // New origin might need creating a higher root.\n\t    var offsetShift = 0;\n\t    while (newOrigin + offsetShift < 0) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t      offsetShift += 1 << newLevel;\n\t    }\n\t    if (offsetShift) {\n\t      newOrigin += offsetShift;\n\t      oldOrigin += offsetShift;\n\t      newCapacity += offsetShift;\n\t      oldCapacity += offsetShift;\n\t    }\n\t\n\t    var oldTailOffset = getTailOffset(oldCapacity);\n\t    var newTailOffset = getTailOffset(newCapacity);\n\t\n\t    // New size might need creating a higher root.\n\t    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n\t      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n\t      newLevel += SHIFT;\n\t    }\n\t\n\t    // Locate or create the new tail.\n\t    var oldTail = list._tail;\n\t    var newTail = newTailOffset < oldTailOffset ?\n\t      listNodeFor(list, newCapacity - 1) :\n\t      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\t\n\t    // Merge Tail into tree.\n\t    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n\t      newRoot = editableVNode(newRoot, owner);\n\t      var node = newRoot;\n\t      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n\t        var idx = (oldTailOffset >>> level) & MASK;\n\t        node = node.array[idx] = editableVNode(node.array[idx], owner);\n\t      }\n\t      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n\t    }\n\t\n\t    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\t    if (newCapacity < oldCapacity) {\n\t      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n\t    }\n\t\n\t    // If the new origin is within the tail, then we do not need a root.\n\t    if (newOrigin >= newTailOffset) {\n\t      newOrigin -= newTailOffset;\n\t      newCapacity -= newTailOffset;\n\t      newLevel = SHIFT;\n\t      newRoot = null;\n\t      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\t\n\t    // Otherwise, if the root has been trimmed, garbage collect.\n\t    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n\t      offsetShift = 0;\n\t\n\t      // Identify the new top root node of the subtree of the old root.\n\t      while (newRoot) {\n\t        var beginIndex = (newOrigin >>> newLevel) & MASK;\n\t        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n\t          break;\n\t        }\n\t        if (beginIndex) {\n\t          offsetShift += (1 << newLevel) * beginIndex;\n\t        }\n\t        newLevel -= SHIFT;\n\t        newRoot = newRoot.array[beginIndex];\n\t      }\n\t\n\t      // Trim the new sides of the new root.\n\t      if (newRoot && newOrigin > oldOrigin) {\n\t        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n\t      }\n\t      if (newRoot && newTailOffset < oldTailOffset) {\n\t        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n\t      }\n\t      if (offsetShift) {\n\t        newOrigin -= offsetShift;\n\t        newCapacity -= offsetShift;\n\t      }\n\t    }\n\t\n\t    if (list.__ownerID) {\n\t      list.size = newCapacity - newOrigin;\n\t      list._origin = newOrigin;\n\t      list._capacity = newCapacity;\n\t      list._level = newLevel;\n\t      list._root = newRoot;\n\t      list._tail = newTail;\n\t      list.__hash = undefined;\n\t      list.__altered = true;\n\t      return list;\n\t    }\n\t    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n\t  }\n\t\n\t  function mergeIntoListWith(list, merger, iterables) {\n\t    var iters = [];\n\t    var maxSize = 0;\n\t    for (var ii = 0; ii < iterables.length; ii++) {\n\t      var value = iterables[ii];\n\t      var iter = IndexedIterable(value);\n\t      if (iter.size > maxSize) {\n\t        maxSize = iter.size;\n\t      }\n\t      if (!isIterable(value)) {\n\t        iter = iter.map(function(v ) {return fromJS(v)});\n\t      }\n\t      iters.push(iter);\n\t    }\n\t    if (maxSize > list.size) {\n\t      list = list.setSize(maxSize);\n\t    }\n\t    return mergeIntoCollectionWith(list, merger, iters);\n\t  }\n\t\n\t  function getTailOffset(size) {\n\t    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n\t  }\n\t\n\t  createClass(OrderedMap, Map);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedMap(value) {\n\t      return value === null || value === undefined ? emptyOrderedMap() :\n\t        isOrderedMap(value) ? value :\n\t        emptyOrderedMap().withMutations(function(map ) {\n\t          var iter = KeyedIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v, k)  {return map.set(k, v)});\n\t        });\n\t    }\n\t\n\t    OrderedMap.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedMap.prototype.toString = function() {\n\t      return this.__toString('OrderedMap {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    OrderedMap.prototype.get = function(k, notSetValue) {\n\t      var index = this._map.get(k);\n\t      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    OrderedMap.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._map.clear();\n\t        this._list.clear();\n\t        return this;\n\t      }\n\t      return emptyOrderedMap();\n\t    };\n\t\n\t    OrderedMap.prototype.set = function(k, v) {\n\t      return updateOrderedMap(this, k, v);\n\t    };\n\t\n\t    OrderedMap.prototype.remove = function(k) {\n\t      return updateOrderedMap(this, k, NOT_SET);\n\t    };\n\t\n\t    OrderedMap.prototype.wasAltered = function() {\n\t      return this._map.wasAltered() || this._list.wasAltered();\n\t    };\n\t\n\t    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._list.__iterate(\n\t        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n\t        reverse\n\t      );\n\t    };\n\t\n\t    OrderedMap.prototype.__iterator = function(type, reverse) {\n\t      return this._list.fromEntrySeq().__iterator(type, reverse);\n\t    };\n\t\n\t    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      var newList = this._list.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        this._list = newList;\n\t        return this;\n\t      }\n\t      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n\t    };\n\t\n\t\n\t  function isOrderedMap(maybeOrderedMap) {\n\t    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n\t  }\n\t\n\t  OrderedMap.isOrderedMap = isOrderedMap;\n\t\n\t  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n\t  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\t\n\t\n\t\n\t  function makeOrderedMap(map, list, ownerID, hash) {\n\t    var omap = Object.create(OrderedMap.prototype);\n\t    omap.size = map ? map.size : 0;\n\t    omap._map = map;\n\t    omap._list = list;\n\t    omap.__ownerID = ownerID;\n\t    omap.__hash = hash;\n\t    return omap;\n\t  }\n\t\n\t  var EMPTY_ORDERED_MAP;\n\t  function emptyOrderedMap() {\n\t    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n\t  }\n\t\n\t  function updateOrderedMap(omap, k, v) {\n\t    var map = omap._map;\n\t    var list = omap._list;\n\t    var i = map.get(k);\n\t    var has = i !== undefined;\n\t    var newMap;\n\t    var newList;\n\t    if (v === NOT_SET) { // removed\n\t      if (!has) {\n\t        return omap;\n\t      }\n\t      if (list.size >= SIZE && list.size >= map.size * 2) {\n\t        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n\t        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n\t        if (omap.__ownerID) {\n\t          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n\t        }\n\t      } else {\n\t        newMap = map.remove(k);\n\t        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n\t      }\n\t    } else {\n\t      if (has) {\n\t        if (v === list.get(i)[1]) {\n\t          return omap;\n\t        }\n\t        newMap = map;\n\t        newList = list.set(i, [k, v]);\n\t      } else {\n\t        newMap = map.set(k, list.size);\n\t        newList = list.set(list.size, [k, v]);\n\t      }\n\t    }\n\t    if (omap.__ownerID) {\n\t      omap.size = newMap.size;\n\t      omap._map = newMap;\n\t      omap._list = newList;\n\t      omap.__hash = undefined;\n\t      return omap;\n\t    }\n\t    return makeOrderedMap(newMap, newList);\n\t  }\n\t\n\t  createClass(ToKeyedSequence, KeyedSeq);\n\t    function ToKeyedSequence(indexed, useKeys) {\n\t      this._iter = indexed;\n\t      this._useKeys = useKeys;\n\t      this.size = indexed.size;\n\t    }\n\t\n\t    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n\t      return this._iter.get(key, notSetValue);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.has = function(key) {\n\t      return this._iter.has(key);\n\t    };\n\t\n\t    ToKeyedSequence.prototype.valueSeq = function() {\n\t      return this._iter.valueSeq();\n\t    };\n\t\n\t    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n\t      var reversedSequence = reverseFactory(this, true);\n\t      if (!this._useKeys) {\n\t        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n\t      }\n\t      return reversedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n\t      var mappedSequence = mapFactory(this, mapper, context);\n\t      if (!this._useKeys) {\n\t        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n\t      }\n\t      return mappedSequence;\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var ii;\n\t      return this._iter.__iterate(\n\t        this._useKeys ?\n\t          function(v, k)  {return fn(v, k, this$0)} :\n\t          ((ii = reverse ? resolveSize(this) : 0),\n\t            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n\t        reverse\n\t      );\n\t    };\n\t\n\t    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n\t      if (this._useKeys) {\n\t        return this._iter.__iterator(type, reverse);\n\t      }\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var ii = reverse ? resolveSize(this) : 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n\t      });\n\t    };\n\t\n\t  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t  createClass(ToIndexedSequence, IndexedSeq);\n\t    function ToIndexedSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToIndexedSequence.prototype.includes = function(value) {\n\t      return this._iter.includes(value);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n\t    };\n\t\n\t    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, iterations++, step.value, step)\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(ToSetSequence, SetSeq);\n\t    function ToSetSequence(iter) {\n\t      this._iter = iter;\n\t      this.size = iter.size;\n\t    }\n\t\n\t    ToSetSequence.prototype.has = function(key) {\n\t      return this._iter.includes(key);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n\t    };\n\t\n\t    ToSetSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        return step.done ? step :\n\t          iteratorValue(type, step.value, step.value, step);\n\t      });\n\t    };\n\t\n\t\n\t\n\t  createClass(FromEntriesSequence, KeyedSeq);\n\t    function FromEntriesSequence(entries) {\n\t      this._iter = entries;\n\t      this.size = entries.size;\n\t    }\n\t\n\t    FromEntriesSequence.prototype.entrySeq = function() {\n\t      return this._iter.toSeq();\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._iter.__iterate(function(entry ) {\n\t        // Check if entry exists first so array access doesn't throw for holes\n\t        // in the parent iteration.\n\t        if (entry) {\n\t          validateEntry(entry);\n\t          var indexedIterable = isIterable(entry);\n\t          return fn(\n\t            indexedIterable ? entry.get(1) : entry[1],\n\t            indexedIterable ? entry.get(0) : entry[0],\n\t            this$0\n\t          );\n\t        }\n\t      }, reverse);\n\t    };\n\t\n\t    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n\t      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          // Check if entry exists first so array access doesn't throw for holes\n\t          // in the parent iteration.\n\t          if (entry) {\n\t            validateEntry(entry);\n\t            var indexedIterable = isIterable(entry);\n\t            return iteratorValue(\n\t              type,\n\t              indexedIterable ? entry.get(0) : entry[0],\n\t              indexedIterable ? entry.get(1) : entry[1],\n\t              step\n\t            );\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t\n\t  ToIndexedSequence.prototype.cacheResult =\n\t  ToKeyedSequence.prototype.cacheResult =\n\t  ToSetSequence.prototype.cacheResult =\n\t  FromEntriesSequence.prototype.cacheResult =\n\t    cacheResultThrough;\n\t\n\t\n\t  function flipFactory(iterable) {\n\t    var flipSequence = makeSequence(iterable);\n\t    flipSequence._iter = iterable;\n\t    flipSequence.size = iterable.size;\n\t    flipSequence.flip = function()  {return iterable};\n\t    flipSequence.reverse = function () {\n\t      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n\t      reversedSequence.flip = function()  {return iterable.reverse()};\n\t      return reversedSequence;\n\t    };\n\t    flipSequence.has = function(key ) {return iterable.includes(key)};\n\t    flipSequence.includes = function(key ) {return iterable.has(key)};\n\t    flipSequence.cacheResult = cacheResultThrough;\n\t    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n\t    }\n\t    flipSequence.__iteratorUncached = function(type, reverse) {\n\t      if (type === ITERATE_ENTRIES) {\n\t        var iterator = iterable.__iterator(type, reverse);\n\t        return new Iterator(function()  {\n\t          var step = iterator.next();\n\t          if (!step.done) {\n\t            var k = step.value[0];\n\t            step.value[0] = step.value[1];\n\t            step.value[1] = k;\n\t          }\n\t          return step;\n\t        });\n\t      }\n\t      return iterable.__iterator(\n\t        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n\t        reverse\n\t      );\n\t    }\n\t    return flipSequence;\n\t  }\n\t\n\t\n\t  function mapFactory(iterable, mapper, context) {\n\t    var mappedSequence = makeSequence(iterable);\n\t    mappedSequence.size = iterable.size;\n\t    mappedSequence.has = function(key ) {return iterable.has(key)};\n\t    mappedSequence.get = function(key, notSetValue)  {\n\t      var v = iterable.get(key, NOT_SET);\n\t      return v === NOT_SET ?\n\t        notSetValue :\n\t        mapper.call(context, v, key, iterable);\n\t    };\n\t    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(\n\t        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n\t        reverse\n\t      );\n\t    }\n\t    mappedSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      return new Iterator(function()  {\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var key = entry[0];\n\t        return iteratorValue(\n\t          type,\n\t          key,\n\t          mapper.call(context, entry[1], key, iterable),\n\t          step\n\t        );\n\t      });\n\t    }\n\t    return mappedSequence;\n\t  }\n\t\n\t\n\t  function reverseFactory(iterable, useKeys) {\n\t    var reversedSequence = makeSequence(iterable);\n\t    reversedSequence._iter = iterable;\n\t    reversedSequence.size = iterable.size;\n\t    reversedSequence.reverse = function()  {return iterable};\n\t    if (iterable.flip) {\n\t      reversedSequence.flip = function () {\n\t        var flipSequence = flipFactory(iterable);\n\t        flipSequence.reverse = function()  {return iterable.flip()};\n\t        return flipSequence;\n\t      };\n\t    }\n\t    reversedSequence.get = function(key, notSetValue) \n\t      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n\t    reversedSequence.has = function(key )\n\t      {return iterable.has(useKeys ? key : -1 - key)};\n\t    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n\t    reversedSequence.cacheResult = cacheResultThrough;\n\t    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n\t      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n\t    };\n\t    reversedSequence.__iterator =\n\t      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n\t    return reversedSequence;\n\t  }\n\t\n\t\n\t  function filterFactory(iterable, predicate, context, useKeys) {\n\t    var filterSequence = makeSequence(iterable);\n\t    if (useKeys) {\n\t      filterSequence.has = function(key ) {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n\t      };\n\t      filterSequence.get = function(key, notSetValue)  {\n\t        var v = iterable.get(key, NOT_SET);\n\t        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n\t          v : notSetValue;\n\t      };\n\t    }\n\t    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      }, reverse);\n\t      return iterations;\n\t    };\n\t    filterSequence.__iteratorUncached = function (type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (true) {\n\t          var step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t          var entry = step.value;\n\t          var key = entry[0];\n\t          var value = entry[1];\n\t          if (predicate.call(context, value, key, iterable)) {\n\t            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n\t          }\n\t        }\n\t      });\n\t    }\n\t    return filterSequence;\n\t  }\n\t\n\t\n\t  function countByFactory(iterable, grouper, context) {\n\t    var groups = Map().asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        0,\n\t        function(a ) {return a + 1}\n\t      );\n\t    });\n\t    return groups.asImmutable();\n\t  }\n\t\n\t\n\t  function groupByFactory(iterable, grouper, context) {\n\t    var isKeyedIter = isKeyed(iterable);\n\t    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n\t    iterable.__iterate(function(v, k)  {\n\t      groups.update(\n\t        grouper.call(context, v, k, iterable),\n\t        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n\t      );\n\t    });\n\t    var coerce = iterableClass(iterable);\n\t    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n\t  }\n\t\n\t\n\t  function sliceFactory(iterable, begin, end, useKeys) {\n\t    var originalSize = iterable.size;\n\t\n\t    // Sanitize begin & end using this shorthand for ToInt32(argument)\n\t    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n\t    if (begin !== undefined) {\n\t      begin = begin | 0;\n\t    }\n\t    if (end !== undefined) {\n\t      if (end === Infinity) {\n\t        end = originalSize;\n\t      } else {\n\t        end = end | 0;\n\t      }\n\t    }\n\t\n\t    if (wholeSlice(begin, end, originalSize)) {\n\t      return iterable;\n\t    }\n\t\n\t    var resolvedBegin = resolveBegin(begin, originalSize);\n\t    var resolvedEnd = resolveEnd(end, originalSize);\n\t\n\t    // begin or end will be NaN if they were provided as negative numbers and\n\t    // this iterable's size is unknown. In that case, cache first so there is\n\t    // a known size and these do not resolve to NaN.\n\t    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n\t      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n\t    }\n\t\n\t    // Note: resolvedEnd is undefined when the original sequence's length is\n\t    // unknown and this slice did not supply an end and should contain all\n\t    // elements after resolvedBegin.\n\t    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n\t    var resolvedSize = resolvedEnd - resolvedBegin;\n\t    var sliceSize;\n\t    if (resolvedSize === resolvedSize) {\n\t      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n\t    }\n\t\n\t    var sliceSeq = makeSequence(iterable);\n\t\n\t    // If iterable.size is undefined, the size of the realized sliceSeq is\n\t    // unknown at this point unless the number of items to slice is 0\n\t    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\t\n\t    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n\t      sliceSeq.get = function (index, notSetValue) {\n\t        index = wrapIndex(this, index);\n\t        return index >= 0 && index < sliceSize ?\n\t          iterable.get(index + resolvedBegin, notSetValue) :\n\t          notSetValue;\n\t      }\n\t    }\n\t\n\t    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (sliceSize === 0) {\n\t        return 0;\n\t      }\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var skipped = 0;\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k)  {\n\t        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n\t                 iterations !== sliceSize;\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t\n\t    sliceSeq.__iteratorUncached = function(type, reverse) {\n\t      if (sliceSize !== 0 && reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      // Don't bother instantiating parent iterator if taking 0.\n\t      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n\t      var skipped = 0;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (skipped++ < resolvedBegin) {\n\t          iterator.next();\n\t        }\n\t        if (++iterations > sliceSize) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (useKeys || type === ITERATE_VALUES) {\n\t          return step;\n\t        } else if (type === ITERATE_KEYS) {\n\t          return iteratorValue(type, iterations - 1, undefined, step);\n\t        } else {\n\t          return iteratorValue(type, iterations - 1, step.value[1], step);\n\t        }\n\t      });\n\t    }\n\t\n\t    return sliceSeq;\n\t  }\n\t\n\t\n\t  function takeWhileFactory(iterable, predicate, context) {\n\t    var takeSequence = makeSequence(iterable);\n\t    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c) \n\t        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n\t      );\n\t      return iterations;\n\t    };\n\t    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var iterating = true;\n\t      return new Iterator(function()  {\n\t        if (!iterating) {\n\t          return iteratorDone();\n\t        }\n\t        var step = iterator.next();\n\t        if (step.done) {\n\t          return step;\n\t        }\n\t        var entry = step.value;\n\t        var k = entry[0];\n\t        var v = entry[1];\n\t        if (!predicate.call(context, v, k, this$0)) {\n\t          iterating = false;\n\t          return iteratorDone();\n\t        }\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return takeSequence;\n\t  }\n\t\n\t\n\t  function skipWhileFactory(iterable, predicate, context, useKeys) {\n\t    var skipSequence = makeSequence(iterable);\n\t    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterate(fn, reverse);\n\t      }\n\t      var isSkipping = true;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k, c)  {\n\t        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n\t          iterations++;\n\t          return fn(v, useKeys ? k : iterations - 1, this$0);\n\t        }\n\t      });\n\t      return iterations;\n\t    };\n\t    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n\t      if (reverse) {\n\t        return this.cacheResult().__iterator(type, reverse);\n\t      }\n\t      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n\t      var skipping = true;\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        var step, k, v;\n\t        do {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            if (useKeys || type === ITERATE_VALUES) {\n\t              return step;\n\t            } else if (type === ITERATE_KEYS) {\n\t              return iteratorValue(type, iterations++, undefined, step);\n\t            } else {\n\t              return iteratorValue(type, iterations++, step.value[1], step);\n\t            }\n\t          }\n\t          var entry = step.value;\n\t          k = entry[0];\n\t          v = entry[1];\n\t          skipping && (skipping = predicate.call(context, v, k, this$0));\n\t        } while (skipping);\n\t        return type === ITERATE_ENTRIES ? step :\n\t          iteratorValue(type, k, v, step);\n\t      });\n\t    };\n\t    return skipSequence;\n\t  }\n\t\n\t\n\t  function concatFactory(iterable, values) {\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var iters = [iterable].concat(values).map(function(v ) {\n\t      if (!isIterable(v)) {\n\t        v = isKeyedIterable ?\n\t          keyedSeqFromValue(v) :\n\t          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n\t      } else if (isKeyedIterable) {\n\t        v = KeyedIterable(v);\n\t      }\n\t      return v;\n\t    }).filter(function(v ) {return v.size !== 0});\n\t\n\t    if (iters.length === 0) {\n\t      return iterable;\n\t    }\n\t\n\t    if (iters.length === 1) {\n\t      var singleton = iters[0];\n\t      if (singleton === iterable ||\n\t          isKeyedIterable && isKeyed(singleton) ||\n\t          isIndexed(iterable) && isIndexed(singleton)) {\n\t        return singleton;\n\t      }\n\t    }\n\t\n\t    var concatSeq = new ArraySeq(iters);\n\t    if (isKeyedIterable) {\n\t      concatSeq = concatSeq.toKeyedSeq();\n\t    } else if (!isIndexed(iterable)) {\n\t      concatSeq = concatSeq.toSetSeq();\n\t    }\n\t    concatSeq = concatSeq.flatten(true);\n\t    concatSeq.size = iters.reduce(\n\t      function(sum, seq)  {\n\t        if (sum !== undefined) {\n\t          var size = seq.size;\n\t          if (size !== undefined) {\n\t            return sum + size;\n\t          }\n\t        }\n\t      },\n\t      0\n\t    );\n\t    return concatSeq;\n\t  }\n\t\n\t\n\t  function flattenFactory(iterable, depth, useKeys) {\n\t    var flatSequence = makeSequence(iterable);\n\t    flatSequence.__iterateUncached = function(fn, reverse) {\n\t      var iterations = 0;\n\t      var stopped = false;\n\t      function flatDeep(iter, currentDepth) {var this$0 = this;\n\t        iter.__iterate(function(v, k)  {\n\t          if ((!depth || currentDepth < depth) && isIterable(v)) {\n\t            flatDeep(v, currentDepth + 1);\n\t          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n\t            stopped = true;\n\t          }\n\t          return !stopped;\n\t        }, reverse);\n\t      }\n\t      flatDeep(iterable, 0);\n\t      return iterations;\n\t    }\n\t    flatSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(type, reverse);\n\t      var stack = [];\n\t      var iterations = 0;\n\t      return new Iterator(function()  {\n\t        while (iterator) {\n\t          var step = iterator.next();\n\t          if (step.done !== false) {\n\t            iterator = stack.pop();\n\t            continue;\n\t          }\n\t          var v = step.value;\n\t          if (type === ITERATE_ENTRIES) {\n\t            v = v[1];\n\t          }\n\t          if ((!depth || stack.length < depth) && isIterable(v)) {\n\t            stack.push(iterator);\n\t            iterator = v.__iterator(type, reverse);\n\t          } else {\n\t            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n\t          }\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    }\n\t    return flatSequence;\n\t  }\n\t\n\t\n\t  function flatMapFactory(iterable, mapper, context) {\n\t    var coerce = iterableClass(iterable);\n\t    return iterable.toSeq().map(\n\t      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n\t    ).flatten(true);\n\t  }\n\t\n\t\n\t  function interposeFactory(iterable, separator) {\n\t    var interposedSequence = makeSequence(iterable);\n\t    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n\t    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n\t      var iterations = 0;\n\t      iterable.__iterate(function(v, k) \n\t        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n\t        fn(v, iterations++, this$0) !== false},\n\t        reverse\n\t      );\n\t      return iterations;\n\t    };\n\t    interposedSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n\t      var iterations = 0;\n\t      var step;\n\t      return new Iterator(function()  {\n\t        if (!step || iterations % 2) {\n\t          step = iterator.next();\n\t          if (step.done) {\n\t            return step;\n\t          }\n\t        }\n\t        return iterations % 2 ?\n\t          iteratorValue(type, iterations++, separator) :\n\t          iteratorValue(type, iterations++, step.value, step);\n\t      });\n\t    };\n\t    return interposedSequence;\n\t  }\n\t\n\t\n\t  function sortFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    var isKeyedIterable = isKeyed(iterable);\n\t    var index = 0;\n\t    var entries = iterable.toSeq().map(\n\t      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n\t    ).toArray();\n\t    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n\t      isKeyedIterable ?\n\t      function(v, i)  { entries[i].length = 2; } :\n\t      function(v, i)  { entries[i] = v[1]; }\n\t    );\n\t    return isKeyedIterable ? KeyedSeq(entries) :\n\t      isIndexed(iterable) ? IndexedSeq(entries) :\n\t      SetSeq(entries);\n\t  }\n\t\n\t\n\t  function maxFactory(iterable, comparator, mapper) {\n\t    if (!comparator) {\n\t      comparator = defaultComparator;\n\t    }\n\t    if (mapper) {\n\t      var entry = iterable.toSeq()\n\t        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n\t        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n\t      return entry && entry[0];\n\t    } else {\n\t      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n\t    }\n\t  }\n\t\n\t  function maxCompare(comparator, a, b) {\n\t    var comp = comparator(b, a);\n\t    // b is considered the new max if the comparator declares them equal, but\n\t    // they are not equal and b is in fact a nullish value.\n\t    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n\t  }\n\t\n\t\n\t  function zipWithFactory(keyIter, zipper, iters) {\n\t    var zipSequence = makeSequence(keyIter);\n\t    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n\t    // Note: this a generic base implementation of __iterate in terms of\n\t    // __iterator which may be more generically useful in the future.\n\t    zipSequence.__iterate = function(fn, reverse) {\n\t      /* generic:\n\t      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        iterations++;\n\t        if (fn(step.value[1], step.value[0], this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t      */\n\t      // indexed:\n\t      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\t      var step;\n\t      var iterations = 0;\n\t      while (!(step = iterator.next()).done) {\n\t        if (fn(step.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return iterations;\n\t    };\n\t    zipSequence.__iteratorUncached = function(type, reverse) {\n\t      var iterators = iters.map(function(i )\n\t        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n\t      );\n\t      var iterations = 0;\n\t      var isDone = false;\n\t      return new Iterator(function()  {\n\t        var steps;\n\t        if (!isDone) {\n\t          steps = iterators.map(function(i ) {return i.next()});\n\t          isDone = steps.some(function(s ) {return s.done});\n\t        }\n\t        if (isDone) {\n\t          return iteratorDone();\n\t        }\n\t        return iteratorValue(\n\t          type,\n\t          iterations++,\n\t          zipper.apply(null, steps.map(function(s ) {return s.value}))\n\t        );\n\t      });\n\t    };\n\t    return zipSequence\n\t  }\n\t\n\t\n\t  // #pragma Helper Functions\n\t\n\t  function reify(iter, seq) {\n\t    return isSeq(iter) ? seq : iter.constructor(seq);\n\t  }\n\t\n\t  function validateEntry(entry) {\n\t    if (entry !== Object(entry)) {\n\t      throw new TypeError('Expected [K, V] tuple: ' + entry);\n\t    }\n\t  }\n\t\n\t  function resolveSize(iter) {\n\t    assertNotInfinite(iter.size);\n\t    return ensureSize(iter);\n\t  }\n\t\n\t  function iterableClass(iterable) {\n\t    return isKeyed(iterable) ? KeyedIterable :\n\t      isIndexed(iterable) ? IndexedIterable :\n\t      SetIterable;\n\t  }\n\t\n\t  function makeSequence(iterable) {\n\t    return Object.create(\n\t      (\n\t        isKeyed(iterable) ? KeyedSeq :\n\t        isIndexed(iterable) ? IndexedSeq :\n\t        SetSeq\n\t      ).prototype\n\t    );\n\t  }\n\t\n\t  function cacheResultThrough() {\n\t    if (this._iter.cacheResult) {\n\t      this._iter.cacheResult();\n\t      this.size = this._iter.size;\n\t      return this;\n\t    } else {\n\t      return Seq.prototype.cacheResult.call(this);\n\t    }\n\t  }\n\t\n\t  function defaultComparator(a, b) {\n\t    return a > b ? 1 : a < b ? -1 : 0;\n\t  }\n\t\n\t  function forceIterator(keyPath) {\n\t    var iter = getIterator(keyPath);\n\t    if (!iter) {\n\t      // Array might not be iterable in this environment, so we need a fallback\n\t      // to our wrapped type.\n\t      if (!isArrayLike(keyPath)) {\n\t        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n\t      }\n\t      iter = getIterator(Iterable(keyPath));\n\t    }\n\t    return iter;\n\t  }\n\t\n\t  createClass(Record, KeyedCollection);\n\t\n\t    function Record(defaultValues, name) {\n\t      var hasInitialized;\n\t\n\t      var RecordType = function Record(values) {\n\t        if (values instanceof RecordType) {\n\t          return values;\n\t        }\n\t        if (!(this instanceof RecordType)) {\n\t          return new RecordType(values);\n\t        }\n\t        if (!hasInitialized) {\n\t          hasInitialized = true;\n\t          var keys = Object.keys(defaultValues);\n\t          setProps(RecordTypePrototype, keys);\n\t          RecordTypePrototype.size = keys.length;\n\t          RecordTypePrototype._name = name;\n\t          RecordTypePrototype._keys = keys;\n\t          RecordTypePrototype._defaultValues = defaultValues;\n\t        }\n\t        this._map = Map(values);\n\t      };\n\t\n\t      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n\t      RecordTypePrototype.constructor = RecordType;\n\t\n\t      return RecordType;\n\t    }\n\t\n\t    Record.prototype.toString = function() {\n\t      return this.__toString(recordName(this) + ' {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Record.prototype.has = function(k) {\n\t      return this._defaultValues.hasOwnProperty(k);\n\t    };\n\t\n\t    Record.prototype.get = function(k, notSetValue) {\n\t      if (!this.has(k)) {\n\t        return notSetValue;\n\t      }\n\t      var defaultVal = this._defaultValues[k];\n\t      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Record.prototype.clear = function() {\n\t      if (this.__ownerID) {\n\t        this._map && this._map.clear();\n\t        return this;\n\t      }\n\t      var RecordType = this.constructor;\n\t      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n\t    };\n\t\n\t    Record.prototype.set = function(k, v) {\n\t      if (!this.has(k)) {\n\t        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n\t      }\n\t      if (this._map && !this._map.has(k)) {\n\t        var defaultVal = this._defaultValues[k];\n\t        if (v === defaultVal) {\n\t          return this;\n\t        }\n\t      }\n\t      var newMap = this._map && this._map.set(k, v);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.remove = function(k) {\n\t      if (!this.has(k)) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.remove(k);\n\t      if (this.__ownerID || newMap === this._map) {\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap);\n\t    };\n\t\n\t    Record.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n\t    };\n\t\n\t    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n\t    };\n\t\n\t    Record.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map && this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return makeRecord(this, newMap, ownerID);\n\t    };\n\t\n\t\n\t  var RecordPrototype = Record.prototype;\n\t  RecordPrototype[DELETE] = RecordPrototype.remove;\n\t  RecordPrototype.deleteIn =\n\t  RecordPrototype.removeIn = MapPrototype.removeIn;\n\t  RecordPrototype.merge = MapPrototype.merge;\n\t  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n\t  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n\t  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n\t  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n\t  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n\t  RecordPrototype.setIn = MapPrototype.setIn;\n\t  RecordPrototype.update = MapPrototype.update;\n\t  RecordPrototype.updateIn = MapPrototype.updateIn;\n\t  RecordPrototype.withMutations = MapPrototype.withMutations;\n\t  RecordPrototype.asMutable = MapPrototype.asMutable;\n\t  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t\n\t  function makeRecord(likeRecord, map, ownerID) {\n\t    var record = Object.create(Object.getPrototypeOf(likeRecord));\n\t    record._map = map;\n\t    record.__ownerID = ownerID;\n\t    return record;\n\t  }\n\t\n\t  function recordName(record) {\n\t    return record._name || record.constructor.name || 'Record';\n\t  }\n\t\n\t  function setProps(prototype, names) {\n\t    try {\n\t      names.forEach(setProp.bind(undefined, prototype));\n\t    } catch (error) {\n\t      // Object.defineProperty failed. Probably IE8.\n\t    }\n\t  }\n\t\n\t  function setProp(prototype, name) {\n\t    Object.defineProperty(prototype, name, {\n\t      get: function() {\n\t        return this.get(name);\n\t      },\n\t      set: function(value) {\n\t        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n\t        this.set(name, value);\n\t      }\n\t    });\n\t  }\n\t\n\t  createClass(Set, SetCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Set(value) {\n\t      return value === null || value === undefined ? emptySet() :\n\t        isSet(value) && !isOrdered(value) ? value :\n\t        emptySet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    Set.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Set.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    Set.prototype.toString = function() {\n\t      return this.__toString('Set {', '}');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Set.prototype.has = function(value) {\n\t      return this._map.has(value);\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Set.prototype.add = function(value) {\n\t      return updateSet(this, this._map.set(value, true));\n\t    };\n\t\n\t    Set.prototype.remove = function(value) {\n\t      return updateSet(this, this._map.remove(value));\n\t    };\n\t\n\t    Set.prototype.clear = function() {\n\t      return updateSet(this, this._map.clear());\n\t    };\n\t\n\t    // @pragma Composition\n\t\n\t    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n\t      iters = iters.filter(function(x ) {return x.size !== 0});\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n\t        return this.constructor(iters[0]);\n\t      }\n\t      return this.withMutations(function(set ) {\n\t        for (var ii = 0; ii < iters.length; ii++) {\n\t          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n\t        }\n\t      });\n\t    };\n\t\n\t    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n\t      if (iters.length === 0) {\n\t        return this;\n\t      }\n\t      iters = iters.map(function(iter ) {return SetIterable(iter)});\n\t      var originalSet = this;\n\t      return this.withMutations(function(set ) {\n\t        originalSet.forEach(function(value ) {\n\t          if (iters.some(function(iter ) {return iter.includes(value)})) {\n\t            set.remove(value);\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    Set.prototype.merge = function() {\n\t      return this.union.apply(this, arguments);\n\t    };\n\t\n\t    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n\t      return this.union.apply(this, iters);\n\t    };\n\t\n\t    Set.prototype.sort = function(comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator));\n\t    };\n\t\n\t    Set.prototype.sortBy = function(mapper, comparator) {\n\t      // Late binding\n\t      return OrderedSet(sortFactory(this, comparator, mapper));\n\t    };\n\t\n\t    Set.prototype.wasAltered = function() {\n\t      return this._map.wasAltered();\n\t    };\n\t\n\t    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n\t      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n\t    };\n\t\n\t    Set.prototype.__iterator = function(type, reverse) {\n\t      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n\t    };\n\t\n\t    Set.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      var newMap = this._map.__ensureOwner(ownerID);\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this._map = newMap;\n\t        return this;\n\t      }\n\t      return this.__make(newMap, ownerID);\n\t    };\n\t\n\t\n\t  function isSet(maybeSet) {\n\t    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n\t  }\n\t\n\t  Set.isSet = isSet;\n\t\n\t  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\t\n\t  var SetPrototype = Set.prototype;\n\t  SetPrototype[IS_SET_SENTINEL] = true;\n\t  SetPrototype[DELETE] = SetPrototype.remove;\n\t  SetPrototype.mergeDeep = SetPrototype.merge;\n\t  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n\t  SetPrototype.withMutations = MapPrototype.withMutations;\n\t  SetPrototype.asMutable = MapPrototype.asMutable;\n\t  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\t\n\t  SetPrototype.__empty = emptySet;\n\t  SetPrototype.__make = makeSet;\n\t\n\t  function updateSet(set, newMap) {\n\t    if (set.__ownerID) {\n\t      set.size = newMap.size;\n\t      set._map = newMap;\n\t      return set;\n\t    }\n\t    return newMap === set._map ? set :\n\t      newMap.size === 0 ? set.__empty() :\n\t      set.__make(newMap);\n\t  }\n\t\n\t  function makeSet(map, ownerID) {\n\t    var set = Object.create(SetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_SET;\n\t  function emptySet() {\n\t    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n\t  }\n\t\n\t  createClass(OrderedSet, Set);\n\t\n\t    // @pragma Construction\n\t\n\t    function OrderedSet(value) {\n\t      return value === null || value === undefined ? emptyOrderedSet() :\n\t        isOrderedSet(value) ? value :\n\t        emptyOrderedSet().withMutations(function(set ) {\n\t          var iter = SetIterable(value);\n\t          assertNotInfinite(iter.size);\n\t          iter.forEach(function(v ) {return set.add(v)});\n\t        });\n\t    }\n\t\n\t    OrderedSet.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    OrderedSet.fromKeys = function(value) {\n\t      return this(KeyedIterable(value).keySeq());\n\t    };\n\t\n\t    OrderedSet.prototype.toString = function() {\n\t      return this.__toString('OrderedSet {', '}');\n\t    };\n\t\n\t\n\t  function isOrderedSet(maybeOrderedSet) {\n\t    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n\t  }\n\t\n\t  OrderedSet.isOrderedSet = isOrderedSet;\n\t\n\t  var OrderedSetPrototype = OrderedSet.prototype;\n\t  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t  OrderedSetPrototype.__empty = emptyOrderedSet;\n\t  OrderedSetPrototype.__make = makeOrderedSet;\n\t\n\t  function makeOrderedSet(map, ownerID) {\n\t    var set = Object.create(OrderedSetPrototype);\n\t    set.size = map ? map.size : 0;\n\t    set._map = map;\n\t    set.__ownerID = ownerID;\n\t    return set;\n\t  }\n\t\n\t  var EMPTY_ORDERED_SET;\n\t  function emptyOrderedSet() {\n\t    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n\t  }\n\t\n\t  createClass(Stack, IndexedCollection);\n\t\n\t    // @pragma Construction\n\t\n\t    function Stack(value) {\n\t      return value === null || value === undefined ? emptyStack() :\n\t        isStack(value) ? value :\n\t        emptyStack().unshiftAll(value);\n\t    }\n\t\n\t    Stack.of = function(/*...values*/) {\n\t      return this(arguments);\n\t    };\n\t\n\t    Stack.prototype.toString = function() {\n\t      return this.__toString('Stack [', ']');\n\t    };\n\t\n\t    // @pragma Access\n\t\n\t    Stack.prototype.get = function(index, notSetValue) {\n\t      var head = this._head;\n\t      index = wrapIndex(this, index);\n\t      while (head && index--) {\n\t        head = head.next;\n\t      }\n\t      return head ? head.value : notSetValue;\n\t    };\n\t\n\t    Stack.prototype.peek = function() {\n\t      return this._head && this._head.value;\n\t    };\n\t\n\t    // @pragma Modification\n\t\n\t    Stack.prototype.push = function(/*...values*/) {\n\t      if (arguments.length === 0) {\n\t        return this;\n\t      }\n\t      var newSize = this.size + arguments.length;\n\t      var head = this._head;\n\t      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n\t        head = {\n\t          value: arguments[ii],\n\t          next: head\n\t        };\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pushAll = function(iter) {\n\t      iter = IndexedIterable(iter);\n\t      if (iter.size === 0) {\n\t        return this;\n\t      }\n\t      assertNotInfinite(iter.size);\n\t      var newSize = this.size;\n\t      var head = this._head;\n\t      iter.reverse().forEach(function(value ) {\n\t        newSize++;\n\t        head = {\n\t          value: value,\n\t          next: head\n\t        };\n\t      });\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    Stack.prototype.pop = function() {\n\t      return this.slice(1);\n\t    };\n\t\n\t    Stack.prototype.unshift = function(/*...values*/) {\n\t      return this.push.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.unshiftAll = function(iter) {\n\t      return this.pushAll(iter);\n\t    };\n\t\n\t    Stack.prototype.shift = function() {\n\t      return this.pop.apply(this, arguments);\n\t    };\n\t\n\t    Stack.prototype.clear = function() {\n\t      if (this.size === 0) {\n\t        return this;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = 0;\n\t        this._head = undefined;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return emptyStack();\n\t    };\n\t\n\t    Stack.prototype.slice = function(begin, end) {\n\t      if (wholeSlice(begin, end, this.size)) {\n\t        return this;\n\t      }\n\t      var resolvedBegin = resolveBegin(begin, this.size);\n\t      var resolvedEnd = resolveEnd(end, this.size);\n\t      if (resolvedEnd !== this.size) {\n\t        // super.slice(begin, end);\n\t        return IndexedCollection.prototype.slice.call(this, begin, end);\n\t      }\n\t      var newSize = this.size - resolvedBegin;\n\t      var head = this._head;\n\t      while (resolvedBegin--) {\n\t        head = head.next;\n\t      }\n\t      if (this.__ownerID) {\n\t        this.size = newSize;\n\t        this._head = head;\n\t        this.__hash = undefined;\n\t        this.__altered = true;\n\t        return this;\n\t      }\n\t      return makeStack(newSize, head);\n\t    };\n\t\n\t    // @pragma Mutability\n\t\n\t    Stack.prototype.__ensureOwner = function(ownerID) {\n\t      if (ownerID === this.__ownerID) {\n\t        return this;\n\t      }\n\t      if (!ownerID) {\n\t        this.__ownerID = ownerID;\n\t        this.__altered = false;\n\t        return this;\n\t      }\n\t      return makeStack(this.size, this._head, ownerID, this.__hash);\n\t    };\n\t\n\t    // @pragma Iteration\n\t\n\t    Stack.prototype.__iterate = function(fn, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterate(fn);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      while (node) {\n\t        if (fn(node.value, iterations++, this) === false) {\n\t          break;\n\t        }\n\t        node = node.next;\n\t      }\n\t      return iterations;\n\t    };\n\t\n\t    Stack.prototype.__iterator = function(type, reverse) {\n\t      if (reverse) {\n\t        return this.reverse().__iterator(type);\n\t      }\n\t      var iterations = 0;\n\t      var node = this._head;\n\t      return new Iterator(function()  {\n\t        if (node) {\n\t          var value = node.value;\n\t          node = node.next;\n\t          return iteratorValue(type, iterations++, value);\n\t        }\n\t        return iteratorDone();\n\t      });\n\t    };\n\t\n\t\n\t  function isStack(maybeStack) {\n\t    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n\t  }\n\t\n\t  Stack.isStack = isStack;\n\t\n\t  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\t\n\t  var StackPrototype = Stack.prototype;\n\t  StackPrototype[IS_STACK_SENTINEL] = true;\n\t  StackPrototype.withMutations = MapPrototype.withMutations;\n\t  StackPrototype.asMutable = MapPrototype.asMutable;\n\t  StackPrototype.asImmutable = MapPrototype.asImmutable;\n\t  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\t\n\t\n\t  function makeStack(size, head, ownerID, hash) {\n\t    var map = Object.create(StackPrototype);\n\t    map.size = size;\n\t    map._head = head;\n\t    map.__ownerID = ownerID;\n\t    map.__hash = hash;\n\t    map.__altered = false;\n\t    return map;\n\t  }\n\t\n\t  var EMPTY_STACK;\n\t  function emptyStack() {\n\t    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n\t  }\n\t\n\t  /**\n\t   * Contributes additional methods to a constructor\n\t   */\n\t  function mixin(ctor, methods) {\n\t    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n\t    Object.keys(methods).forEach(keyCopier);\n\t    Object.getOwnPropertySymbols &&\n\t      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n\t    return ctor;\n\t  }\n\t\n\t  Iterable.Iterator = Iterator;\n\t\n\t  mixin(Iterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toArray: function() {\n\t      assertNotInfinite(this.size);\n\t      var array = new Array(this.size || 0);\n\t      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n\t      return array;\n\t    },\n\t\n\t    toIndexedSeq: function() {\n\t      return new ToIndexedSequence(this);\n\t    },\n\t\n\t    toJS: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toJSON: function() {\n\t      return this.toSeq().map(\n\t        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n\t      ).__toJS();\n\t    },\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, true);\n\t    },\n\t\n\t    toMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Map(this.toKeyedSeq());\n\t    },\n\t\n\t    toObject: function() {\n\t      assertNotInfinite(this.size);\n\t      var object = {};\n\t      this.__iterate(function(v, k)  { object[k] = v; });\n\t      return object;\n\t    },\n\t\n\t    toOrderedMap: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedMap(this.toKeyedSeq());\n\t    },\n\t\n\t    toOrderedSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSet: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Set(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toSetSeq: function() {\n\t      return new ToSetSequence(this);\n\t    },\n\t\n\t    toSeq: function() {\n\t      return isIndexed(this) ? this.toIndexedSeq() :\n\t        isKeyed(this) ? this.toKeyedSeq() :\n\t        this.toSetSeq();\n\t    },\n\t\n\t    toStack: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return Stack(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t    toList: function() {\n\t      // Use Late Binding here to solve the circular dependency.\n\t      return List(isKeyed(this) ? this.valueSeq() : this);\n\t    },\n\t\n\t\n\t    // ### Common JavaScript methods and properties\n\t\n\t    toString: function() {\n\t      return '[Iterable]';\n\t    },\n\t\n\t    __toString: function(head, tail) {\n\t      if (this.size === 0) {\n\t        return head + tail;\n\t      }\n\t      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    concat: function() {var values = SLICE$0.call(arguments, 0);\n\t      return reify(this, concatFactory(this, values));\n\t    },\n\t\n\t    includes: function(searchValue) {\n\t      return this.some(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    entries: function() {\n\t      return this.__iterator(ITERATE_ENTRIES);\n\t    },\n\t\n\t    every: function(predicate, context) {\n\t      assertNotInfinite(this.size);\n\t      var returnValue = true;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (!predicate.call(context, v, k, c)) {\n\t          returnValue = false;\n\t          return false;\n\t        }\n\t      });\n\t      return returnValue;\n\t    },\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, true));\n\t    },\n\t\n\t    find: function(predicate, context, notSetValue) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[1] : notSetValue;\n\t    },\n\t\n\t    forEach: function(sideEffect, context) {\n\t      assertNotInfinite(this.size);\n\t      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n\t    },\n\t\n\t    join: function(separator) {\n\t      assertNotInfinite(this.size);\n\t      separator = separator !== undefined ? '' + separator : ',';\n\t      var joined = '';\n\t      var isFirst = true;\n\t      this.__iterate(function(v ) {\n\t        isFirst ? (isFirst = false) : (joined += separator);\n\t        joined += v !== null && v !== undefined ? v.toString() : '';\n\t      });\n\t      return joined;\n\t    },\n\t\n\t    keys: function() {\n\t      return this.__iterator(ITERATE_KEYS);\n\t    },\n\t\n\t    map: function(mapper, context) {\n\t      return reify(this, mapFactory(this, mapper, context));\n\t    },\n\t\n\t    reduce: function(reducer, initialReduction, context) {\n\t      assertNotInfinite(this.size);\n\t      var reduction;\n\t      var useFirst;\n\t      if (arguments.length < 2) {\n\t        useFirst = true;\n\t      } else {\n\t        reduction = initialReduction;\n\t      }\n\t      this.__iterate(function(v, k, c)  {\n\t        if (useFirst) {\n\t          useFirst = false;\n\t          reduction = v;\n\t        } else {\n\t          reduction = reducer.call(context, reduction, v, k, c);\n\t        }\n\t      });\n\t      return reduction;\n\t    },\n\t\n\t    reduceRight: function(reducer, initialReduction, context) {\n\t      var reversed = this.toKeyedSeq().reverse();\n\t      return reversed.reduce.apply(reversed, arguments);\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, true));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, true));\n\t    },\n\t\n\t    some: function(predicate, context) {\n\t      return !this.every(not(predicate), context);\n\t    },\n\t\n\t    sort: function(comparator) {\n\t      return reify(this, sortFactory(this, comparator));\n\t    },\n\t\n\t    values: function() {\n\t      return this.__iterator(ITERATE_VALUES);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    butLast: function() {\n\t      return this.slice(0, -1);\n\t    },\n\t\n\t    isEmpty: function() {\n\t      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n\t    },\n\t\n\t    count: function(predicate, context) {\n\t      return ensureSize(\n\t        predicate ? this.toSeq().filter(predicate, context) : this\n\t      );\n\t    },\n\t\n\t    countBy: function(grouper, context) {\n\t      return countByFactory(this, grouper, context);\n\t    },\n\t\n\t    equals: function(other) {\n\t      return deepEqual(this, other);\n\t    },\n\t\n\t    entrySeq: function() {\n\t      var iterable = this;\n\t      if (iterable._cache) {\n\t        // We cache as an entries array, so we can just return the cache!\n\t        return new ArraySeq(iterable._cache);\n\t      }\n\t      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n\t      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n\t      return entriesSequence;\n\t    },\n\t\n\t    filterNot: function(predicate, context) {\n\t      return this.filter(not(predicate), context);\n\t    },\n\t\n\t    findEntry: function(predicate, context, notSetValue) {\n\t      var found = notSetValue;\n\t      this.__iterate(function(v, k, c)  {\n\t        if (predicate.call(context, v, k, c)) {\n\t          found = [k, v];\n\t          return false;\n\t        }\n\t      });\n\t      return found;\n\t    },\n\t\n\t    findKey: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry && entry[0];\n\t    },\n\t\n\t    findLast: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastEntry: function(predicate, context, notSetValue) {\n\t      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n\t    },\n\t\n\t    findLastKey: function(predicate, context) {\n\t      return this.toKeyedSeq().reverse().findKey(predicate, context);\n\t    },\n\t\n\t    first: function() {\n\t      return this.find(returnTrue);\n\t    },\n\t\n\t    flatMap: function(mapper, context) {\n\t      return reify(this, flatMapFactory(this, mapper, context));\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, true));\n\t    },\n\t\n\t    fromEntrySeq: function() {\n\t      return new FromEntriesSequence(this);\n\t    },\n\t\n\t    get: function(searchKey, notSetValue) {\n\t      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n\t    },\n\t\n\t    getIn: function(searchKeyPath, notSetValue) {\n\t      var nested = this;\n\t      // Note: in an ES6 environment, we would prefer:\n\t      // for (var key of searchKeyPath) {\n\t      var iter = forceIterator(searchKeyPath);\n\t      var step;\n\t      while (!(step = iter.next()).done) {\n\t        var key = step.value;\n\t        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n\t        if (nested === NOT_SET) {\n\t          return notSetValue;\n\t        }\n\t      }\n\t      return nested;\n\t    },\n\t\n\t    groupBy: function(grouper, context) {\n\t      return groupByFactory(this, grouper, context);\n\t    },\n\t\n\t    has: function(searchKey) {\n\t      return this.get(searchKey, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    hasIn: function(searchKeyPath) {\n\t      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n\t    },\n\t\n\t    isSubset: function(iter) {\n\t      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n\t      return this.every(function(value ) {return iter.includes(value)});\n\t    },\n\t\n\t    isSuperset: function(iter) {\n\t      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n\t      return iter.isSubset(this);\n\t    },\n\t\n\t    keyOf: function(searchValue) {\n\t      return this.findKey(function(value ) {return is(value, searchValue)});\n\t    },\n\t\n\t    keySeq: function() {\n\t      return this.toSeq().map(keyMapper).toIndexedSeq();\n\t    },\n\t\n\t    last: function() {\n\t      return this.toSeq().reverse().first();\n\t    },\n\t\n\t    lastKeyOf: function(searchValue) {\n\t      return this.toKeyedSeq().reverse().keyOf(searchValue);\n\t    },\n\t\n\t    max: function(comparator) {\n\t      return maxFactory(this, comparator);\n\t    },\n\t\n\t    maxBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator, mapper);\n\t    },\n\t\n\t    min: function(comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n\t    },\n\t\n\t    minBy: function(mapper, comparator) {\n\t      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n\t    },\n\t\n\t    rest: function() {\n\t      return this.slice(1);\n\t    },\n\t\n\t    skip: function(amount) {\n\t      return this.slice(Math.max(0, amount));\n\t    },\n\t\n\t    skipLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, true));\n\t    },\n\t\n\t    skipUntil: function(predicate, context) {\n\t      return this.skipWhile(not(predicate), context);\n\t    },\n\t\n\t    sortBy: function(mapper, comparator) {\n\t      return reify(this, sortFactory(this, comparator, mapper));\n\t    },\n\t\n\t    take: function(amount) {\n\t      return this.slice(0, Math.max(0, amount));\n\t    },\n\t\n\t    takeLast: function(amount) {\n\t      return reify(this, this.toSeq().reverse().take(amount).reverse());\n\t    },\n\t\n\t    takeWhile: function(predicate, context) {\n\t      return reify(this, takeWhileFactory(this, predicate, context));\n\t    },\n\t\n\t    takeUntil: function(predicate, context) {\n\t      return this.takeWhile(not(predicate), context);\n\t    },\n\t\n\t    valueSeq: function() {\n\t      return this.toIndexedSeq();\n\t    },\n\t\n\t\n\t    // ### Hashable Object\n\t\n\t    hashCode: function() {\n\t      return this.__hash || (this.__hash = hashIterable(this));\n\t    }\n\t\n\t\n\t    // ### Internal\n\t\n\t    // abstract __iterate(fn, reverse)\n\t\n\t    // abstract __iterator(type, reverse)\n\t  });\n\t\n\t  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n\t  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n\t  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n\t  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\t\n\t  var IterablePrototype = Iterable.prototype;\n\t  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n\t  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n\t  IterablePrototype.__toJS = IterablePrototype.toArray;\n\t  IterablePrototype.__toStringMapper = quoteString;\n\t  IterablePrototype.inspect =\n\t  IterablePrototype.toSource = function() { return this.toString(); };\n\t  IterablePrototype.chain = IterablePrototype.flatMap;\n\t  IterablePrototype.contains = IterablePrototype.includes;\n\t\n\t  mixin(KeyedIterable, {\n\t\n\t    // ### More sequential methods\n\t\n\t    flip: function() {\n\t      return reify(this, flipFactory(this));\n\t    },\n\t\n\t    mapEntries: function(mapper, context) {var this$0 = this;\n\t      var iterations = 0;\n\t      return reify(this,\n\t        this.toSeq().map(\n\t          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n\t        ).fromEntrySeq()\n\t      );\n\t    },\n\t\n\t    mapKeys: function(mapper, context) {var this$0 = this;\n\t      return reify(this,\n\t        this.toSeq().flip().map(\n\t          function(k, v)  {return mapper.call(context, k, v, this$0)}\n\t        ).flip()\n\t      );\n\t    }\n\t\n\t  });\n\t\n\t  var KeyedIterablePrototype = KeyedIterable.prototype;\n\t  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n\t  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n\t  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n\t  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\t\n\t\n\t\n\t  mixin(IndexedIterable, {\n\t\n\t    // ### Conversion to other types\n\t\n\t    toKeyedSeq: function() {\n\t      return new ToKeyedSequence(this, false);\n\t    },\n\t\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    filter: function(predicate, context) {\n\t      return reify(this, filterFactory(this, predicate, context, false));\n\t    },\n\t\n\t    findIndex: function(predicate, context) {\n\t      var entry = this.findEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    indexOf: function(searchValue) {\n\t      var key = this.keyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    lastIndexOf: function(searchValue) {\n\t      var key = this.lastKeyOf(searchValue);\n\t      return key === undefined ? -1 : key;\n\t    },\n\t\n\t    reverse: function() {\n\t      return reify(this, reverseFactory(this, false));\n\t    },\n\t\n\t    slice: function(begin, end) {\n\t      return reify(this, sliceFactory(this, begin, end, false));\n\t    },\n\t\n\t    splice: function(index, removeNum /*, ...values*/) {\n\t      var numArgs = arguments.length;\n\t      removeNum = Math.max(removeNum | 0, 0);\n\t      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n\t        return this;\n\t      }\n\t      // If index is negative, it should resolve relative to the size of the\n\t      // collection. However size may be expensive to compute if not cached, so\n\t      // only call count() if the number is in fact negative.\n\t      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n\t      var spliced = this.slice(0, index);\n\t      return reify(\n\t        this,\n\t        numArgs === 1 ?\n\t          spliced :\n\t          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n\t      );\n\t    },\n\t\n\t\n\t    // ### More collection methods\n\t\n\t    findLastIndex: function(predicate, context) {\n\t      var entry = this.findLastEntry(predicate, context);\n\t      return entry ? entry[0] : -1;\n\t    },\n\t\n\t    first: function() {\n\t      return this.get(0);\n\t    },\n\t\n\t    flatten: function(depth) {\n\t      return reify(this, flattenFactory(this, depth, false));\n\t    },\n\t\n\t    get: function(index, notSetValue) {\n\t      index = wrapIndex(this, index);\n\t      return (index < 0 || (this.size === Infinity ||\n\t          (this.size !== undefined && index > this.size))) ?\n\t        notSetValue :\n\t        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n\t    },\n\t\n\t    has: function(index) {\n\t      index = wrapIndex(this, index);\n\t      return index >= 0 && (this.size !== undefined ?\n\t        this.size === Infinity || index < this.size :\n\t        this.indexOf(index) !== -1\n\t      );\n\t    },\n\t\n\t    interpose: function(separator) {\n\t      return reify(this, interposeFactory(this, separator));\n\t    },\n\t\n\t    interleave: function(/*...iterables*/) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n\t      var interleaved = zipped.flatten(true);\n\t      if (zipped.size) {\n\t        interleaved.size = zipped.size * iterables.length;\n\t      }\n\t      return reify(this, interleaved);\n\t    },\n\t\n\t    keySeq: function() {\n\t      return Range(0, this.size);\n\t    },\n\t\n\t    last: function() {\n\t      return this.get(-1);\n\t    },\n\t\n\t    skipWhile: function(predicate, context) {\n\t      return reify(this, skipWhileFactory(this, predicate, context, false));\n\t    },\n\t\n\t    zip: function(/*, ...iterables */) {\n\t      var iterables = [this].concat(arrCopy(arguments));\n\t      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n\t    },\n\t\n\t    zipWith: function(zipper/*, ...iterables */) {\n\t      var iterables = arrCopy(arguments);\n\t      iterables[0] = this;\n\t      return reify(this, zipWithFactory(this, zipper, iterables));\n\t    }\n\t\n\t  });\n\t\n\t  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n\t  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\t\n\t\n\t\n\t  mixin(SetIterable, {\n\t\n\t    // ### ES6 Collection methods (ES6 Array and Map)\n\t\n\t    get: function(value, notSetValue) {\n\t      return this.has(value) ? value : notSetValue;\n\t    },\n\t\n\t    includes: function(value) {\n\t      return this.has(value);\n\t    },\n\t\n\t\n\t    // ### More sequential methods\n\t\n\t    keySeq: function() {\n\t      return this.valueSeq();\n\t    }\n\t\n\t  });\n\t\n\t  SetIterable.prototype.has = IterablePrototype.includes;\n\t  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\t\n\t\n\t  // Mixin subclasses\n\t\n\t  mixin(KeyedSeq, KeyedIterable.prototype);\n\t  mixin(IndexedSeq, IndexedIterable.prototype);\n\t  mixin(SetSeq, SetIterable.prototype);\n\t\n\t  mixin(KeyedCollection, KeyedIterable.prototype);\n\t  mixin(IndexedCollection, IndexedIterable.prototype);\n\t  mixin(SetCollection, SetIterable.prototype);\n\t\n\t\n\t  // #pragma Helper functions\n\t\n\t  function keyMapper(v, k) {\n\t    return k;\n\t  }\n\t\n\t  function entryMapper(v, k) {\n\t    return [k, v];\n\t  }\n\t\n\t  function not(predicate) {\n\t    return function() {\n\t      return !predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function neg(predicate) {\n\t    return function() {\n\t      return -predicate.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  function quoteString(value) {\n\t    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n\t  }\n\t\n\t  function defaultZipper() {\n\t    return arrCopy(arguments);\n\t  }\n\t\n\t  function defaultNegComparator(a, b) {\n\t    return a < b ? 1 : a > b ? -1 : 0;\n\t  }\n\t\n\t  function hashIterable(iterable) {\n\t    if (iterable.size === Infinity) {\n\t      return 0;\n\t    }\n\t    var ordered = isOrdered(iterable);\n\t    var keyed = isKeyed(iterable);\n\t    var h = ordered ? 1 : 0;\n\t    var size = iterable.__iterate(\n\t      keyed ?\n\t        ordered ?\n\t          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n\t          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n\t        ordered ?\n\t          function(v ) { h = 31 * h + hash(v) | 0; } :\n\t          function(v ) { h = h + hash(v) | 0; }\n\t    );\n\t    return murmurHashOfSize(size, h);\n\t  }\n\t\n\t  function murmurHashOfSize(size, h) {\n\t    h = imul(h, 0xCC9E2D51);\n\t    h = imul(h << 15 | h >>> -15, 0x1B873593);\n\t    h = imul(h << 13 | h >>> -13, 5);\n\t    h = (h + 0xE6546B64 | 0) ^ size;\n\t    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n\t    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n\t    h = smi(h ^ h >>> 16);\n\t    return h;\n\t  }\n\t\n\t  function hashMerge(a, b) {\n\t    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n\t  }\n\t\n\t  var Immutable = {\n\t\n\t    Iterable: Iterable,\n\t\n\t    Seq: Seq,\n\t    Collection: Collection,\n\t    Map: Map,\n\t    OrderedMap: OrderedMap,\n\t    List: List,\n\t    Stack: Stack,\n\t    Set: Set,\n\t    OrderedSet: OrderedSet,\n\t\n\t    Record: Record,\n\t    Range: Range,\n\t    Repeat: Repeat,\n\t\n\t    is: is,\n\t    fromJS: fromJS\n\t\n\t  };\n\t\n\t  return Immutable;\n\t\n\t}));\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    /**\n\t     * A simple factory that creates an event object which can be cancelled\n\t     *\n\t     * @param options The options for the event\n\t     */\n\t    function createCancelableEvent(options) {\n\t        var type = options.type, target = options.target;\n\t        var event = Object.defineProperties({}, {\n\t            type: { value: type, enumerable: true },\n\t            target: { value: target, enumerable: true },\n\t            cancelable: { value: true, enumerable: true },\n\t            defaultPrevented: { value: false, enumerable: true, configurable: true },\n\t            preventDefault: { value: function () {\n\t                    Object.defineProperty(event, 'defaultPrevented', { value: true, enumerable: true });\n\t                }, enumerable: true }\n\t        });\n\t        return event;\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createCancelableEvent;\n\t});\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(25), __webpack_require__(22), __webpack_require__(18), __webpack_require__(37)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var lang_1 = __webpack_require__(25);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var createEvented_1 = __webpack_require__(18);\n\t    var createCancelableEvent_1 = __webpack_require__(37);\n\t    /**\n\t     * A weak map of stateful instances to their obseved state references\n\t     */\n\t    var observedStateMap = new WeakMap_1.default();\n\t    /**\n\t     * Internal function to unobserve the state of a `Stateful`.  It emits a `statecomplete` event which can be\n\t     * cancelled.\n\t     *\n\t     * @param stateful The `Stateful` object to unobserve\n\t     */\n\t    function unobserve(stateful) {\n\t        var observedState = observedStateMap.get(stateful);\n\t        if (observedState) {\n\t            observedState.handle.destroy();\n\t            var statecomplete = createCancelableEvent_1.default({\n\t                type: 'statecomplete',\n\t                target: stateful\n\t            });\n\t            stateful.emit(statecomplete);\n\t            if (!statecomplete.defaultPrevented) {\n\t                stateful.destroy();\n\t            }\n\t        }\n\t    }\n\t    /**\n\t     * Internal function that actually applies the state to the Stateful's state and\n\t     * emits the `statechange` event.\n\t     *\n\t     * @param stateful The Stateful instance\n\t     * @param state The State to be set\n\t     */\n\t    function setStatefulState(stateful, state) {\n\t        state = lang_1.deepAssign(stateWeakMap.get(stateful), state);\n\t        stateful.emit({\n\t            type: 'statechange',\n\t            state: state,\n\t            target: stateful\n\t        });\n\t    }\n\t    /**\n\t     * A weak map that contains the stateful's state\n\t     */\n\t    var stateWeakMap = new WeakMap_1.default();\n\t    /**\n\t     * Create an instance of a stateful object\n\t     */\n\t    var createStateful = createEvented_1.default\n\t        .mixin({\n\t        className: 'Stateful',\n\t        mixin: {\n\t            get state() {\n\t                return stateWeakMap.get(this);\n\t            },\n\t            setState: function (value) {\n\t                var observedState = observedStateMap.get(this);\n\t                if (observedState) {\n\t                    observedState.observable.patch(value, { id: observedState.id });\n\t                }\n\t                else {\n\t                    setStatefulState(this, value);\n\t                }\n\t            },\n\t            observeState: function (id, observable) {\n\t                var observedState = observedStateMap.get(this);\n\t                if (observedState) {\n\t                    if (observedState.id === id && observedState.observable === observable) {\n\t                        return observedState.handle;\n\t                    }\n\t                    throw new Error(\"Already observing state with ID '\" + observedState.id + \"'\");\n\t                }\n\t                var stateful = this;\n\t                observedState = {\n\t                    id: id,\n\t                    observable: observable,\n\t                    subscription: observable\n\t                        .observe(id)\n\t                        .subscribe(function (item) { return setStatefulState(stateful, item); }, /* next handler */ function (err) {\n\t                        /* TODO: Should we emit an error, instead of throwing? */\n\t                        throw err;\n\t                    }, /* error handler */ function () { return unobserve(stateful); }),\n\t                    handle: {\n\t                        destroy: function () {\n\t                            var observedState = observedStateMap.get(stateful);\n\t                            if (observedState) {\n\t                                observedState.subscription.unsubscribe();\n\t                                observedStateMap.delete(stateful);\n\t                            }\n\t                        }\n\t                    }\n\t                };\n\t                observedStateMap.set(stateful, observedState);\n\t                return observedState.handle;\n\t            }\n\t        },\n\t        initialize: function (instance, options) {\n\t            /* Using Object.create(null) will improve performance when looking up properties in state */\n\t            stateWeakMap.set(instance, Object.create(null));\n\t            instance.own({\n\t                destroy: function () {\n\t                    stateWeakMap.delete(instance);\n\t                }\n\t            });\n\t            if (options) {\n\t                var id = options.id, stateFrom = options.stateFrom, state = options.state;\n\t                if (typeof id !== 'undefined' && stateFrom) {\n\t                    instance.own(instance.observeState(id, stateFrom));\n\t                }\n\t                else if (stateFrom) {\n\t                    throw new TypeError('When \"stateFrom\" option is supplied, factory also requires \"id\" option.');\n\t                }\n\t                if (state) {\n\t                    instance.setState(state);\n\t                }\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createStateful;\n\t});\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(38), __webpack_require__(25), __webpack_require__(31), __webpack_require__(22), __webpack_require__(40)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createStateful_1 = __webpack_require__(38);\n\t    var lang_1 = __webpack_require__(25);\n\t    var Map_1 = __webpack_require__(31);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var maquette_1 = __webpack_require__(40);\n\t    /**\n\t     * A map of dirty flags used when determining if the render function\n\t     * should be called\n\t     */\n\t    var dirtyMap = new Map_1.default();\n\t    /**\n\t     * A weak map of the rendered VNode to return when the widget is\n\t     * not dirty.\n\t     */\n\t    var renderCache = new WeakMap_1.default();\n\t    /**\n\t     * The counter for generating a unique ID\n\t     */\n\t    var cachedRenderCount = 0;\n\t    /**\n\t     * A function that generates an ID\n\t     */\n\t    function generateID(cachedRender) {\n\t        var id = \"\" + createRenderMixin.idBase + ++cachedRenderCount;\n\t        cachedRender.setState({ id: id });\n\t        return id;\n\t    }\n\t    /**\n\t     * A weak map of the historic classes associated to a specific widget\n\t     */\n\t    var widgetClassesMap = new WeakMap_1.default();\n\t    var createRenderMixin = createStateful_1.default\n\t        .mixin({\n\t        mixin: {\n\t            getNodeAttributes: function (overrides) {\n\t                var _this = this;\n\t                var props = {};\n\t                this.nodeAttributes.forEach(function (fn) {\n\t                    var newProps = fn.call(_this, lang_1.assign({}, props));\n\t                    if (newProps) {\n\t                        lang_1.assign(props, newProps);\n\t                    }\n\t                });\n\t                if (overrides) {\n\t                    lang_1.assign(props, overrides);\n\t                }\n\t                return props;\n\t            },\n\t            getSelectorAndWidgetClasses: function () {\n\t                var selectorAndClasses = [this.tagName].concat(this.classes);\n\t                return selectorAndClasses.join('.');\n\t            },\n\t            getChildrenNodes: function () {\n\t                return this.state.label ? [this.state.label] : [];\n\t            },\n\t            get id() {\n\t                return (this.state && this.state.id) || generateID(this);\n\t            },\n\t            invalidate: function () {\n\t                if (dirtyMap.get(this)) {\n\t                    return;\n\t                }\n\t                var parent = this.parent;\n\t                dirtyMap.set(this, true);\n\t                renderCache.delete(this); /* Allow GC to occur on renderCache */\n\t                if (parent && parent.invalidate) {\n\t                    parent.invalidate();\n\t                }\n\t            },\n\t            nodeAttributes: [\n\t                function () {\n\t                    var baseIdProp = this.state && this.state.id ? { 'data-widget-id': this.state.id } : {};\n\t                    var _a = this.state.styles, styles = _a === void 0 ? {} : _a;\n\t                    var classes = {};\n\t                    var widgetClasses = widgetClassesMap.get(this);\n\t                    widgetClasses.forEach(function (c) { return classes[c] = false; });\n\t                    if (this.state && this.state.classes) {\n\t                        this.state.classes.forEach(function (c) { return classes[c] = true; });\n\t                        widgetClassesMap.set(this, this.state.classes);\n\t                    }\n\t                    return lang_1.assign(baseIdProp, { key: this, classes: classes, styles: styles });\n\t                }\n\t            ],\n\t            parent: null,\n\t            render: function () {\n\t                var cachedRender = this;\n\t                var cached = renderCache.get(cachedRender);\n\t                if (!dirtyMap.get(cachedRender) && cached) {\n\t                    return cached;\n\t                }\n\t                else {\n\t                    cached = maquette_1.h(cachedRender.getSelectorAndWidgetClasses(), cachedRender.getNodeAttributes(), cachedRender.getChildrenNodes());\n\t                    renderCache.set(cachedRender, cached);\n\t                    dirtyMap.set(cachedRender, false);\n\t                    return cached;\n\t                }\n\t            },\n\t            classes: [],\n\t            tagName: 'div'\n\t        },\n\t        initialize: function (instance, options) {\n\t            if (options === void 0) { options = {}; }\n\t            var tagName = options.tagName, render = options.render, parent = options.parent;\n\t            instance.tagName = tagName || instance.tagName;\n\t            instance.render = render || instance.render;\n\t            if (parent) {\n\t                parent.append(instance);\n\t            }\n\t            dirtyMap.set(instance, true);\n\t            instance.own(instance.on('statechange', function () { return instance.invalidate(); }));\n\t            widgetClassesMap.set(instance, []);\n\t        }\n\t    })\n\t        .static({\n\t        idBase: 'widget'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createRenderMixin;\n\t});\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n\t        // CommonJS\n\t        factory(exports);\n\t    } else {\n\t        // Browser globals\n\t        factory(root.maquette = {});\n\t    }\n\t}(this, function (exports) {\n\t    'use strict';\n\t    ;\n\t    ;\n\t    ;\n\t    ;\n\t    var NAMESPACE_W3 = 'http://www.w3.org/';\n\t    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n\t    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n\t    // Utilities\n\t    var emptyArray = [];\n\t    var extend = function (base, overrides) {\n\t        var result = {};\n\t        Object.keys(base).forEach(function (key) {\n\t            result[key] = base[key];\n\t        });\n\t        if (overrides) {\n\t            Object.keys(overrides).forEach(function (key) {\n\t                result[key] = overrides[key];\n\t            });\n\t        }\n\t        return result;\n\t    };\n\t    // Hyperscript helper functions\n\t    var same = function (vnode1, vnode2) {\n\t        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n\t            return false;\n\t        }\n\t        if (vnode1.properties && vnode2.properties) {\n\t            if (vnode1.properties.key !== vnode2.properties.key) {\n\t                return false;\n\t            }\n\t            return vnode1.properties.bind === vnode2.properties.bind;\n\t        }\n\t        return !vnode1.properties && !vnode2.properties;\n\t    };\n\t    var toTextVNode = function (data) {\n\t        return {\n\t            vnodeSelector: '',\n\t            properties: undefined,\n\t            children: undefined,\n\t            text: data.toString(),\n\t            domNode: null\n\t        };\n\t    };\n\t    var appendChildren = function (parentSelector, insertions, main) {\n\t        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n\t            var item = insertions[i];\n\t            if (Array.isArray(item)) {\n\t                appendChildren(parentSelector, item, main);\n\t            } else {\n\t                if (item !== null && item !== undefined) {\n\t                    if (!item.hasOwnProperty('vnodeSelector')) {\n\t                        item = toTextVNode(item);\n\t                    }\n\t                    main.push(item);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    // Render helper functions\n\t    var missingTransition = function () {\n\t        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n\t    };\n\t    var DEFAULT_PROJECTION_OPTIONS = {\n\t        namespace: undefined,\n\t        eventHandlerInterceptor: undefined,\n\t        styleApplyer: function (domNode, styleName, value) {\n\t            // Provides a hook to add vendor prefixes for browsers that still need it.\n\t            domNode.style[styleName] = value;\n\t        },\n\t        transitions: {\n\t            enter: missingTransition,\n\t            exit: missingTransition\n\t        }\n\t    };\n\t    var applyDefaultProjectionOptions = function (projectorOptions) {\n\t        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n\t    };\n\t    var checkStyleValue = function (styleValue) {\n\t        if (typeof styleValue !== 'string') {\n\t            throw new Error('Style values must be strings');\n\t        }\n\t    };\n\t    var setProperties = function (domNode, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            /* tslint:disable:no-var-keyword: edge case */\n\t            var propValue = properties[propName];\n\t            /* tslint:enable:no-var-keyword */\n\t            if (propName === 'className') {\n\t                throw new Error('Property \"className\" is not supported, use \"class\".');\n\t            } else if (propName === 'class') {\n\t                propValue.split(/\\s+/).forEach(function (token) {\n\t                    return domNode.classList.add(token);\n\t                });\n\t            } else if (propName === 'classes') {\n\t                // object with string keys and boolean values\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    if (propValue[className]) {\n\t                        domNode.classList.add(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                // object with string keys and string (!) values\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var styleValue = propValue[styleName];\n\t                    if (styleValue) {\n\t                        checkStyleValue(styleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n\t                    }\n\t                }\n\t            } else if (propName === 'key') {\n\t                continue;\n\t            } else if (propValue === null || propValue === undefined) {\n\t                continue;\n\t            } else {\n\t                var type = typeof propValue;\n\t                if (type === 'function') {\n\t                    if (propName.lastIndexOf('on', 0) === 0) {\n\t                        if (eventHandlerInterceptor) {\n\t                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n\t                        }\n\t                        if (propName === 'oninput') {\n\t                            (function () {\n\t                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n\t                                var oldPropValue = propValue;\n\t                                propValue = function (evt) {\n\t                                    evt.target['oninput-value'] = evt.target.value;\n\t                                    // may be HTMLTextAreaElement as well\n\t                                    oldPropValue.apply(this, [evt]);\n\t                                };\n\t                            }());\n\t                        }\n\t                        domNode[propName] = propValue;\n\t                    }\n\t                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n\t                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                    } else {\n\t                        domNode.setAttribute(propName, propValue);\n\t                    }\n\t                } else {\n\t                    domNode[propName] = propValue;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n\t        if (!properties) {\n\t            return;\n\t        }\n\t        var propertiesUpdated = false;\n\t        var propNames = Object.keys(properties);\n\t        var propCount = propNames.length;\n\t        for (var i = 0; i < propCount; i++) {\n\t            var propName = propNames[i];\n\t            // assuming that properties will be nullified instead of missing is by design\n\t            var propValue = properties[propName];\n\t            var previousValue = previousProperties[propName];\n\t            if (propName === 'class') {\n\t                if (previousValue !== propValue) {\n\t                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n\t                }\n\t            } else if (propName === 'classes') {\n\t                var classList = domNode.classList;\n\t                var classNames = Object.keys(propValue);\n\t                var classNameCount = classNames.length;\n\t                for (var j = 0; j < classNameCount; j++) {\n\t                    var className = classNames[j];\n\t                    var on = !!propValue[className];\n\t                    var previousOn = !!previousValue[className];\n\t                    if (on === previousOn) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (on) {\n\t                        classList.add(className);\n\t                    } else {\n\t                        classList.remove(className);\n\t                    }\n\t                }\n\t            } else if (propName === 'styles') {\n\t                var styleNames = Object.keys(propValue);\n\t                var styleCount = styleNames.length;\n\t                for (var j = 0; j < styleCount; j++) {\n\t                    var styleName = styleNames[j];\n\t                    var newStyleValue = propValue[styleName];\n\t                    var oldStyleValue = previousValue[styleName];\n\t                    if (newStyleValue === oldStyleValue) {\n\t                        continue;\n\t                    }\n\t                    propertiesUpdated = true;\n\t                    if (newStyleValue) {\n\t                        checkStyleValue(newStyleValue);\n\t                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n\t                    } else {\n\t                        projectionOptions.styleApplyer(domNode, styleName, '');\n\t                    }\n\t                }\n\t            } else {\n\t                if (!propValue && typeof previousValue === 'string') {\n\t                    propValue = '';\n\t                }\n\t                if (propName === 'value') {\n\t                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n\t                        domNode[propName] = propValue;\n\t                        // Reset the value, even if the virtual DOM did not change\n\t                        domNode['oninput-value'] = undefined;\n\t                    }\n\t                    // else do not update the domNode, otherwise the cursor position would be changed\n\t                    if (propValue !== previousValue) {\n\t                        propertiesUpdated = true;\n\t                    }\n\t                } else if (propValue !== previousValue) {\n\t                    var type = typeof propValue;\n\t                    if (type === 'function') {\n\t                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n\t                    }\n\t                    if (type === 'string' && propName !== 'innerHTML') {\n\t                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n\t                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n\t                        } else {\n\t                            domNode.setAttribute(propName, propValue);\n\t                        }\n\t                    } else {\n\t                        if (domNode[propName] !== propValue) {\n\t                            domNode[propName] = propValue;\n\t                        }\n\t                    }\n\t                    propertiesUpdated = true;\n\t                }\n\t            }\n\t        }\n\t        return propertiesUpdated;\n\t    };\n\t    var findIndexOfChild = function (children, sameAs, start) {\n\t        if (sameAs.vnodeSelector !== '') {\n\t            // Never scan for text-nodes\n\t            for (var i = start; i < children.length; i++) {\n\t                if (same(children[i], sameAs)) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    var nodeAdded = function (vNode, transitions) {\n\t        if (vNode.properties) {\n\t            var enterAnimation = vNode.properties.enterAnimation;\n\t            if (enterAnimation) {\n\t                if (typeof enterAnimation === 'function') {\n\t                    enterAnimation(vNode.domNode, vNode.properties);\n\t                } else {\n\t                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var nodeToRemove = function (vNode, transitions) {\n\t        var domNode = vNode.domNode;\n\t        if (vNode.properties) {\n\t            var exitAnimation = vNode.properties.exitAnimation;\n\t            if (exitAnimation) {\n\t                domNode.style.pointerEvents = 'none';\n\t                var removeDomNode = function () {\n\t                    if (domNode.parentNode) {\n\t                        domNode.parentNode.removeChild(domNode);\n\t                    }\n\t                };\n\t                if (typeof exitAnimation === 'function') {\n\t                    exitAnimation(domNode, removeDomNode, vNode.properties);\n\t                    return;\n\t                } else {\n\t                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t        if (domNode.parentNode) {\n\t            domNode.parentNode.removeChild(domNode);\n\t        }\n\t    };\n\t    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n\t        var childNode = childNodes[indexToCheck];\n\t        if (childNode.vnodeSelector === '') {\n\t            return;    // Text nodes need not be distinguishable\n\t        }\n\t        var properties = childNode.properties;\n\t        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n\t        if (!key) {\n\t            for (var i = 0; i < childNodes.length; i++) {\n\t                if (i !== indexToCheck) {\n\t                    var node = childNodes[i];\n\t                    if (same(node, childNode)) {\n\t                        if (operation === 'added') {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n\t                        } else {\n\t                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    var createDom;\n\t    var updateDom;\n\t    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n\t        if (oldChildren === newChildren) {\n\t            return false;\n\t        }\n\t        oldChildren = oldChildren || emptyArray;\n\t        newChildren = newChildren || emptyArray;\n\t        var oldChildrenLength = oldChildren.length;\n\t        var newChildrenLength = newChildren.length;\n\t        var transitions = projectionOptions.transitions;\n\t        var oldIndex = 0;\n\t        var newIndex = 0;\n\t        var i;\n\t        var textUpdated = false;\n\t        while (newIndex < newChildrenLength) {\n\t            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n\t            var newChild = newChildren[newIndex];\n\t            if (oldChild !== undefined && same(oldChild, newChild)) {\n\t                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n\t                oldIndex++;\n\t            } else {\n\t                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n\t                if (findOldIndex >= 0) {\n\t                    // Remove preceding missing children\n\t                    for (i = oldIndex; i < findOldIndex; i++) {\n\t                        nodeToRemove(oldChildren[i], transitions);\n\t                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t                    }\n\t                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n\t                    oldIndex = findOldIndex + 1;\n\t                } else {\n\t                    // New child\n\t                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n\t                    nodeAdded(newChild, transitions);\n\t                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n\t                }\n\t            }\n\t            newIndex++;\n\t        }\n\t        if (oldChildrenLength > oldIndex) {\n\t            // Remove child fragments\n\t            for (i = oldIndex; i < oldChildrenLength; i++) {\n\t                nodeToRemove(oldChildren[i], transitions);\n\t                checkDistinguishable(oldChildren, i, vnode, 'removed');\n\t            }\n\t        }\n\t        return textUpdated;\n\t    };\n\t    var addChildren = function (domNode, children, projectionOptions) {\n\t        if (!children) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < children.length; i++) {\n\t            createDom(children[i], domNode, undefined, projectionOptions);\n\t        }\n\t    };\n\t    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n\t        addChildren(domNode, vnode.children, projectionOptions);\n\t        // children before properties, needed for value property of <select>.\n\t        if (vnode.text) {\n\t            domNode.textContent = vnode.text;\n\t        }\n\t        setProperties(domNode, vnode.properties, projectionOptions);\n\t        if (vnode.properties && vnode.properties.afterCreate) {\n\t            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n\t                domNode,\n\t                projectionOptions,\n\t                vnode.vnodeSelector,\n\t                vnode.properties,\n\t                vnode.children\n\t            ]);\n\t        }\n\t    };\n\t    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n\t        var domNode, i, c, start = 0, type, found;\n\t        var vnodeSelector = vnode.vnodeSelector;\n\t        if (vnodeSelector === '') {\n\t            domNode = vnode.domNode = document.createTextNode(vnode.text);\n\t            if (insertBefore !== undefined) {\n\t                parentNode.insertBefore(domNode, insertBefore);\n\t            } else {\n\t                parentNode.appendChild(domNode);\n\t            }\n\t        } else {\n\t            for (i = 0; i <= vnodeSelector.length; ++i) {\n\t                c = vnodeSelector.charAt(i);\n\t                if (i === vnodeSelector.length || c === '.' || c === '#') {\n\t                    type = vnodeSelector.charAt(start - 1);\n\t                    found = vnodeSelector.slice(start, i);\n\t                    if (type === '.') {\n\t                        domNode.classList.add(found);\n\t                    } else if (type === '#') {\n\t                        domNode.id = found;\n\t                    } else {\n\t                        if (found === 'svg') {\n\t                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t                        }\n\t                        if (projectionOptions.namespace !== undefined) {\n\t                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n\t                        } else {\n\t                            domNode = vnode.domNode = document.createElement(found);\n\t                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n\t                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n\t                                domNode.setAttribute('type', vnode.properties.type);\n\t                            }\n\t                        }\n\t                        if (insertBefore !== undefined) {\n\t                            parentNode.insertBefore(domNode, insertBefore);\n\t                        } else {\n\t                            parentNode.appendChild(domNode);\n\t                        }\n\t                    }\n\t                    start = i + 1;\n\t                }\n\t            }\n\t            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n\t        }\n\t    };\n\t    updateDom = function (previous, vnode, projectionOptions) {\n\t        var domNode = previous.domNode;\n\t        var textUpdated = false;\n\t        if (previous === vnode) {\n\t            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n\t        }\n\t        var updated = false;\n\t        if (vnode.vnodeSelector === '') {\n\t            if (vnode.text !== previous.text) {\n\t                var newVNode = document.createTextNode(vnode.text);\n\t                domNode.parentNode.replaceChild(newVNode, domNode);\n\t                vnode.domNode = newVNode;\n\t                textUpdated = true;\n\t                return textUpdated;\n\t            }\n\t        } else {\n\t            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n\t                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n\t            }\n\t            if (previous.text !== vnode.text) {\n\t                updated = true;\n\t                if (vnode.text === undefined) {\n\t                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n\t                } else {\n\t                    domNode.textContent = vnode.text;\n\t                }\n\t            }\n\t            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n\t            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n\t            if (vnode.properties && vnode.properties.afterUpdate) {\n\t                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n\t                    domNode,\n\t                    projectionOptions,\n\t                    vnode.vnodeSelector,\n\t                    vnode.properties,\n\t                    vnode.children\n\t                ]);\n\t            }\n\t        }\n\t        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n\t            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n\t        }\n\t        vnode.domNode = previous.domNode;\n\t        return textUpdated;\n\t    };\n\t    var createProjection = function (vnode, projectionOptions) {\n\t        return {\n\t            update: function (updatedVnode) {\n\t                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n\t                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n\t                }\n\t                updateDom(vnode, updatedVnode, projectionOptions);\n\t                vnode = updatedVnode;\n\t            },\n\t            domNode: vnode.domNode\n\t        };\n\t    };\n\t    ;\n\t    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n\t    exports.h = function (selector) {\n\t        var properties = arguments[1];\n\t        if (typeof selector !== 'string') {\n\t            throw new Error();\n\t        }\n\t        var childIndex = 1;\n\t        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n\t            childIndex = 2;\n\t        } else {\n\t            // Optional properties argument was omitted\n\t            properties = undefined;\n\t        }\n\t        var text = undefined;\n\t        var children = undefined;\n\t        var argsLength = arguments.length;\n\t        // Recognize a common special case where there is only a single text node\n\t        if (argsLength === childIndex + 1) {\n\t            var onlyChild = arguments[childIndex];\n\t            if (typeof onlyChild === 'string') {\n\t                text = onlyChild;\n\t            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n\t                text = onlyChild[0];\n\t            }\n\t        }\n\t        if (text === undefined) {\n\t            children = [];\n\t            for (; childIndex < argsLength; childIndex++) {\n\t                var child = arguments[childIndex];\n\t                if (child === null || child === undefined) {\n\t                    continue;\n\t                } else if (Array.isArray(child)) {\n\t                    appendChildren(selector, child, children);\n\t                } else if (child.hasOwnProperty('vnodeSelector')) {\n\t                    children.push(child);\n\t                } else {\n\t                    children.push(toTextVNode(child));\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            vnodeSelector: selector,\n\t            properties: properties,\n\t            children: children,\n\t            text: text === '' ? undefined : text,\n\t            domNode: null\n\t        };\n\t    };\n\t    /**\n\t * Contains simple low-level utility functions to manipulate the real DOM.\n\t */\n\t    exports.dom = {\n\t        /**\n\t     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n\t     * its [[Projection.domNode|domNode]] property.\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection.\n\t     * @returns The [[Projection]] which also contains the DOM Node that was created.\n\t     */\n\t        create: function (vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n\t     * This is a low-level method. Users will typically use a [[Projector]] instead.\n\t     * @param parentNode - The parent node for the new childNode.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n\t     * objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        append: function (parentNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, parentNode, undefined, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Inserts a new DOM node which is generated from a [[VNode]].\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param beforeNode - The node that the DOM Node is inserted before.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n\t     * NOTE: [[VNode]] objects may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        insertBefore: function (beforeNode, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        },\n\t        /**\n\t     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n\t     * This means that the virtual DOM and the real DOM will have one overlapping element.\n\t     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n\t     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n\t     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n\t     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n\t     * may only be rendered once.\n\t     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n\t     * @returns The [[Projection]] that was created.\n\t     */\n\t        merge: function (element, vnode, projectionOptions) {\n\t            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n\t            vnode.domNode = element;\n\t            initPropertiesAndChildren(element, vnode, projectionOptions);\n\t            return createProjection(vnode, projectionOptions);\n\t        }\n\t    };\n\t    /**\n\t * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n\t * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n\t * For more information, see [[CalculationCache]].\n\t *\n\t * @param <Result> The type of the value that is cached.\n\t */\n\t    exports.createCache = function () {\n\t        var cachedInputs = undefined;\n\t        var cachedOutcome = undefined;\n\t        var result = {\n\t            invalidate: function () {\n\t                cachedOutcome = undefined;\n\t                cachedInputs = undefined;\n\t            },\n\t            result: function (inputs, calculation) {\n\t                if (cachedInputs) {\n\t                    for (var i = 0; i < inputs.length; i++) {\n\t                        if (cachedInputs[i] !== inputs[i]) {\n\t                            cachedOutcome = undefined;\n\t                        }\n\t                    }\n\t                }\n\t                if (!cachedOutcome) {\n\t                    cachedOutcome = calculation();\n\t                    cachedInputs = inputs;\n\t                }\n\t                return cachedOutcome;\n\t            }\n\t        };\n\t        return result;\n\t    };\n\t    /**\n\t * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n\t * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n\t *\n\t * @param <Source>       The type of source items. A database-record for instance.\n\t * @param <Target>       The type of target items. A [[Component]] for instance.\n\t * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n\t * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n\t *                       to the `callback` argument in `Array.map(callback)`.\n\t * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n\t */\n\t    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n\t        var keys = [];\n\t        var results = [];\n\t        return {\n\t            results: results,\n\t            map: function (newSources) {\n\t                var newKeys = newSources.map(getSourceKey);\n\t                var oldTargets = results.slice();\n\t                var oldIndex = 0;\n\t                for (var i = 0; i < newSources.length; i++) {\n\t                    var source = newSources[i];\n\t                    var sourceKey = newKeys[i];\n\t                    if (sourceKey === keys[oldIndex]) {\n\t                        results[i] = oldTargets[oldIndex];\n\t                        updateResult(source, oldTargets[oldIndex], i);\n\t                        oldIndex++;\n\t                    } else {\n\t                        var found = false;\n\t                        for (var j = 1; j < keys.length + 1; j++) {\n\t                            var searchIndex = (oldIndex + j) % keys.length;\n\t                            if (keys[searchIndex] === sourceKey) {\n\t                                results[i] = oldTargets[searchIndex];\n\t                                updateResult(newSources[i], oldTargets[searchIndex], i);\n\t                                oldIndex = searchIndex + 1;\n\t                                found = true;\n\t                                break;\n\t                            }\n\t                        }\n\t                        if (!found) {\n\t                            results[i] = createResult(source, i);\n\t                        }\n\t                    }\n\t                }\n\t                results.length = newSources.length;\n\t                keys = newKeys;\n\t            }\n\t        };\n\t    };\n\t    /**\n\t * Creates a [[Projector]] instance using the provided projectionOptions.\n\t *\n\t * For more information, see [[Projector]].\n\t *\n\t * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n\t */\n\t    exports.createProjector = function (projectorOptions) {\n\t        var projector;\n\t        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n\t        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n\t            return function () {\n\t                // intercept function calls (event handlers) to do a render afterwards.\n\t                projector.scheduleRender();\n\t                return eventHandler.apply(properties.bind || this, arguments);\n\t            };\n\t        };\n\t        var renderCompleted = true;\n\t        var scheduled;\n\t        var stopped = false;\n\t        var projections = [];\n\t        var renderFunctions = [];\n\t        // matches the projections array\n\t        var doRender = function () {\n\t            scheduled = undefined;\n\t            if (!renderCompleted) {\n\t                return;    // The last render threw an error, it should be logged in the browser console.\n\t            }\n\t            renderCompleted = false;\n\t            for (var i = 0; i < projections.length; i++) {\n\t                var updatedVnode = renderFunctions[i]();\n\t                projections[i].update(updatedVnode);\n\t            }\n\t            renderCompleted = true;\n\t        };\n\t        projector = {\n\t            renderNow: doRender,\n\t            scheduleRender: function () {\n\t                if (!scheduled && !stopped) {\n\t                    scheduled = requestAnimationFrame(doRender);\n\t                }\n\t            },\n\t            stop: function () {\n\t                if (scheduled) {\n\t                    cancelAnimationFrame(scheduled);\n\t                    scheduled = undefined;\n\t                }\n\t                stopped = true;\n\t            },\n\t            resume: function () {\n\t                stopped = false;\n\t                renderCompleted = true;\n\t                projector.scheduleRender();\n\t            },\n\t            append: function (parentNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            insertBefore: function (beforeNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            merge: function (domNode, renderMaquetteFunction) {\n\t                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            replace: function (domNode, renderMaquetteFunction) {\n\t                var vnode = renderMaquetteFunction();\n\t                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n\t                domNode.parentNode.removeChild(domNode);\n\t                projections.push(createProjection(vnode, projectionOptions));\n\t                renderFunctions.push(renderMaquetteFunction);\n\t            },\n\t            detach: function (renderMaquetteFunction) {\n\t                for (var i = 0; i < renderFunctions.length; i++) {\n\t                    if (renderFunctions[i] === renderMaquetteFunction) {\n\t                        renderFunctions.splice(i, 1);\n\t                        return projections.splice(i, 1)[0];\n\t                    }\n\t                }\n\t                throw new Error('renderMaquetteFunction was not found');\n\t            }\n\t        };\n\t        return projector;\n\t    };\n\t}));\n\t//# sourceMappingURL=maquette.js.map\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(62), __webpack_require__(25), __webpack_require__(61), __webpack_require__(42)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createAction_1 = __webpack_require__(62);\n\t    var lang_1 = __webpack_require__(25);\n\t    var widgetStore_1 = __webpack_require__(61);\n\t    var todoStoreActions_1 = __webpack_require__(42);\n\t    exports.todoInput = createAction_1.default({\n\t        do: function (_a) {\n\t            var _b = _a.event, keyCode = _b.keyCode, label = _b.target.value;\n\t            if (keyCode === 13 && label) {\n\t                todoStoreActions_1.addTodo.do({ label: label, completed: false });\n\t                return widgetStore_1.default.patch({ id: 'new-todo', value: '' });\n\t            }\n\t        }\n\t    });\n\t    exports.todoEdit = createAction_1.default({\n\t        do: function (options) {\n\t            return widgetStore_1.default.patch(lang_1.assign(options, { editing: true }));\n\t        }\n\t    });\n\t    exports.todoEditInput = createAction_1.default({\n\t        do: function (options) {\n\t            var keyCode = options.event.keyCode;\n\t            if (keyCode === 13) {\n\t                return exports.todoSave.do(options);\n\t            }\n\t            else if (keyCode === 27) {\n\t                return widgetStore_1.default.patch(lang_1.assign(options.state, { editing: false }));\n\t            }\n\t        }\n\t    });\n\t    exports.todoSave = createAction_1.default({\n\t        do: function (_a) {\n\t            var label = _a.event.target.value, state = _a.state;\n\t            if (!label) {\n\t                return todoStoreActions_1.deleteTodo.do(state);\n\t            }\n\t            else {\n\t                return todoStoreActions_1.updateTodo.do(lang_1.assign(state, { label: label, editing: false }));\n\t            }\n\t        }\n\t    });\n\t    exports.todoRemove = createAction_1.default({\n\t        do: function (item) {\n\t            return todoStoreActions_1.deleteTodo.do(item);\n\t        }\n\t    });\n\t    exports.todoToggleComplete = createAction_1.default({\n\t        do: function (item) {\n\t            item = lang_1.assign({}, item, { completed: !item.completed });\n\t            return todoStoreActions_1.updateTodo.do(item);\n\t        }\n\t    });\n\t    exports.filter = createAction_1.default({\n\t        do: function (_a) {\n\t            var activeFilter = _a.filter;\n\t            return Promise.all([\n\t                widgetStore_1.default.patch({ id: 'todo-footer', activeFilter: activeFilter }),\n\t                widgetStore_1.default.patch({ id: 'todo-list', activeFilter: activeFilter })\n\t            ]);\n\t        }\n\t    });\n\t    exports.todoToggleAll = createAction_1.default({\n\t        do: function (_a) {\n\t            var checked = _a.event.target.checked;\n\t            todoStoreActions_1.toggleAll.do({ checked: checked });\n\t        }\n\t    });\n\t    exports.clearCompleted = createAction_1.default({\n\t        do: function () {\n\t            return todoStoreActions_1.deleteCompleted.do();\n\t        }\n\t    });\n\t});\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(62), __webpack_require__(28), __webpack_require__(43)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createAction_1 = __webpack_require__(62);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var todoStore_1 = __webpack_require__(43);\n\t    exports.addTodo = createAction_1.default({\n\t        do: function (_a) {\n\t            var label = _a.label;\n\t            return todoStore_1.default.add({ id: \"\" + Date.now(), label: label });\n\t        }\n\t    });\n\t    exports.deleteTodo = createAction_1.default({\n\t        do: function (_a) {\n\t            var id = _a.id;\n\t            return todoStore_1.default.delete(id);\n\t        }\n\t    });\n\t    exports.deleteCompleted = createAction_1.default({\n\t        do: function () {\n\t            return todoStore_1.default.get()\n\t                .then(function (items) {\n\t                var promises = Array.from(items)\n\t                    .filter(function (_a) {\n\t                    var completed = _a.completed;\n\t                    return completed;\n\t                })\n\t                    .map(function (_a) {\n\t                    var id = _a.id;\n\t                    return todoStore_1.default.delete(id);\n\t                });\n\t                return Promise_1.default.all(promises);\n\t            });\n\t        }\n\t    });\n\t    exports.toggleAll = createAction_1.default({\n\t        do: function (_a) {\n\t            var completed = _a.checked;\n\t            return todoStore_1.default.get()\n\t                .then(function (items) {\n\t                var promises = Array.from(items)\n\t                    .map(function (_a) {\n\t                    var id = _a.id;\n\t                    return todoStore_1.default.patch({ completed: completed }, { id: id });\n\t                });\n\t                return Promise_1.default.all(promises);\n\t            });\n\t        }\n\t    });\n\t    exports.updateTodo = createAction_1.default({\n\t        do: function (item) {\n\t            return todoStore_1.default.patch(item);\n\t        }\n\t    });\n\t});\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(44), __webpack_require__(60)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createMemoryStore_1 = __webpack_require__(44);\n\t    var widgetStoreActions_1 = __webpack_require__(60);\n\t    var todoStore = createMemoryStore_1.default({\n\t        data: []\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = todoStore;\n\t    // FIXME: Would be great if the app could trigger a callback like this.\n\t    function bindActions() {\n\t        return todoStore\n\t            .observe()\n\t            .subscribe(function (options) {\n\t            var changeRecord = options;\n\t            widgetStoreActions_1.updateHeaderAndFooter.do(changeRecord);\n\t            var puts = changeRecord.puts, deletes = changeRecord.deletes;\n\t            if (deletes.length) {\n\t                widgetStoreActions_1.deleteTodo.do(changeRecord);\n\t            }\n\t            if (puts.length) {\n\t                widgetStoreActions_1.putTodo.do(changeRecord);\n\t            }\n\t        });\n\t    }\n\t    exports.bindActions = bindActions;\n\t});\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(36), __webpack_require__(45), __webpack_require__(25), __webpack_require__(28), __webpack_require__(22), __webpack_require__(20), __webpack_require__(19)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var immutable_1 = __webpack_require__(36);\n\t    var Observable_1 = __webpack_require__(45);\n\t    var lang_1 = __webpack_require__(25);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var compose_1 = __webpack_require__(20);\n\t    var createDestroyable_1 = __webpack_require__(19);\n\t    /**\n\t     * The weak map that contains the data for the stores\n\t     */\n\t    var dataWeakMap = new WeakMap_1.default();\n\t    /**\n\t     * The weak map that contains any observers for the stores\n\t     */\n\t    var itemObserverWeakMap = new WeakMap_1.default();\n\t    /**\n\t     *\n\t     */\n\t    var storeObserverWeakMap = new WeakMap_1.default();\n\t    /**\n\t     * The methods to decorate the MemoryStorePromise with\n\t     */\n\t    var storeMethods = ['get', 'put', 'add', 'patch', 'delete', 'fromArray'];\n\t    /**\n\t        * Returns true if a given value has a `then` method.\n\t        * @param {any} value The value to check if is Thenable\n\t        * @returns {is Thenable<T>} A type guard if the value is thenable\n\t        */\n\t    function isThenable(value) {\n\t        return value && typeof value.then === 'function';\n\t    }\n\t    /**\n\t     * Utility function that takes a result and generates a MemoryStorePromise\n\t     * @param store The store to use as a reference when decorating the Promise\n\t     * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created\n\t     */\n\t    function wrapResult(store, result) {\n\t        /* TODO: this all seems pretty expensive, there has to be a better way */\n\t        var p = (isThenable(result) ? result : Promise_1.default.resolve(result));\n\t        storeMethods.forEach(function (method) {\n\t            p[method] = function () {\n\t                var args = [];\n\t                for (var _i = 0; _i < arguments.length; _i++) {\n\t                    args[_i - 0] = arguments[_i];\n\t                }\n\t                return p.then(function () {\n\t                    return store[method].apply(store, args);\n\t                });\n\t            };\n\t        });\n\t        return p;\n\t    }\n\t    /**\n\t     * Utility function that takes an error and generates a rejected MemoryStorePromise\n\t     * @param store The store to use as a reference when decorating the Promise\n\t     * @param result The result to wrap\n\t     */\n\t    function wrapError(store, result) {\n\t        var p = (isThenable(result) ? result : Promise_1.default.reject(result));\n\t        storeMethods.forEach(function (method) {\n\t            p[method] = function () {\n\t                var args = [];\n\t                for (var _i = 0; _i < arguments.length; _i++) {\n\t                    args[_i - 0] = arguments[_i];\n\t                }\n\t                return p.then(function () {\n\t                    return store[method].apply(store, args);\n\t                });\n\t            };\n\t        });\n\t        return p;\n\t    }\n\t    /**\n\t     * Create a new instance of a MemoryStore\n\t     */\n\t    var createMemoryStore = compose_1.default({\n\t        idProperty: 'id',\n\t        get: function (id) {\n\t            var data = dataWeakMap.get(this);\n\t            if (id) {\n\t                return wrapResult(this, data && data.get(String(id)));\n\t            }\n\t            else {\n\t                return wrapResult(this, data.values());\n\t            }\n\t        },\n\t        observe: function (id) {\n\t            var store = this;\n\t            if (id) {\n\t                return new Observable_1.Observable(function subscribe(observer) {\n\t                    store.get(String(id)).then(function (item) {\n\t                        if (item) {\n\t                            observer.next(item);\n\t                            var observers = itemObserverWeakMap.get(store);\n\t                            var observerArray = observers && observers.has(String(id)) ? observers.get(String(id)) : [];\n\t                            observerArray.push(observer);\n\t                            itemObserverWeakMap.set(store, (observers ? observers : immutable_1.Map()).set(String(id), observerArray));\n\t                        }\n\t                        else {\n\t                            observer.error(new Error(\"ID \\\"\" + id + \"\\\" not found in store\"));\n\t                        }\n\t                    });\n\t                });\n\t            }\n\t            else {\n\t                return new Observable_1.Observable(function subscribe(observer) {\n\t                    var data = dataWeakMap.get(store);\n\t                    var observers = storeObserverWeakMap.get(store) || [];\n\t                    var values = data.values();\n\t                    var items = Array.from(values);\n\t                    var payload = {\n\t                        puts: items,\n\t                        deletes: [],\n\t                        beforeAll: [],\n\t                        afterAll: items\n\t                    };\n\t                    observer.next(payload);\n\t                    observers.push(observer);\n\t                    storeObserverWeakMap.set(store, observers);\n\t                });\n\t            }\n\t        },\n\t        put: function (item, options) {\n\t            var store = this;\n\t            var data = dataWeakMap.get(store);\n\t            var beforeAll = data ? data.values() : [];\n\t            var idProperty = store.idProperty;\n\t            var id = options && 'id' in options ? options.id :\n\t                idProperty in item ? item[idProperty] :\n\t                    data ? data.size : 0;\n\t            if (options && options.replace === false && data && data.has(String(id))) {\n\t                return wrapError(store, Error(\"Duplicate ID \\\"\" + id + \"\\\" when pragma \\\"replace\\\" is false\"));\n\t            }\n\t            item[idProperty] = id;\n\t            dataWeakMap.set(store, (data ? data : immutable_1.OrderedMap()).set(String(id), item));\n\t            var observers = itemObserverWeakMap.get(store);\n\t            if (observers && observers.has(String(id))) {\n\t                observers.get(String(id)).forEach(function (observer) { return observer.next(item); });\n\t            }\n\t            var storeObservers = storeObserverWeakMap.get(store);\n\t            if (storeObservers) {\n\t                var afterData = dataWeakMap.get(store);\n\t                var afterAll = afterData.values();\n\t                var payload_1 = {\n\t                    puts: [item],\n\t                    deletes: [],\n\t                    beforeAll: Array.from(beforeAll),\n\t                    afterAll: Array.from(afterAll)\n\t                };\n\t                storeObservers.forEach(function (observer) {\n\t                    observer.next(payload_1);\n\t                });\n\t            }\n\t            return wrapResult(store, item);\n\t        },\n\t        add: function (item, options) {\n\t            return this.put(item, lang_1.assign(options ? options : {}, { replace: false }));\n\t        },\n\t        patch: function (partial, options) {\n\t            var _this = this;\n\t            var idProperty = this.idProperty;\n\t            var id = options && 'id' in options ? options.id : partial[idProperty];\n\t            if (!id) {\n\t                return wrapError(this, new Error(\"Object ID must either be passed in \\\"partial.\" + idProperty + \"\\\" or \\\"options.id\\\"\"));\n\t            }\n\t            return wrapResult(this, this.get(id).then(function (item) {\n\t                if (item === void 0) { item = {}; }\n\t                options = options || {};\n\t                options.id = id;\n\t                return _this.put(lang_1.assign(item, partial), options);\n\t            }));\n\t        },\n\t        delete: function (item) {\n\t            var store = this;\n\t            var idProperty = store.idProperty;\n\t            var data = dataWeakMap.get(store);\n\t            var beforeAll = data ? data.values() : [];\n\t            /**\n\t             * Complete any observers associated with this items id\n\t             */\n\t            function completeObservable(id) {\n\t                var observers = itemObserverWeakMap.get(store);\n\t                if (observers && observers.has(String(id))) {\n\t                    observers.get(String(id)).forEach(function (observer) { return observer.complete(); });\n\t                    itemObserverWeakMap.set(store, observers.delete(id));\n\t                }\n\t            }\n\t            function completeStoreObservers() {\n\t                var storeObservers = storeObserverWeakMap.get(store);\n\t                if (storeObservers) {\n\t                    var afterData = dataWeakMap.get(store);\n\t                    var afterAll = afterData.values();\n\t                    var payload_2 = {\n\t                        puts: [],\n\t                        deletes: [item],\n\t                        beforeAll: Array.from(beforeAll),\n\t                        afterAll: Array.from(afterAll)\n\t                    };\n\t                    storeObservers.forEach(function (observer) {\n\t                        observer.next(payload_2);\n\t                    });\n\t                }\n\t            }\n\t            if (typeof item === 'object') {\n\t                if (idProperty in item && data && data.has(String(item[idProperty]))) {\n\t                    dataWeakMap.set(store, data.delete(String(item[idProperty])));\n\t                    completeObservable(item[idProperty]);\n\t                    completeStoreObservers();\n\t                    return wrapResult(store, true);\n\t                }\n\t            }\n\t            else {\n\t                if (data && data.has(String(item))) {\n\t                    dataWeakMap.set(store, data.delete(String(item)));\n\t                    completeObservable(item);\n\t                    completeStoreObservers();\n\t                    return wrapResult(store, true);\n\t                }\n\t            }\n\t            return wrapResult(store, false);\n\t        },\n\t        fromArray: function (items) {\n\t            var store = this;\n\t            var map = {};\n\t            var idProperty = store.idProperty;\n\t            items.forEach(function (item, idx) {\n\t                var id = idProperty in item ? item[idProperty] : idx;\n\t                item[idProperty] = id;\n\t                map[id] = item;\n\t            });\n\t            dataWeakMap.set(store, immutable_1.OrderedMap(map));\n\t            return wrapResult(store, undefined);\n\t        }\n\t    }, function (instance, options) {\n\t        if (options) {\n\t            if (options.idProperty) {\n\t                instance.idProperty = options.idProperty;\n\t            }\n\t            if (options.data) {\n\t                instance.fromArray(options.data);\n\t            }\n\t        }\n\t    })\n\t        .mixin(createDestroyable_1.default)\n\t        .static({\n\t        fromArray: function (data) {\n\t            return createMemoryStore({ data: data });\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createMemoryStore;\n\t});\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(46), __webpack_require__(48), __webpack_require__(49)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, root_1, observable_1, toSubscriber_1) {\n\t    \"use strict\";\n\t    /**\n\t     * A representation of any set of values over any amount of time. This the most basic building block\n\t     * of RxJS.\n\t     *\n\t     * @class Observable<T>\n\t     */\n\t    var Observable = (function () {\n\t        /**\n\t         * @constructor\n\t         * @param {Function} subscribe the function that is  called when the Observable is\n\t         * initially subscribed to. This function is given a Subscriber, to which new values\n\t         * can be `next`ed, or an `error` method can be called to raise an error, or\n\t         * `complete` can be called to notify of a successful completion.\n\t         */\n\t        function Observable(subscribe) {\n\t            this._isScalar = false;\n\t            if (subscribe) {\n\t                this._subscribe = subscribe;\n\t            }\n\t        }\n\t        /**\n\t         * Creates a new Observable, with this Observable as the source, and the passed\n\t         * operator defined as the new observable's operator.\n\t         * @method lift\n\t         * @param {Operator} operator the operator defining the operation to take on the observable\n\t         * @return {Observable} a new observable with the Operator applied\n\t         */\n\t        Observable.prototype.lift = function (operator) {\n\t            var observable = new Observable();\n\t            observable.source = this;\n\t            observable.operator = operator;\n\t            return observable;\n\t        };\n\t        /**\n\t         * Registers handlers for handling emitted values, error and completions from the observable, and\n\t         *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n\t         * @method subscribe\n\t         * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n\t         *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n\t         * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n\t         *  the error will be thrown as unhandled\n\t         * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n\t         * @return {ISubscription} a subscription reference to the registered handlers\n\t         */\n\t        Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t            var operator = this.operator;\n\t            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t            sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));\n\t            if (sink.syncErrorThrowable) {\n\t                sink.syncErrorThrowable = false;\n\t                if (sink.syncErrorThrown) {\n\t                    throw sink.syncErrorValue;\n\t                }\n\t            }\n\t            return sink;\n\t        };\n\t        /**\n\t         * @method forEach\n\t         * @param {Function} next a handler for each value emitted by the observable\n\t         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t         * @return {Promise} a promise that either resolves on observable completion or\n\t         *  rejects with the handled error\n\t         */\n\t        Observable.prototype.forEach = function (next, PromiseCtor) {\n\t            var _this = this;\n\t            if (!PromiseCtor) {\n\t                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                    PromiseCtor = root_1.root.Rx.config.Promise;\n\t                }\n\t                else if (root_1.root.Promise) {\n\t                    PromiseCtor = root_1.root.Promise;\n\t                }\n\t            }\n\t            if (!PromiseCtor) {\n\t                throw new Error('no Promise impl found');\n\t            }\n\t            return new PromiseCtor(function (resolve, reject) {\n\t                var subscription = _this.subscribe(function (value) {\n\t                    if (subscription) {\n\t                        // if there is a subscription, then we can surmise\n\t                        // the next handling is asynchronous. Any errors thrown\n\t                        // need to be rejected explicitly and unsubscribe must be\n\t                        // called manually\n\t                        try {\n\t                            next(value);\n\t                        }\n\t                        catch (err) {\n\t                            reject(err);\n\t                            subscription.unsubscribe();\n\t                        }\n\t                    }\n\t                    else {\n\t                        // if there is NO subscription, then we're getting a nexted\n\t                        // value synchronously during subscription. We can just call it.\n\t                        // If it errors, Observable's `subscribe` imple will ensure the\n\t                        // unsubscription logic is called, then synchronously rethrow the error.\n\t                        // After that, Promise will trap the error and send it\n\t                        // down the rejection path.\n\t                        next(value);\n\t                    }\n\t                }, reject, resolve);\n\t            });\n\t        };\n\t        Observable.prototype._subscribe = function (subscriber) {\n\t            return this.source.subscribe(subscriber);\n\t        };\n\t        /**\n\t         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t         * @method Symbol.observable\n\t         * @return {Observable} this instance of the observable\n\t         */\n\t        Observable.prototype[observable_1.$$observable] = function () {\n\t            return this;\n\t        };\n\t        // HACK: Since TypeScript inherits static properties too, we have to\n\t        // fight against TypeScript here so Subject can have a different static create signature\n\t        /**\n\t         * Creates a new cold Observable by calling the Observable constructor\n\t         * @static true\n\t         * @owner Observable\n\t         * @method create\n\t         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t         * @return {Observable} a new cold observable\n\t         */\n\t        Observable.create = function (subscribe) {\n\t            return new Observable(subscribe);\n\t        };\n\t        return Observable;\n\t    }());\n\t    exports.Observable = Observable;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    var objectTypes = {\n\t        'boolean': false,\n\t        'function': true,\n\t        'object': true,\n\t        'number': false,\n\t        'string': false,\n\t        'undefined': false\n\t    };\n\t    exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n\t    /* tslint:disable:no-unused-variable */\n\t    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\t    var freeGlobal = objectTypes[typeof global] && global;\n\t    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n\t        exports.root = freeGlobal;\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=root.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(47)(module), (function() { return this; }())))\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(46)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, root_1) {\n\t    \"use strict\";\n\t    var Symbol = root_1.root.Symbol;\n\t    if (typeof Symbol === 'function') {\n\t        if (Symbol.observable) {\n\t            exports.$$observable = Symbol.observable;\n\t        }\n\t        else {\n\t            if (typeof Symbol.for === 'function') {\n\t                exports.$$observable = Symbol.for('observable');\n\t            }\n\t            else {\n\t                exports.$$observable = Symbol('observable');\n\t            }\n\t            Symbol.observable = exports.$$observable;\n\t        }\n\t    }\n\t    else {\n\t        exports.$$observable = '@@observable';\n\t    }\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=observable.js.map\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(50), __webpack_require__(58)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, Subscriber_1, rxSubscriber_1) {\n\t    \"use strict\";\n\t    function toSubscriber(nextOrObserver, error, complete) {\n\t        if (nextOrObserver && typeof nextOrObserver === 'object') {\n\t            if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t                return nextOrObserver;\n\t            }\n\t            else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {\n\t                return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t            }\n\t        }\n\t        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t    }\n\t    exports.toSubscriber = toSubscriber;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=toSubscriber.js.map\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(51), __webpack_require__(52), __webpack_require__(58), __webpack_require__(59)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, isFunction_1, Subscription_1, rxSubscriber_1, Observer_1) {\n\t    \"use strict\";\n\t    /**\n\t     * Implements the {@link Observer} interface and extends the\n\t     * {@link Subscription} class. While the {@link Observer} is the public API for\n\t     * consuming the values of an {@link Observable}, all Observers get converted to\n\t     * a Subscriber, in order to provide Subscription-like capabilities such as\n\t     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t     * implementing operators, but it is rarely used as a public API.\n\t     *\n\t     * @class Subscriber<T>\n\t     */\n\t    var Subscriber = (function (_super) {\n\t        __extends(Subscriber, _super);\n\t        /**\n\t         * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t         * defined Observer or a `next` callback function.\n\t         * @param {function(e: ?any): void} [error] The `error` callback of an\n\t         * Observer.\n\t         * @param {function(): void} [complete] The `complete` callback of an\n\t         * Observer.\n\t         */\n\t        function Subscriber(destinationOrNext, error, complete) {\n\t            _super.call(this);\n\t            this.syncErrorValue = null;\n\t            this.syncErrorThrown = false;\n\t            this.syncErrorThrowable = false;\n\t            this.isStopped = false;\n\t            switch (arguments.length) {\n\t                case 0:\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                case 1:\n\t                    if (!destinationOrNext) {\n\t                        this.destination = Observer_1.empty;\n\t                        break;\n\t                    }\n\t                    if (typeof destinationOrNext === 'object') {\n\t                        if (destinationOrNext instanceof Subscriber) {\n\t                            this.destination = destinationOrNext;\n\t                            this.destination.add(this);\n\t                        }\n\t                        else {\n\t                            this.syncErrorThrowable = true;\n\t                            this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                        }\n\t                        break;\n\t                    }\n\t                default:\n\t                    this.syncErrorThrowable = true;\n\t                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                    break;\n\t            }\n\t        }\n\t        /**\n\t         * A static factory for a Subscriber, given a (potentially partial) definition\n\t         * of an Observer.\n\t         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t         * @param {function(e: ?any): void} [error] The `error` callback of an\n\t         * Observer.\n\t         * @param {function(): void} [complete] The `complete` callback of an\n\t         * Observer.\n\t         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t         * Observer represented by the given arguments.\n\t         */\n\t        Subscriber.create = function (next, error, complete) {\n\t            var subscriber = new Subscriber(next, error, complete);\n\t            subscriber.syncErrorThrowable = false;\n\t            return subscriber;\n\t        };\n\t        /**\n\t         * The {@link Observer} callback to receive notifications of type `next` from\n\t         * the Observable, with a value. The Observable may call this method 0 or more\n\t         * times.\n\t         * @param {T} [value] The `next` value.\n\t         * @return {void}\n\t         */\n\t        Subscriber.prototype.next = function (value) {\n\t            if (!this.isStopped) {\n\t                this._next(value);\n\t            }\n\t        };\n\t        /**\n\t         * The {@link Observer} callback to receive notifications of type `error` from\n\t         * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t         * the Observable has experienced an error condition.\n\t         * @param {any} [err] The `error` exception.\n\t         * @return {void}\n\t         */\n\t        Subscriber.prototype.error = function (err) {\n\t            if (!this.isStopped) {\n\t                this.isStopped = true;\n\t                this._error(err);\n\t            }\n\t        };\n\t        /**\n\t         * The {@link Observer} callback to receive a valueless notification of type\n\t         * `complete` from the Observable. Notifies the Observer that the Observable\n\t         * has finished sending push-based notifications.\n\t         * @return {void}\n\t         */\n\t        Subscriber.prototype.complete = function () {\n\t            if (!this.isStopped) {\n\t                this.isStopped = true;\n\t                this._complete();\n\t            }\n\t        };\n\t        Subscriber.prototype.unsubscribe = function () {\n\t            if (this.isUnsubscribed) {\n\t                return;\n\t            }\n\t            this.isStopped = true;\n\t            _super.prototype.unsubscribe.call(this);\n\t        };\n\t        Subscriber.prototype._next = function (value) {\n\t            this.destination.next(value);\n\t        };\n\t        Subscriber.prototype._error = function (err) {\n\t            this.destination.error(err);\n\t            this.unsubscribe();\n\t        };\n\t        Subscriber.prototype._complete = function () {\n\t            this.destination.complete();\n\t            this.unsubscribe();\n\t        };\n\t        Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n\t            return this;\n\t        };\n\t        return Subscriber;\n\t    }(Subscription_1.Subscription));\n\t    exports.Subscriber = Subscriber;\n\t    /**\n\t     * We need this JSDoc comment for affecting ESDoc.\n\t     * @ignore\n\t     * @extends {Ignored}\n\t     */\n\t    var SafeSubscriber = (function (_super) {\n\t        __extends(SafeSubscriber, _super);\n\t        function SafeSubscriber(_parent, observerOrNext, error, complete) {\n\t            _super.call(this);\n\t            this._parent = _parent;\n\t            var next;\n\t            var context = this;\n\t            if (isFunction_1.isFunction(observerOrNext)) {\n\t                next = observerOrNext;\n\t            }\n\t            else if (observerOrNext) {\n\t                context = observerOrNext;\n\t                next = observerOrNext.next;\n\t                error = observerOrNext.error;\n\t                complete = observerOrNext.complete;\n\t                if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                    this.add(context.unsubscribe.bind(context));\n\t                }\n\t                context.unsubscribe = this.unsubscribe.bind(this);\n\t            }\n\t            this._context = context;\n\t            this._next = next;\n\t            this._error = error;\n\t            this._complete = complete;\n\t        }\n\t        SafeSubscriber.prototype.next = function (value) {\n\t            if (!this.isStopped && this._next) {\n\t                var _parent = this._parent;\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._next, value);\n\t                }\n\t                else if (this.__tryOrSetError(_parent, this._next, value)) {\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.error = function (err) {\n\t            if (!this.isStopped) {\n\t                var _parent = this._parent;\n\t                if (this._error) {\n\t                    if (!_parent.syncErrorThrowable) {\n\t                        this.__tryOrUnsub(this._error, err);\n\t                        this.unsubscribe();\n\t                    }\n\t                    else {\n\t                        this.__tryOrSetError(_parent, this._error, err);\n\t                        this.unsubscribe();\n\t                    }\n\t                }\n\t                else if (!_parent.syncErrorThrowable) {\n\t                    this.unsubscribe();\n\t                    throw err;\n\t                }\n\t                else {\n\t                    _parent.syncErrorValue = err;\n\t                    _parent.syncErrorThrown = true;\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.complete = function () {\n\t            if (!this.isStopped) {\n\t                var _parent = this._parent;\n\t                if (this._complete) {\n\t                    if (!_parent.syncErrorThrowable) {\n\t                        this.__tryOrUnsub(this._complete);\n\t                        this.unsubscribe();\n\t                    }\n\t                    else {\n\t                        this.__tryOrSetError(_parent, this._complete);\n\t                        this.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t            try {\n\t                fn.call(this._context, value);\n\t            }\n\t            catch (err) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t        };\n\t        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t            try {\n\t                fn.call(this._context, value);\n\t            }\n\t            catch (err) {\n\t                parent.syncErrorValue = err;\n\t                parent.syncErrorThrown = true;\n\t                return true;\n\t            }\n\t            return false;\n\t        };\n\t        SafeSubscriber.prototype._unsubscribe = function () {\n\t            var _parent = this._parent;\n\t            this._context = null;\n\t            this._parent = null;\n\t            _parent.unsubscribe();\n\t        };\n\t        return SafeSubscriber;\n\t    }(Subscriber));\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    function isFunction(x) {\n\t        return typeof x === 'function';\n\t    }\n\t    exports.isFunction = isFunction;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=isFunction.js.map\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(53), __webpack_require__(54), __webpack_require__(51), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, isArray_1, isObject_1, isFunction_1, tryCatch_1, errorObject_1, UnsubscriptionError_1) {\n\t    \"use strict\";\n\t    /**\n\t     * Represents a disposable resource, such as the execution of an Observable. A\n\t     * Subscription has one important method, `unsubscribe`, that takes no argument\n\t     * and just disposes the resource held by the subscription.\n\t     *\n\t     * Additionally, subscriptions may be grouped together through the `add()`\n\t     * method, which will attach a child Subscription to the current Subscription.\n\t     * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t     * will be unsubscribed as well.\n\t     *\n\t     * @class Subscription\n\t     */\n\t    var Subscription = (function () {\n\t        /**\n\t         * @param {function(): void} [unsubscribe] A function describing how to\n\t         * perform the disposal of resources when the `unsubscribe` method is called.\n\t         */\n\t        function Subscription(unsubscribe) {\n\t            /**\n\t             * A flag to indicate whether this Subscription has already been unsubscribed.\n\t             * @type {boolean}\n\t             */\n\t            this.isUnsubscribed = false;\n\t            if (unsubscribe) {\n\t                this._unsubscribe = unsubscribe;\n\t            }\n\t        }\n\t        /**\n\t         * Disposes the resources held by the subscription. May, for instance, cancel\n\t         * an ongoing Observable execution or cancel any other type of work that\n\t         * started when the Subscription was created.\n\t         * @return {void}\n\t         */\n\t        Subscription.prototype.unsubscribe = function () {\n\t            var hasErrors = false;\n\t            var errors;\n\t            if (this.isUnsubscribed) {\n\t                return;\n\t            }\n\t            this.isUnsubscribed = true;\n\t            var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t            this._subscriptions = null;\n\t            if (isFunction_1.isFunction(_unsubscribe)) {\n\t                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t                if (trial === errorObject_1.errorObject) {\n\t                    hasErrors = true;\n\t                    (errors = errors || []).push(errorObject_1.errorObject.e);\n\t                }\n\t            }\n\t            if (isArray_1.isArray(_subscriptions)) {\n\t                var index = -1;\n\t                var len = _subscriptions.length;\n\t                while (++index < len) {\n\t                    var sub = _subscriptions[index];\n\t                    if (isObject_1.isObject(sub)) {\n\t                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                        if (trial === errorObject_1.errorObject) {\n\t                            hasErrors = true;\n\t                            errors = errors || [];\n\t                            var err = errorObject_1.errorObject.e;\n\t                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                                errors = errors.concat(err.errors);\n\t                            }\n\t                            else {\n\t                                errors.push(err);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            if (hasErrors) {\n\t                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t            }\n\t        };\n\t        /**\n\t         * Adds a tear down to be called during the unsubscribe() of this\n\t         * Subscription.\n\t         *\n\t         * If the tear down being added is a subscription that is already\n\t         * unsubscribed, is the same reference `add` is being called on, or is\n\t         * `Subscription.EMPTY`, it will not be added.\n\t         *\n\t         * If this subscription is already in an `isUnsubscribed` state, the passed\n\t         * tear down logic will be executed immediately.\n\t         *\n\t         * @param {TeardownLogic} teardown The additional logic to execute on\n\t         * teardown.\n\t         * @return {Subscription} Returns the Subscription used or created to be\n\t         * added to the inner subscriptions list. This Subscription can be used with\n\t         * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t         * list.\n\t         */\n\t        Subscription.prototype.add = function (teardown) {\n\t            if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n\t                return;\n\t            }\n\t            var sub = teardown;\n\t            switch (typeof teardown) {\n\t                case 'function':\n\t                    sub = new Subscription(teardown);\n\t                case 'object':\n\t                    if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n\t                        break;\n\t                    }\n\t                    else if (this.isUnsubscribed) {\n\t                        sub.unsubscribe();\n\t                    }\n\t                    else {\n\t                        (this._subscriptions || (this._subscriptions = [])).push(sub);\n\t                    }\n\t                    break;\n\t                default:\n\t                    throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n\t            }\n\t            return sub;\n\t        };\n\t        /**\n\t         * Removes a Subscription from the internal list of subscriptions that will\n\t         * unsubscribe during the unsubscribe process of this Subscription.\n\t         * @param {Subscription} subscription The subscription to remove.\n\t         * @return {void}\n\t         */\n\t        Subscription.prototype.remove = function (subscription) {\n\t            // HACK: This might be redundant because of the logic in `add()`\n\t            if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t                return;\n\t            }\n\t            var subscriptions = this._subscriptions;\n\t            if (subscriptions) {\n\t                var subscriptionIndex = subscriptions.indexOf(subscription);\n\t                if (subscriptionIndex !== -1) {\n\t                    subscriptions.splice(subscriptionIndex, 1);\n\t                }\n\t            }\n\t        };\n\t        Subscription.EMPTY = (function (empty) {\n\t            empty.isUnsubscribed = true;\n\t            return empty;\n\t        }(new Subscription()));\n\t        return Subscription;\n\t    }());\n\t    exports.Subscription = Subscription;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=isArray.js.map\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    function isObject(x) {\n\t        return x != null && typeof x === 'object';\n\t    }\n\t    exports.isObject = isObject;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=isObject.js.map\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(56)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, errorObject_1) {\n\t    \"use strict\";\n\t    var tryCatchTarget;\n\t    function tryCatcher() {\n\t        try {\n\t            return tryCatchTarget.apply(this, arguments);\n\t        }\n\t        catch (e) {\n\t            errorObject_1.errorObject.e = e;\n\t            return errorObject_1.errorObject;\n\t        }\n\t    }\n\t    function tryCatch(fn) {\n\t        tryCatchTarget = fn;\n\t        return tryCatcher;\n\t    }\n\t    exports.tryCatch = tryCatch;\n\t    ;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    // typeof any so that it we don't have to cast when comparing a result to the error object\n\t    exports.errorObject = { e: {} };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=errorObject.js.map\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    /**\n\t     * An error thrown when one or more errors have occurred during the\n\t     * `unsubscribe` of a {@link Subscription}.\n\t     */\n\t    var UnsubscriptionError = (function (_super) {\n\t        __extends(UnsubscriptionError, _super);\n\t        function UnsubscriptionError(errors) {\n\t            _super.call(this);\n\t            this.errors = errors;\n\t            this.name = 'UnsubscriptionError';\n\t            this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n\t        }\n\t        return UnsubscriptionError;\n\t    }(Error));\n\t    exports.UnsubscriptionError = UnsubscriptionError;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(46)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, root_1) {\n\t    \"use strict\";\n\t    var Symbol = root_1.root.Symbol;\n\t    exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {\n\t    \"use strict\";\n\t    exports.empty = {\n\t        isUnsubscribed: true,\n\t        next: function (value) { },\n\t        error: function (err) { throw err; },\n\t        complete: function () { }\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t//# sourceMappingURL=Observer.js.map\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(62), __webpack_require__(25), __webpack_require__(23), __webpack_require__(61)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createAction_1 = __webpack_require__(62);\n\t    var lang_1 = __webpack_require__(25);\n\t    var array_1 = __webpack_require__(23);\n\t    var widgetStore_1 = __webpack_require__(61);\n\t    exports.updateHeaderAndFooter = createAction_1.default({\n\t        do: function (_a) {\n\t            var afterAll = _a.afterAll;\n\t            var completedCount = afterAll.filter(function (_a) {\n\t                var completed = _a.completed;\n\t                return completed;\n\t            }).length;\n\t            var activeCount = afterAll.length - completedCount;\n\t            var hidden = afterAll.length ? [] : ['hidden'];\n\t            var allCompleted = afterAll.length === completedCount;\n\t            return Promise.all([\n\t                widgetStore_1.default.patch({\n\t                    id: 'todo-footer',\n\t                    completedCount: completedCount,\n\t                    activeCount: activeCount,\n\t                    classes: ['footer'].concat(hidden)\n\t                }),\n\t                widgetStore_1.default.patch({\n\t                    id: 'todo-toggle',\n\t                    checked: allCompleted,\n\t                    classes: ['toggle-all'].concat(hidden)\n\t                })\n\t            ]);\n\t        }\n\t    });\n\t    exports.deleteTodo = createAction_1.default({\n\t        do: function (_a) {\n\t            var afterAll = _a.afterAll, deletes = _a.deletes;\n\t            if (deletes.length) {\n\t                var deletedId_1 = deletes[0];\n\t                var children = afterAll\n\t                    .filter(function (_a) {\n\t                    var id = _a.id;\n\t                    return id !== deletedId_1;\n\t                })\n\t                    .map(function (_a) {\n\t                    var id = _a.id;\n\t                    return id;\n\t                });\n\t                return widgetStore_1.default\n\t                    .delete(deletedId_1)\n\t                    .patch({ id: 'todo-list', children: children });\n\t            }\n\t        }\n\t    });\n\t    exports.putTodo = createAction_1.default({\n\t        do: function (_a) {\n\t            var beforeAll = _a.beforeAll, puts = _a.puts;\n\t            if (puts.length) {\n\t                var item = puts[0];\n\t                var children = beforeAll.map(function (_a) {\n\t                    var id = _a.id;\n\t                    return id;\n\t                });\n\t                if (array_1.includes(children, item.id)) {\n\t                    return widgetStore_1.default\n\t                        .patch(item)\n\t                        .patch({ id: 'todo-list', children: children });\n\t                }\n\t                return widgetStore_1.default\n\t                    .put(lang_1.assign({}, item, { type: 'todo-item' }))\n\t                    .patch({ id: 'todo-list', children: children.concat([item.id]) });\n\t            }\n\t        }\n\t    });\n\t});\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(44)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createMemoryStore_1 = __webpack_require__(44);\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createMemoryStore_1.default({\n\t        data: [\n\t            {\n\t                id: 'title',\n\t                label: 'todos'\n\t            },\n\t            {\n\t                id: 'new-todo',\n\t                classes: ['new-todo'],\n\t                focused: true,\n\t                placeholder: 'What needs to be done?'\n\t            },\n\t            {\n\t                id: 'main-section',\n\t                classes: ['main']\n\t            },\n\t            {\n\t                id: 'todo-list',\n\t                classes: ['todo-list'],\n\t                children: []\n\t            },\n\t            {\n\t                id: 'todo-toggle',\n\t                classes: ['toggle-all'],\n\t                checked: false\n\t            },\n\t            {\n\t                id: 'todo-footer',\n\t                classes: ['footer'],\n\t                completedCount: 0,\n\t                activeCount: 0,\n\t                activeFilter: 'all'\n\t            }\n\t        ]\n\t    });\n\t});\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(38), __webpack_require__(63), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var createStateful_1 = __webpack_require__(38);\n\t    var Task_1 = __webpack_require__(63);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    /**\n\t     * A type guard that validates the object passed is an Action\n\t     */\n\t    function isAction(value) {\n\t        return typeof value === 'object' && typeof value.do === 'function';\n\t    }\n\t    exports.isAction = isAction;\n\t    /**\n\t     * A weak map of `do` methods\n\t     */\n\t    var doFunctions = new WeakMap_1.default();\n\t    /**\n\t     * A weak map of `configure` methods\n\t     */\n\t    var configureFunctions = new WeakMap_1.default();\n\t    /**\n\t     * A factory which creates instances of Action\n\t     */\n\t    var createAction = compose_1.default({\n\t        do: function (options) {\n\t            var doFn = doFunctions.get(this);\n\t            if (doFn && this.state.enabled) {\n\t                var result = doFn.call(this, options);\n\t                return Task_1.isTask(result) ? result : Task_1.default.resolve(result);\n\t            }\n\t            return Task_1.default.resolve();\n\t        },\n\t        enable: function () {\n\t            if (!this.state.enabled) {\n\t                this.setState({ enabled: true });\n\t            }\n\t        },\n\t        disable: function () {\n\t            if (this.state.enabled) {\n\t                this.setState({ enabled: false });\n\t            }\n\t        },\n\t        configure: function (configuration) {\n\t            var configureFn = configureFunctions.get(this);\n\t            if (configureFn) {\n\t                return configureFn.call(this, configuration);\n\t            }\n\t        }\n\t    })\n\t        .mixin({\n\t        mixin: createStateful_1.default,\n\t        initialize: function (instance, _a) {\n\t            var doFn = _a.do, _b = _a.enabled, enabled = _b === void 0 ? true : _b, configure = _a.configure;\n\t            if (!doFn) {\n\t                throw new TypeError(\"'options.do' required during creation.\");\n\t            }\n\t            doFunctions.set(instance, doFn);\n\t            instance.setState({ enabled: enabled });\n\t            if (configure) {\n\t                configureFunctions.set(instance, configure);\n\t            }\n\t            instance.own({\n\t                destroy: function () {\n\t                    doFunctions.delete(instance);\n\t                    configureFunctions.delete(instance);\n\t                }\n\t            });\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createAction;\n\t});\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(64)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var ExtensiblePromise_1 = __webpack_require__(64);\n\t    /**\n\t     * A type guard that determines if `value` is a `Task`\n\t     * @param value The value to guard\n\t     */\n\t    function isTask(value) {\n\t        return Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n\t    }\n\t    exports.isTask = isTask;\n\t    /**\n\t     * Returns true if a given value has a `then` method.\n\t     * @param {any} value The value to check if is Thenable\n\t     * @returns {is Thenable<T>} A type guard if the value is thenable\n\t     */\n\t    function isThenable(value) {\n\t        return value && typeof value.then === 'function';\n\t    }\n\t    exports.isThenable = isThenable;\n\t    /**\n\t     * Task is an extension of Promise that supports cancellation and the Task#finally method.\n\t     */\n\t    var Task = (function (_super) {\n\t        __extends(Task, _super);\n\t        /**\n\t         * @constructor\n\t         *\n\t         * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t         *\n\t         * @param executor Method that initiates some task\n\t         * @param canceler Method to call when the task is canceled\n\t         *\n\t         */\n\t        function Task(executor, canceler) {\n\t            var _this = this;\n\t            _super.call(this, function (resolve, reject) {\n\t                // Don't let the Task resolve if it's been canceled\n\t                executor(function (value) {\n\t                    if (_this._state === 3 /* Canceled */) {\n\t                        return;\n\t                    }\n\t                    _this._state = 0 /* Fulfilled */;\n\t                    resolve(value);\n\t                }, function (reason) {\n\t                    if (_this._state === 3 /* Canceled */) {\n\t                        return;\n\t                    }\n\t                    _this._state = 2 /* Rejected */;\n\t                    reject(reason);\n\t                });\n\t            });\n\t            this._state = 1 /* Pending */;\n\t            this.children = [];\n\t            this.canceler = function () {\n\t                if (canceler) {\n\t                    canceler();\n\t                }\n\t                _this._cancel();\n\t            };\n\t        }\n\t        Task.resolve = function (value) {\n\t            return new this(function (resolve, reject) { return resolve(value); });\n\t        };\n\t        Object.defineProperty(Task.prototype, \"state\", {\n\t            get: function () {\n\t                return this._state;\n\t            },\n\t            enumerable: true,\n\t            configurable: true\n\t        });\n\t        /**\n\t         * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t         * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t         * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t         * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t         */\n\t        Task.prototype._cancel = function (finallyTask) {\n\t            var _this = this;\n\t            this._state = 3 /* Canceled */;\n\t            var runFinally = function () {\n\t                try {\n\t                    return _this._finally();\n\t                }\n\t                catch (error) {\n\t                }\n\t            };\n\t            if (this._finally) {\n\t                if (isThenable(finallyTask)) {\n\t                    finallyTask = finallyTask.then(runFinally, runFinally);\n\t                }\n\t                else {\n\t                    finallyTask = runFinally();\n\t                }\n\t            }\n\t            this.children.forEach(function (child) {\n\t                child._cancel(finallyTask);\n\t            });\n\t        };\n\t        /**\n\t         * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t         * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t         */\n\t        Task.prototype.cancel = function () {\n\t            if (this._state === 1 /* Pending */) {\n\t                this.canceler();\n\t            }\n\t        };\n\t        /**\n\t         * Allows for cleanup actions to be performed after resolution of a Promise.\n\t         */\n\t        Task.prototype.finally = function (callback) {\n\t            var task = this.then(function (value) { return Task.resolve(callback()).then(function () { return value; }); }, function (reason) { return Task.resolve(callback()).then(function () {\n\t                throw reason;\n\t            }); });\n\t            // Keep a reference to the callback; it will be called if the Task is canceled\n\t            task._finally = callback;\n\t            return task;\n\t        };\n\t        /**\n\t         * Adds a callback to be invoked when the Task resolves or is rejected.\n\t         *\n\t         * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t         * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t         *\n\t         * @returns {ExtensiblePromise}\n\t         */\n\t        Task.prototype.then = function (onFulfilled, onRejected) {\n\t            var _this = this;\n\t            // FIXME\n\t            // tslint:disable-next-line:no-var-keyword\n\t            var task = _super.prototype.then.call(this, \n\t            // Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t            function (value) {\n\t                if (task._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                if (onFulfilled) {\n\t                    return onFulfilled(value);\n\t                }\n\t                return value;\n\t            }, function (error) {\n\t                if (task._state === 3 /* Canceled */) {\n\t                    return;\n\t                }\n\t                if (onRejected) {\n\t                    return onRejected(error);\n\t                }\n\t                throw error;\n\t            });\n\t            task.canceler = function () {\n\t                // If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t                // unresolved parent\n\t                if (_this._state === 1 /* Pending */) {\n\t                    _this.cancel();\n\t                }\n\t                else {\n\t                    task._cancel();\n\t                }\n\t            };\n\t            // Keep track of child Tasks for propogating cancelation back down the chain\n\t            this.children.push(task);\n\t            return task;\n\t        };\n\t        return Task;\n\t    }(ExtensiblePromise_1.default));\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = Task;\n\t});\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(15), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var iterator_1 = __webpack_require__(15);\n\t    var Promise_1 = __webpack_require__(28);\n\t    /**\n\t     * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n\t     * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n\t     *\n\t     * @param iterable    The list of objects to iterate over\n\t     * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n\t     */\n\t    function unwrapPromises(iterable) {\n\t        var unwrapped = [];\n\t        iterator_1.forOf(iterable, function (item) {\n\t            unwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t        });\n\t        return unwrapped;\n\t    }\n\t    /**\n\t     * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n\t     * giving an API like a native promise.\n\t     */\n\t    var ExtensiblePromise = (function () {\n\t        /**\n\t         * Creates a new extended Promise.\n\t         *\n\t         * @constructor\n\t         *\n\t         * @param executor\n\t         * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t         * starting the asynchronous operation when it is invoked.\n\t         *\n\t         * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t         * successfully, or the `reject` function when the operation fails.\n\t         */\n\t        function ExtensiblePromise(executor) {\n\t            this._promise = new Promise_1.default(executor);\n\t        }\n\t        /**\n\t         * Return a rejected promise wrapped in an ExtensiblePromise\n\t         *\n\t         * @param {Error?} reason    The reason for the rejection\n\t         * @returns {ExtensiblePromise}\n\t         */\n\t        ExtensiblePromise.reject = function (reason) {\n\t            return new this(function (resolve, reject) { return reject(reason); });\n\t        };\n\t        ExtensiblePromise.resolve = function (value) {\n\t            return new this(function (resolve, reject) { return resolve(value); });\n\t        };\n\t        /**\n\t         * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved\n\t         *\n\t         * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t         * @returns {ExtensiblePromise}\n\t         */\n\t        ExtensiblePromise.all = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                Promise_1.default.all(unwrapPromises(iterable)).then(resolve, reject);\n\t            });\n\t        };\n\t        /**\n\t         * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t         *\n\t         * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t         * @returns {ExtensiblePromise}\n\t         */\n\t        ExtensiblePromise.race = function (iterable) {\n\t            return new this(function (resolve, reject) {\n\t                Promise_1.default.race(unwrapPromises(iterable)).then(resolve, reject);\n\t            });\n\t        };\n\t        ExtensiblePromise.prototype.catch = function (onRejected) {\n\t            return this.then(undefined, onRejected);\n\t        };\n\t        ExtensiblePromise.prototype.then = function (onFulfilled, onRejected) {\n\t            var _this = this;\n\t            var e = function (resolve, reject) {\n\t                function handler(rejected, valueOrError) {\n\t                    var callback = rejected ? onRejected : onFulfilled;\n\t                    if (typeof callback === 'function') {\n\t                        try {\n\t                            resolve(callback(valueOrError));\n\t                        }\n\t                        catch (error) {\n\t                            reject(error);\n\t                        }\n\t                    }\n\t                    else if (rejected) {\n\t                        reject(valueOrError);\n\t                    }\n\t                    else {\n\t                        resolve(valueOrError);\n\t                    }\n\t                }\n\t                _this._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t            };\n\t            return new this.constructor(e);\n\t        };\n\t        return ExtensiblePromise;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = ExtensiblePromise;\n\t});\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(38), __webpack_require__(31), __webpack_require__(28), __webpack_require__(22), __webpack_require__(36), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createStateful_1 = __webpack_require__(38);\n\t    var Map_1 = __webpack_require__(31);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var immutable_1 = __webpack_require__(36);\n\t    var lang_1 = __webpack_require__(35);\n\t    /**\n\t     * Map that holds state for manageChildren and manageChildrenState by widget instance.\n\t     */\n\t    var managementMap = new WeakMap_1.default();\n\t    /**\n\t     * Internal statechange listener which deals with managing the children when a state\n\t     * change occurs on the parent\n\t     *\n\t     * @param evt The state change event of the parent\n\t     */\n\t    function manageChildren(evt) {\n\t        var parent = evt.target;\n\t        /* Assume this function cannot be called without the widget being in the management map */\n\t        var internalState = managementMap.get(parent);\n\t        /* Initialize cache */\n\t        var _a = internalState.cache, cache = _a === void 0 ? new Map_1.default() : _a;\n\t        if (!internalState.cache) {\n\t            internalState.cache = cache;\n\t        }\n\t        /* Initialize current children IDs */\n\t        if (!internalState.current) {\n\t            internalState.current = immutable_1.List();\n\t        }\n\t        var currentChildrenIDs = evt.state.children ? immutable_1.List(evt.state.children) : immutable_1.List();\n\t        if (currentChildrenIDs.equals(internalState.current)) {\n\t            /* There are no changes to the children */\n\t            return;\n\t        }\n\t        // Increment the generation vector. Used when children are replaced asynchronously to ensure\n\t        // no newer state is overriden.\n\t        var generation = ++internalState.generation;\n\t        internalState.current = currentChildrenIDs;\n\t        var resolvingWidgets = [];\n\t        /* Sometimes we are dealing with children that are a list, somtimes, a Map */\n\t        var childrenList = [];\n\t        var childrenMap = {};\n\t        var childrenIsList = lang_1.isList(parent.children);\n\t        /* Iterate through children ids, retrieving reference to widget or otherwise\n\t         * requesting the widget from the registry */\n\t        currentChildrenIDs.forEach(function (id, key) {\n\t            // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t            // istanbul ignore else\n\t            if (id !== undefined && key !== undefined) {\n\t                if (cache.has(id)) {\n\t                    if (childrenIsList) {\n\t                        childrenList[key] = cache.get(id);\n\t                    }\n\t                    else {\n\t                        childrenMap[id] = cache.get(id);\n\t                    }\n\t                }\n\t                else {\n\t                    var widgetPromise = internalState.registry.has(id).then(function (exists) {\n\t                        if (exists) {\n\t                            return internalState.registry.get(id);\n\t                        }\n\t                    });\n\t                    /* Tuple of Promise, child ID, position in child list */\n\t                    resolvingWidgets.push([widgetPromise, id, key]);\n\t                }\n\t            }\n\t        });\n\t        /* If we have requests for widgets outstanding, we need to wait for them to be\n\t         * resolved and then populate them in the children */\n\t        if (resolvingWidgets.length) {\n\t            Promise_1.default.all(resolvingWidgets.map(function (_a) {\n\t                var promise = _a[0];\n\t                return promise;\n\t            }))\n\t                .then(function (widgets) {\n\t                /* Only replace children if there is no newer state that either already has, or soon will,\n\t                 * replace the original listeners. */\n\t                if (internalState.generation !== generation) {\n\t                    return;\n\t                }\n\t                widgets.forEach(function (widget, idx) {\n\t                    var _a = resolvingWidgets[idx], id = _a[1], key = _a[2];\n\t                    if (widget) {\n\t                        if (childrenIsList) {\n\t                            childrenList[key] = widget;\n\t                        }\n\t                        else {\n\t                            childrenMap[id] = widget;\n\t                        }\n\t                        cache.set(id, widget);\n\t                        widget.own({\n\t                            destroy: function () {\n\t                                cache.delete(id);\n\t                            }\n\t                        });\n\t                    }\n\t                    else {\n\t                        if (childrenIsList) {\n\t                            childrenList.splice(key, 1);\n\t                        }\n\t                    }\n\t                });\n\t                /* Some parents have a List, some have a Map, so setting them varies */\n\t                parent.children = lang_1.isList(parent.children) ? immutable_1.List(childrenList) : immutable_1.Map(childrenMap);\n\t            }, function (error) {\n\t                /* A promise got rejected for some reason */\n\t                parent.emit({\n\t                    type: 'error',\n\t                    target: parent,\n\t                    error: error\n\t                });\n\t            });\n\t        }\n\t        else {\n\t            /* Otherwise we can just set the children */\n\t            parent.children = lang_1.isList(parent.children) ? immutable_1.List(childrenList) : immutable_1.Map(childrenMap);\n\t        }\n\t    }\n\t    /**\n\t     * Internal function to manage the state of the children when a child list event occurs\n\t     *\n\t     * @param evt The child list event from the parent\n\t     */\n\t    function manageChildrenState(evt) {\n\t        var parent = evt.target;\n\t        /* Assume this function cannot be called without the widget being in the management map */\n\t        var registry = managementMap.get(parent).registry;\n\t        var evtChildren = evt.children;\n\t        var currentChildrenIDs;\n\t        if (lang_1.isList(evtChildren)) {\n\t            currentChildrenIDs = evtChildren.map(function (widget) {\n\t                // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                // istanbul ignore else\n\t                if (widget) {\n\t                    return registry.identify(widget);\n\t                }\n\t            });\n\t        }\n\t        else {\n\t            currentChildrenIDs = immutable_1.List(evtChildren.keys());\n\t        }\n\t        var storedChildren = parent.state.children ? immutable_1.List(parent.state.children) : immutable_1.List();\n\t        if (!currentChildrenIDs.equals(storedChildren)) {\n\t            var children = currentChildrenIDs.toArray();\n\t            parent.setState({ children: children });\n\t        }\n\t    }\n\t    function isCreateChildrenMap(value) {\n\t        return typeof value === 'object' && !Array.isArray(value);\n\t    }\n\t    var createStatefulChildrenMixin = createStateful_1.default\n\t        .mixin({\n\t        mixin: {\n\t            createChildren: function (children) {\n\t                var _this = this;\n\t                if (managementMap.has(this)) {\n\t                    var management_1 = managementMap.get(this);\n\t                    var registry_1 = management_1.registry, id_1 = management_1.id;\n\t                    if (isCreateChildrenMap(children)) {\n\t                        /* Because we have a map, but Promise.all only takes an array, we have to \"flatten\" the map into\n\t                        * two arrays, of promises and labels */\n\t                        var promises = [];\n\t                        var labels_1 = [];\n\t                        for (var label in children) {\n\t                            var _a = children[label], factory = _a.factory, _b = _a.options, options = _b === void 0 ? {} : _b;\n\t                            if (!options.id) {\n\t                                /* See createChild for explination of this logic */\n\t                                options.id = (id_1 || this.id) + \"-child-\" + ++management_1.childrenUID;\n\t                            }\n\t                            promises.push(registry_1.create(factory, options));\n\t                            labels_1.push(label);\n\t                        }\n\t                        return Promise_1.default\n\t                            .all(promises)\n\t                            .then(function (items) {\n\t                            /* create a handle which will destroy the children created */\n\t                            var instances = items.map(function (_a) {\n\t                                var child = _a[1];\n\t                                return child;\n\t                            });\n\t                            _this.own({\n\t                                destroy: function () {\n\t                                    return instances.map(function (instance) { return instance.destroy(); });\n\t                                }\n\t                            });\n\t                            /* Now we need to constitute our map to return it */\n\t                            var results = {};\n\t                            var newChildren = items.map(function (_a, idx) {\n\t                                var id = _a[0], widget = _a[1];\n\t                                results[labels_1[idx]] = { id: id, widget: widget };\n\t                                return id;\n\t                            });\n\t                            var children = _this.state.children ? _this.state.children.concat(newChildren) : newChildren;\n\t                            _this.setState({ children: children });\n\t                            return results;\n\t                        });\n\t                    }\n\t                    else {\n\t                        return Promise_1.default\n\t                            .all(children.map(function (_a) {\n\t                            var factory = _a[0], options = _a[1];\n\t                            if (!options.id) {\n\t                                /* depending upon the construction lifecycle, the this.id may not have been properly set and will\n\t                                * auto-generate an ID, therefore we have copied the ID out of options, if it was present and will\n\t                                * use that as a base for autogenerating the child widget's ID */\n\t                                options.id = (id_1 || _this.id) + \"-child-\" + ++management_1.childrenUID;\n\t                            }\n\t                            return registry_1.create(factory, options);\n\t                        }))\n\t                            .then(function (items) {\n\t                            /* create a handle which will destroy the children created */\n\t                            var instances = items.map(function (_a) {\n\t                                var child = _a[1];\n\t                                return child;\n\t                            });\n\t                            _this.own({\n\t                                destroy: function () {\n\t                                    return instances.map(function (instance) { return instance.destroy(); });\n\t                                }\n\t                            });\n\t                            var newChildren = items.map(function (_a) {\n\t                                var id = _a[0];\n\t                                return id;\n\t                            });\n\t                            var children = _this.state.children ? _this.state.children.concat(newChildren) : newChildren;\n\t                            _this.setState({ children: children });\n\t                            return items;\n\t                        });\n\t                    }\n\t                }\n\t                return Promise_1.default.reject(new Error('Unable to resolve registry'));\n\t            },\n\t            createChild: function (factory, options) {\n\t                if (options === void 0) { options = {}; }\n\t                return this.createChildren([[factory, options]]).then(function (_a) {\n\t                    var tuple = _a[0];\n\t                    return tuple;\n\t                });\n\t            }\n\t        },\n\t        initialize: function (instance, _a) {\n\t            var _b = _a === void 0 ? {} : _a, registryProvider = _b.registryProvider, id = _b.id, state = _b.state;\n\t            if (registryProvider) {\n\t                var registry = registryProvider.get('widgets');\n\t                managementMap.set(instance, {\n\t                    registry: registry,\n\t                    generation: 0,\n\t                    childrenUID: 0,\n\t                    id: id\n\t                });\n\t                instance.own(instance.on('statechange', manageChildren));\n\t                instance.own(instance.on('childlist', manageChildrenState));\n\t                /* Stateful will have already fired the statechange event at this point */\n\t                if (state) {\n\t                    instance.setState(state);\n\t                }\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createStatefulChildrenMixin;\n\t});\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(22), __webpack_require__(34), __webpack_require__(39), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var createFormFieldMixin_1 = __webpack_require__(34);\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createVNodeEvented_1 = __webpack_require__(7);\n\t    var afterUpdateFunctions = new WeakMap_1.default();\n\t    function afterUpdate(instance, element) {\n\t        var focused = instance.state.focused;\n\t        if (focused) {\n\t            setTimeout(function () { return element.focus(); }, 0);\n\t        }\n\t        else if (!focused && document.activeElement === element) {\n\t            element.blur();\n\t        }\n\t    }\n\t    var createFocusableTextInput = createRenderMixin_1.default\n\t        .mixin(createFormFieldMixin_1.default)\n\t        .mixin({\n\t        mixin: createVNodeEvented_1.default,\n\t        initialize: function (instance) {\n\t            instance.own(instance.on('input', function (event) {\n\t                instance.value = event.target.value;\n\t            }));\n\t            afterUpdateFunctions.set(instance, function (element) { return afterUpdate(instance, element); });\n\t        }\n\t    })\n\t        .extend({\n\t        nodeAttributes: [\n\t            function () {\n\t                var afterUpdate = afterUpdateFunctions.get(this);\n\t                var placeholder = this.state.placeholder;\n\t                return { afterUpdate: afterUpdate, placeholder: placeholder };\n\t            }\n\t        ],\n\t        tagName: 'input',\n\t        type: 'text'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createFocusableTextInput;\n\t});\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(39), __webpack_require__(7), __webpack_require__(34), __webpack_require__(68)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createVNodeEvented_1 = __webpack_require__(7);\n\t    var createFormFieldMixin_1 = __webpack_require__(34);\n\t    var Button_1 = __webpack_require__(68);\n\t    var createButton = createRenderMixin_1.default\n\t        .mixin(createFormFieldMixin_1.default)\n\t        .mixin(createVNodeEvented_1.default)\n\t        .extend({\n\t        tagName: 'button',\n\t        type: 'button',\n\t        classes: [Button_1.default.button]\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createButton;\n\t});\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = { \"button\": \"_button_ng9vr_1\" };\n\t});\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(67), __webpack_require__(71), __webpack_require__(39), __webpack_require__(65), __webpack_require__(40), __webpack_require__(41), __webpack_require__(70)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createButton_1 = __webpack_require__(67);\n\t    var createParentMapMixin_1 = __webpack_require__(71);\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createStatefulChildrenMixin_1 = __webpack_require__(65);\n\t    var maquette_1 = __webpack_require__(40);\n\t    var userActions_1 = __webpack_require__(41);\n\t    var createTodoFilter_1 = __webpack_require__(70);\n\t    function manageChildren() {\n\t        var filterWidget = this.children.get('filter');\n\t        var buttonWidget = this.children.get('button');\n\t        filterWidget.setState({\n\t            activeFilter: this.state.activeFilter\n\t        });\n\t        var clearCompletedButtonClasses = ['clear-completed'];\n\t        if (this.state.completedCount === 0) {\n\t            clearCompletedButtonClasses.push('hidden');\n\t        }\n\t        buttonWidget.setState({\n\t            classes: clearCompletedButtonClasses\n\t        });\n\t    }\n\t    var createTodoFooter = createRenderMixin_1.default\n\t        .mixin(createStatefulChildrenMixin_1.default)\n\t        .mixin({\n\t        mixin: createParentMapMixin_1.default,\n\t        initialize: function (instance, options) {\n\t            var filterWidget = createTodoFilter_1.default({\n\t                state: {\n\t                    id: 'filter',\n\t                    classes: ['filters']\n\t                }\n\t            });\n\t            var clearCompletedButton = createButton_1.default({\n\t                state: {\n\t                    id: 'button',\n\t                    label: 'Clear completed',\n\t                    classes: ['clear-completed']\n\t                },\n\t                listeners: {\n\t                    click: userActions_1.clearCompleted\n\t                }\n\t            });\n\t            instance.append([filterWidget, clearCompletedButton]);\n\t            instance.on('statechange', manageChildren);\n\t        }\n\t    })\n\t        .extend({\n\t        getChildrenNodes: function () {\n\t            var activeCount = this.state.activeCount;\n\t            var countLabel = activeCount === 1 ? 'item' : 'items';\n\t            return [\n\t                maquette_1.h('span', { 'class': 'todo-count' }, [\n\t                    maquette_1.h('strong', [activeCount + ' ']),\n\t                    maquette_1.h('span', [countLabel + ' left'])\n\t                ]),\n\t                this.children.get('filter').render(),\n\t                this.children.get('button').render()\n\t            ];\n\t        },\n\t        tagName: 'footer'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createTodoFooter;\n\t});\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(39), __webpack_require__(40)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var maquette_1 = __webpack_require__(40);\n\t    var createTodoFilter = createRenderMixin_1.default\n\t        .extend({\n\t        getChildrenNodes: function () {\n\t            var activeFilter = this.state.activeFilter;\n\t            return [\n\t                maquette_1.h('li', {}, [\n\t                    maquette_1.h('a', {\n\t                        innerHTML: 'All',\n\t                        href: '#all',\n\t                        classes: {\n\t                            selected: activeFilter === 'all'\n\t                        }\n\t                    })\n\t                ]),\n\t                maquette_1.h('li', {}, [\n\t                    maquette_1.h('a', {\n\t                        innerHTML: 'Active',\n\t                        href: '#active',\n\t                        classes: {\n\t                            selected: activeFilter === 'active'\n\t                        }\n\t                    })\n\t                ]),\n\t                maquette_1.h('li', {}, [\n\t                    maquette_1.h('a', {\n\t                        innerHTML: 'Completed',\n\t                        href: '#completed',\n\t                        classes: {\n\t                            selected: activeFilter === 'completed'\n\t                        }\n\t                    })\n\t                ])\n\t            ];\n\t        },\n\t        tagName: 'ul'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createTodoFilter;\n\t});\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(36), __webpack_require__(20), __webpack_require__(18), __webpack_require__(22), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var immutable_1 = __webpack_require__(36);\n\t    var compose_1 = __webpack_require__(20);\n\t    var createEvented_1 = __webpack_require__(18);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var lang_1 = __webpack_require__(35);\n\t    var childrenMap = new WeakMap_1.default();\n\t    /**\n\t     * Function that resolves the key for the children map for a given child\n\t     * @param parent The parent that the child will be mapped to\n\t     * @param child The child that is being mapped\n\t     */\n\t    function getChildKey(parent, child) {\n\t        return child.id || 'child' + parent.children.size;\n\t    }\n\t    /**\n\t     * Function that converts an array of children into a map of children\n\t     * @param parent The parent that the children will be mapped to\n\t     * @param children An array of children to be mapped to the parent\n\t     */\n\t    function mapChildArray(parent, children) {\n\t        var childMap = {};\n\t        var keyCount = parent.children.size;\n\t        /* TODO: in theory, if children are added, then removed and then added again, duplicate keys could\n\t         * be generated*/\n\t        children.forEach(function (child) { return childMap[child.id || 'child' + keyCount++] = child; });\n\t        return childMap;\n\t    }\n\t    var createParentMapMixin = compose_1.default({\n\t        get children() {\n\t            return childrenMap.get(this);\n\t        },\n\t        set children(value) {\n\t            var _this = this;\n\t            if (!value.equals(childrenMap.get(this))) {\n\t                value.forEach(function (widget) {\n\t                    // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                    // istanbul ignore else\n\t                    if (widget) {\n\t                        if (widget.parent !== _this) {\n\t                            widget.parent = _this;\n\t                            /* TODO: If a child gets attached and reattached it may own multiple handles */\n\t                            lang_1.getRemoveHandle(_this, widget);\n\t                        }\n\t                    }\n\t                });\n\t                childrenMap.set(this, value);\n\t                this.emit({\n\t                    type: 'childlist',\n\t                    target: this,\n\t                    children: value\n\t                });\n\t                if (this.invalidate) {\n\t                    this.invalidate();\n\t                }\n\t            }\n\t        },\n\t        append: function (child) {\n\t            this.children = Array.isArray(child) ?\n\t                this.children.merge(mapChildArray(this, child)) :\n\t                this.children.set(getChildKey(this, child), child);\n\t            return lang_1.getRemoveHandle(this, child);\n\t        },\n\t        merge: function (children) {\n\t            this.children = this.children.merge(children);\n\t            return lang_1.getRemoveHandle(this, children);\n\t        },\n\t        clear: function () {\n\t            this.children = immutable_1.Map();\n\t        }\n\t    })\n\t        .mixin({\n\t        mixin: createEvented_1.default,\n\t        initialize: function (instance, options) {\n\t            childrenMap.set(instance, immutable_1.Map());\n\t            if (options && options.children) {\n\t                instance.own(instance.merge(options.children));\n\t            }\n\t            instance.own({\n\t                destroy: function () {\n\t                    var children = childrenMap.get(instance);\n\t                    children.forEach(function (child) {\n\t                        // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                        // istanbul ignore else\n\t                        if (child) {\n\t                            child.destroy();\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createParentMapMixin;\n\t});\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(78), __webpack_require__(75), __webpack_require__(73), __webpack_require__(41)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createRoute_1 = __webpack_require__(78);\n\t    var createRouter_1 = __webpack_require__(75);\n\t    var createHashHistory_1 = __webpack_require__(73);\n\t    var userActions_1 = __webpack_require__(41);\n\t    var filterRoute = createRoute_1.default({\n\t        path: '/{filter}',\n\t        params: function (_a) {\n\t            var filter = _a[0];\n\t            switch (filter) {\n\t                case 'active':\n\t                    return { filter: 'active' };\n\t                case 'all':\n\t                    return { filter: 'all' };\n\t                case 'completed':\n\t                    return { filter: 'completed' };\n\t                default:\n\t                    return null;\n\t            }\n\t        },\n\t        exec: function (request) {\n\t            var filter = request.params.filter;\n\t            return userActions_1.filter.do({ filter: filter });\n\t        }\n\t    });\n\t    var router = createRouter_1.default({ history: createHashHistory_1.default() });\n\t    router.append(filterRoute);\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = router;\n\t});\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(18), __webpack_require__(27), __webpack_require__(74), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var createEvented_1 = __webpack_require__(18);\n\t    var global_1 = __webpack_require__(27);\n\t    var on_1 = __webpack_require__(74);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var privateStateMap = new WeakMap_1.default();\n\t    var createHashHistory = compose_1.default.mixin(createEvented_1.default, {\n\t        mixin: {\n\t            get current() {\n\t                return privateStateMap.get(this).current;\n\t            },\n\t            prefix: function (path) {\n\t                return \"#\" + path;\n\t            },\n\t            set: function (path) {\n\t                var privateState = privateStateMap.get(this);\n\t                if (privateState.current === path) {\n\t                    return;\n\t                }\n\t                privateState.current = path;\n\t                privateState.browserLocation.hash = this.prefix(path);\n\t                this.emit({\n\t                    type: 'change',\n\t                    value: path\n\t                });\n\t            },\n\t            replace: function (path) {\n\t                var privateState = privateStateMap.get(this);\n\t                if (privateState.current === path) {\n\t                    return;\n\t                }\n\t                privateState.current = path;\n\t                var _a = privateState.browserLocation, pathname = _a.pathname, search = _a.search;\n\t                privateState.browserLocation.replace(pathname + search + this.prefix(path));\n\t                this.emit({\n\t                    type: 'change',\n\t                    value: path\n\t                });\n\t            }\n\t        },\n\t        initialize: function (instance, _a) {\n\t            var window = (_a === void 0 ? { window: global_1.default } : _a).window;\n\t            var browserLocation = window.location;\n\t            var privateState = {\n\t                current: browserLocation.hash.slice(1),\n\t                browserLocation: browserLocation\n\t            };\n\t            privateStateMap.set(instance, privateState);\n\t            instance.own(on_1.default(window, 'hashchange', function () {\n\t                var path = browserLocation.hash.slice(1);\n\t                // Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n\t                // manager sets the hash.\n\t                if (path !== privateState.current) {\n\t                    privateState.current = path;\n\t                    instance.emit({\n\t                        type: 'change',\n\t                        value: path\n\t                    });\n\t                }\n\t            }));\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createHashHistory;\n\t});\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(25)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var lang_1 = __webpack_require__(25);\n\t    function emit(target, event) {\n\t        if (target.dispatchEvent &&\n\t            ((target.ownerDocument && target.ownerDocument.createEvent) ||\n\t                (target.document && target.document.createEvent) ||\n\t                target.createEvent) /* matches document */) {\n\t            var nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n\t            nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));\n\t            for (var key in event) {\n\t                if (!(key in nativeEvent)) {\n\t                    nativeEvent[key] = event[key];\n\t                }\n\t            }\n\t            return target.dispatchEvent(nativeEvent);\n\t        }\n\t        if (target.emit) {\n\t            if (target.removeListener) {\n\t                // Node.js EventEmitter\n\t                target.emit(event.type, event);\n\t                return false;\n\t            }\n\t            else if (target.on) {\n\t                // Dojo Evented or similar\n\t                target.emit(event);\n\t                return false;\n\t            }\n\t        }\n\t        throw new Error('Target must be an event emitter');\n\t    }\n\t    exports.emit = emit;\n\t    function on(target, type, listener, capture) {\n\t        if (Array.isArray(type)) {\n\t            var handles = type.map(function (type) {\n\t                return on(target, type, listener, capture);\n\t            });\n\t            return lang_1.createCompositeHandle.apply(void 0, handles);\n\t        }\n\t        var callback = function () {\n\t            listener.apply(this, arguments);\n\t        };\n\t        // DOM EventTarget\n\t        if (target.addEventListener && target.removeEventListener) {\n\t            target.addEventListener(type, callback, capture);\n\t            return lang_1.createHandle(function () {\n\t                target.removeEventListener(type, callback, capture);\n\t            });\n\t        }\n\t        if (target.on) {\n\t            // EventEmitter\n\t            if (target.removeListener) {\n\t                target.on(type, callback);\n\t                return lang_1.createHandle(function () {\n\t                    target.removeListener(type, callback);\n\t                });\n\t            }\n\t            else if (target.emit) {\n\t                return target.on(type, listener);\n\t            }\n\t        }\n\t        throw new TypeError('Unknown event emitter object');\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = on;\n\t    function once(target, type, listener, capture) {\n\t        // FIXME\n\t        // tslint:disable-next-line:no-var-keyword\n\t        var handle = on(target, type, function () {\n\t            handle.destroy();\n\t            return listener.apply(this, arguments);\n\t        }, capture);\n\t        return handle;\n\t    }\n\t    exports.once = once;\n\t    function pausable(target, type, listener, capture) {\n\t        var paused;\n\t        var handle = on(target, type, function () {\n\t            if (!paused) {\n\t                return listener.apply(this, arguments);\n\t            }\n\t        }, capture);\n\t        handle.pause = function () {\n\t            paused = true;\n\t        };\n\t        handle.resume = function () {\n\t            paused = false;\n\t        };\n\t        return handle;\n\t    }\n\t    exports.pausable = pausable;\n\t});\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(18), __webpack_require__(63), __webpack_require__(74), __webpack_require__(76), __webpack_require__(23), __webpack_require__(28), __webpack_require__(22), __webpack_require__(77)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var createEvented_1 = __webpack_require__(18);\n\t    var Task_1 = __webpack_require__(63);\n\t    var on_1 = __webpack_require__(74);\n\t    var UrlSearchParams_1 = __webpack_require__(76);\n\t    var array_1 = __webpack_require__(23);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var path_1 = __webpack_require__(77);\n\t    var parentMap = new WeakMap_1.default();\n\t    function hasBeenAppended(route) {\n\t        return parentMap.has(route) || route.parent !== undefined;\n\t    }\n\t    exports.hasBeenAppended = hasBeenAppended;\n\t    var privateStateMap = new WeakMap_1.default();\n\t    // istanbul ignore next\n\t    var noop = function () { };\n\t    function createDeferral() {\n\t        // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n\t        var cancel = noop;\n\t        var resume = noop;\n\t        var promise = new Promise_1.default(function (resolve, reject) {\n\t            cancel = reject;\n\t            // Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n\t            resume = function () { return resolve(); };\n\t        });\n\t        return { cancel: cancel, promise: promise, resume: resume };\n\t    }\n\t    function reportError(router, context, path, error) {\n\t        router.emit({\n\t            context: context,\n\t            error: error,\n\t            path: path,\n\t            target: router,\n\t            type: 'error'\n\t        });\n\t    }\n\t    function catchRejection(router, context, path, thenable) {\n\t        if (thenable) {\n\t            Promise_1.default.resolve(thenable).catch(function (error) {\n\t                reportError(router, context, path, error);\n\t            });\n\t        }\n\t    }\n\t    var createRouter = compose_1.default.mixin(createEvented_1.default, {\n\t        mixin: {\n\t            append: function (add) {\n\t                var _this = this;\n\t                var routes = privateStateMap.get(this).routes;\n\t                var append = function (route) {\n\t                    if (hasBeenAppended(route)) {\n\t                        throw new Error('Cannot append route that has already been appended');\n\t                    }\n\t                    routes.push(route);\n\t                    parentMap.set(route, _this);\n\t                };\n\t                if (Array.isArray(add)) {\n\t                    for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                        var route = add_1[_i];\n\t                        append(route);\n\t                    }\n\t                }\n\t                else {\n\t                    append(add);\n\t                }\n\t            },\n\t            dispatch: function (context, path) {\n\t                var _this = this;\n\t                var state = privateStateMap.get(this);\n\t                var dispatchFromStart = state.dispatchFromStart;\n\t                // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n\t                // may call dispatch() themselves.\n\t                state.dispatchFromStart = false;\n\t                var canceled = false;\n\t                var cancel = function () {\n\t                    canceled = true;\n\t                };\n\t                var deferrals = [];\n\t                this.emit({\n\t                    cancel: cancel,\n\t                    defer: function () {\n\t                        var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;\n\t                        deferrals.push(promise);\n\t                        return { cancel: cancel, resume: resume };\n\t                    },\n\t                    path: path,\n\t                    target: this,\n\t                    type: 'navstart'\n\t                });\n\t                // Synchronous cancelation.\n\t                if (canceled) {\n\t                    return Task_1.default.resolve({ success: false });\n\t                }\n\t                var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;\n\t                return new Task_1.default(function (resolve, reject) {\n\t                    // *Always* start dispatching in a future turn, even if there were no deferrals.\n\t                    Promise_1.default.all(deferrals).then(function () {\n\t                        // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n\t                        // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n\t                        // manages to do so before this turn.\n\t                        if (canceled) {\n\t                            return { success: false };\n\t                        }\n\t                        var fallback = state.fallback, routes = state.routes;\n\t                        var redirect;\n\t                        var dispatched = routes.some(function (route) {\n\t                            var result = route.select(context, segments, trailingSlash, searchParams);\n\t                            if (typeof result === 'string') {\n\t                                redirect = result;\n\t                                return true;\n\t                            }\n\t                            if (result.length === 0) {\n\t                                return false;\n\t                            }\n\t                            // Update the selected routes after selecting new routes, but before invoking the handlers.\n\t                            // This means the original value is available to guard() and params() functions, and the\n\t                            // new value when the newly selected routes are executed.\n\t                            //\n\t                            // Reset selected routes if not dispatched from start().\n\t                            state.currentSelection = dispatchFromStart ? result : [];\n\t                            for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {\n\t                                var _a = result_1[_i], handler = _a.handler, params = _a.params;\n\t                                catchRejection(_this, context, path, handler({ context: context, params: params }));\n\t                            }\n\t                            return true;\n\t                        });\n\t                        // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n\t                        if (!dispatched || redirect !== undefined) {\n\t                            state.currentSelection = [];\n\t                        }\n\t                        if (!dispatched && fallback) {\n\t                            catchRejection(_this, context, path, fallback({ context: context, params: {} }));\n\t                            return { success: false };\n\t                        }\n\t                        var result = { success: dispatched };\n\t                        if (redirect !== undefined) {\n\t                            result.redirect = redirect;\n\t                        }\n\t                        return result;\n\t                    }, \n\t                    // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n\t                    // with `false` instead of being rejected too.\n\t                    function () {\n\t                        return { success: false };\n\t                    }).then(resolve, function (error) {\n\t                        reportError(_this, context, path, error);\n\t                        reject(error);\n\t                    });\n\t                }, cancel);\n\t            },\n\t            link: function (route, params) {\n\t                if (params === void 0) { params = {}; }\n\t                var _a = privateStateMap.get(this), history = _a.history, roots = _a.routes, currentSelection = _a.currentSelection;\n\t                var hierarchy = [route];\n\t                for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {\n\t                    hierarchy.unshift(parent_1);\n\t                }\n\t                if (!array_1.includes(roots, hierarchy[0])) {\n\t                    throw new Error('Cannot generate link for route that is not in the hierarchy');\n\t                }\n\t                var addLeadingSlash = hierarchy[0].path.leadingSlash;\n\t                var addTrailingSlash = false;\n\t                var segments = [];\n\t                var searchParams = new UrlSearchParams_1.default();\n\t                hierarchy\n\t                    .map(function (route, index) {\n\t                    var path = route.path;\n\t                    var currentPathValues;\n\t                    var currentSearchParams;\n\t                    var selection = currentSelection[index];\n\t                    if (selection && selection.route === route) {\n\t                        currentPathValues = selection.rawPathValues;\n\t                        currentSearchParams = selection.rawSearchParams;\n\t                    }\n\t                    return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };\n\t                })\n\t                    .forEach(function (_a) {\n\t                    var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;\n\t                    var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;\n\t                    addTrailingSlash = trailingSlash;\n\t                    var namedOffset = 0;\n\t                    for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {\n\t                        var segment = expectedSegments_1[_i];\n\t                        if (path_1.isNamedSegment(segment)) {\n\t                            var value = params[segment.name];\n\t                            if (typeof value === 'string') {\n\t                                segments.push(value);\n\t                            }\n\t                            else if (Array.isArray(value)) {\n\t                                if (value.length === 1) {\n\t                                    segments.push(value[0]);\n\t                                }\n\t                                else {\n\t                                    throw new TypeError(\"Cannot generate link, multiple values for parameter '\" + segment.name + \"'\");\n\t                                }\n\t                            }\n\t                            else if (currentPathValues) {\n\t                                segments.push(currentPathValues[namedOffset]);\n\t                            }\n\t                            else {\n\t                                throw new Error(\"Cannot generate link, missing parameter '\" + segment.name + \"'\");\n\t                            }\n\t                            namedOffset++;\n\t                        }\n\t                        else {\n\t                            segments.push(segment.literal);\n\t                        }\n\t                    }\n\t                    for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {\n\t                        var key = searchParameters_1[_b];\n\t                        // Don't repeat the search parameter if a previous route in the hierarchy has already appended\n\t                        // it.\n\t                        if (searchParams.has(key)) {\n\t                            continue;\n\t                        }\n\t                        var value = params[key];\n\t                        if (typeof value === 'string') {\n\t                            searchParams.append(key, value);\n\t                        }\n\t                        else if (Array.isArray(value)) {\n\t                            for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {\n\t                                var item = value_1[_c];\n\t                                searchParams.append(key, item);\n\t                            }\n\t                        }\n\t                        else if (currentSearchParams) {\n\t                            for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {\n\t                                var item = _e[_d];\n\t                                searchParams.append(key, item);\n\t                            }\n\t                        }\n\t                        else {\n\t                            throw new Error(\"Cannot generate link, missing search parameter '\" + key + \"'\");\n\t                        }\n\t                    }\n\t                });\n\t                var pathname = segments.join('/');\n\t                if (addLeadingSlash) {\n\t                    pathname = '/' + pathname;\n\t                }\n\t                if (addTrailingSlash) {\n\t                    pathname += '/';\n\t                }\n\t                if (history) {\n\t                    pathname = history.prefix(pathname);\n\t                }\n\t                var search = searchParams.toString();\n\t                var path = search ? pathname + \"?\" + search : pathname;\n\t                return path;\n\t            },\n\t            start: function (_a) {\n\t                var _this = this;\n\t                var dispatchCurrent = (_a === void 0 ? { dispatchCurrent: true } : _a).dispatchCurrent;\n\t                var state = privateStateMap.get(this);\n\t                if (state.started) {\n\t                    throw new Error('start can only be called once');\n\t                }\n\t                state.started = true;\n\t                var contextFactory = state.contextFactory, history = state.history;\n\t                if (!history) {\n\t                    return {\n\t                        pause: function () { },\n\t                        resume: function () { },\n\t                        destroy: function () { }\n\t                    };\n\t                }\n\t                var lastDispatch;\n\t                var redirectCount = 0;\n\t                var redirecting = false;\n\t                var dispatch = function (path) {\n\t                    if (lastDispatch) {\n\t                        lastDispatch.cancel();\n\t                    }\n\t                    // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n\t                    // a route's exec / fallback / index handler to change the history, setting off a new flurry of\n\t                    // redirects, without being encumbered by the number of redirects that led to that route being selected.\n\t                    if (!redirecting) {\n\t                        redirectCount = 0;\n\t                    }\n\t                    // Signal to dispatch() that it was called from here.\n\t                    state.dispatchFromStart = true;\n\t                    var context = contextFactory();\n\t                    lastDispatch = _this.dispatch(context, path).then(function (_a) {\n\t                        var redirect = _a.redirect, success = _a.success;\n\t                        if (success && redirect !== undefined) {\n\t                            redirectCount++;\n\t                            if (redirectCount > 20) {\n\t                                var error = new Error('More than 20 redirects, giving up');\n\t                                reportError(_this, context, path, error);\n\t                                throw error;\n\t                            }\n\t                            redirecting = true;\n\t                            // The history manager MUST emit the change event synchronously.\n\t                            history.replace(redirect);\n\t                            redirecting = false;\n\t                        }\n\t                    });\n\t                };\n\t                var listener = on_1.pausable(history, 'change', function (event) {\n\t                    dispatch(event.value);\n\t                });\n\t                this.own(listener);\n\t                if (dispatchCurrent) {\n\t                    dispatch(history.current);\n\t                }\n\t                return listener;\n\t            }\n\t        },\n\t        initialize: function (instance, _a) {\n\t            var _b = _a === void 0 ? {} : _a, context = _b.context, fallback = _b.fallback, history = _b.history;\n\t            var contextFactory;\n\t            if (typeof context === 'function') {\n\t                contextFactory = context;\n\t            }\n\t            else if (typeof context === 'undefined') {\n\t                contextFactory = function () {\n\t                    return {};\n\t                };\n\t            }\n\t            else {\n\t                // Assign to a constant since the context variable may be changed after the function is defined,\n\t                // which would violate its typing.\n\t                var sharedContext_1 = context;\n\t                contextFactory = function () { return sharedContext_1; };\n\t            }\n\t            if (history) {\n\t                instance.own(history);\n\t            }\n\t            privateStateMap.set(instance, {\n\t                contextFactory: contextFactory,\n\t                currentSelection: [],\n\t                dispatchFromStart: false,\n\t                fallback: fallback,\n\t                history: history,\n\t                routes: []\n\t            });\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createRouter;\n\t});\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(25)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var lang_1 = __webpack_require__(25);\n\t    /**\n\t     * Parses a query string, returning a ParamList object.\n\t     */\n\t    function parseQueryString(input) {\n\t        var query = {};\n\t        for (var _i = 0, _a = input.split('&'); _i < _a.length; _i++) {\n\t            var entry = _a[_i];\n\t            var indexOfFirstEquals = entry.indexOf('=');\n\t            var key = void 0;\n\t            var value = '';\n\t            if (indexOfFirstEquals >= 0) {\n\t                key = entry.slice(0, indexOfFirstEquals);\n\t                value = entry.slice(indexOfFirstEquals + 1);\n\t            }\n\t            else {\n\t                key = entry;\n\t            }\n\t            key = key ? decodeURIComponent(key) : '';\n\t            value = value ? decodeURIComponent(value) : '';\n\t            if (key in query) {\n\t                query[key].push(value);\n\t            }\n\t            else {\n\t                query[key] = [value];\n\t            }\n\t        }\n\t        return query;\n\t    }\n\t    /**\n\t     * Represents a set of URL query search parameters.\n\t     */\n\t    var UrlSearchParams = (function () {\n\t        /**\n\t         * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n\t         * UrlSearchParams.\n\t         */\n\t        function UrlSearchParams(input) {\n\t            var list;\n\t            if (input instanceof UrlSearchParams) {\n\t                // Copy the incoming UrlSearchParam's internal list\n\t                list = lang_1.duplicate(input._list);\n\t            }\n\t            else if (typeof input === 'object') {\n\t                // Copy the incoming object, assuming its property values are either arrays or strings\n\t                list = {};\n\t                for (var key in input) {\n\t                    var value = input[key];\n\t                    if (Array.isArray(value)) {\n\t                        list[key] = value.length ? value.slice() : [''];\n\t                    }\n\t                    else if (value == null) {\n\t                        list[key] = [''];\n\t                    }\n\t                    else {\n\t                        list[key] = [value];\n\t                    }\n\t                }\n\t            }\n\t            else if (typeof input === 'string') {\n\t                // Parse the incoming string as a query string\n\t                list = parseQueryString(input);\n\t            }\n\t            else {\n\t                list = {};\n\t            }\n\t            Object.defineProperty(this, '_list', { value: list });\n\t        }\n\t        /**\n\t         * Appends a new value to the set of values for a key.\n\t         * @param key The key to add a value for\n\t         * @param value The value to add\n\t         */\n\t        UrlSearchParams.prototype.append = function (key, value) {\n\t            if (!this.has(key)) {\n\t                this.set(key, value);\n\t            }\n\t            else {\n\t                var values = this._list[key];\n\t                if (values) {\n\t                    values.push(value);\n\t                }\n\t            }\n\t        };\n\t        /**\n\t         * Deletes all values for a key.\n\t         * @param key The key whose values are to be removed\n\t         */\n\t        UrlSearchParams.prototype.delete = function (key) {\n\t            // Set to undefined rather than deleting the key, for better consistency across browsers.\n\t            // If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n\t            // its original position.  This approach maintains the original position everywhere.\n\t            this._list[key] = undefined;\n\t        };\n\t        /**\n\t         * Returns the first value associated with a key.\n\t         * @param key The key to return the first value for\n\t         * @return The first string value for the key\n\t         */\n\t        UrlSearchParams.prototype.get = function (key) {\n\t            if (!this.has(key)) {\n\t                return undefined;\n\t            }\n\t            var value = this._list[key];\n\t            return value ? value[0] : undefined;\n\t        };\n\t        /**\n\t         * Returns all the values associated with a key.\n\t         * @param key The key to return all values for\n\t         * @return An array of strings containing all values for the key\n\t         */\n\t        UrlSearchParams.prototype.getAll = function (key) {\n\t            if (!this.has(key)) {\n\t                return undefined;\n\t            }\n\t            return this._list[key];\n\t        };\n\t        /**\n\t         * Returns true if a key has been set to any value, false otherwise.\n\t         * @param key The key to test for existence\n\t         * @return A boolean indicating if the key has been set\n\t         */\n\t        UrlSearchParams.prototype.has = function (key) {\n\t            return Array.isArray(this._list[key]);\n\t        };\n\t        /**\n\t         * Returns an array of all keys which have been set.\n\t         * @return An array of strings containing all keys set in the UrlSearchParams instance\n\t         */\n\t        UrlSearchParams.prototype.keys = function () {\n\t            var keys = [];\n\t            for (var key in this._list) {\n\t                if (this.has(key)) {\n\t                    keys.push(key);\n\t                }\n\t            }\n\t            return keys;\n\t        };\n\t        /**\n\t         * Sets the value associated with a key.\n\t         * @param key The key to set the value of\n\t         */\n\t        UrlSearchParams.prototype.set = function (key, value) {\n\t            this._list[key] = [value];\n\t        };\n\t        /**\n\t         * Returns this object's data as an encoded query string.\n\t         * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n\t         */\n\t        UrlSearchParams.prototype.toString = function () {\n\t            var query = [];\n\t            for (var key in this._list) {\n\t                if (!this.has(key)) {\n\t                    continue;\n\t                }\n\t                var values = this._list[key];\n\t                if (values) {\n\t                    var encodedKey = encodeURIComponent(key);\n\t                    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n\t                        var value = values_1[_i];\n\t                        query.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n\t                    }\n\t                }\n\t            }\n\t            return query.join('&');\n\t        };\n\t        return UrlSearchParams;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = UrlSearchParams;\n\t});\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(76)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var UrlSearchParams_1 = __webpack_require__(76);\n\t    /**\n\t     * Parses a path\n\t     * @param path The path to parse.\n\t     * @return The search params, pathname segments, and whether it ended with a trailing slash.\n\t     */\n\t    function parse(path) {\n\t        var tokens = path.split(/([/?#])/).filter(Boolean);\n\t        var pathnameTokens = tokens;\n\t        var searchParams;\n\t        var searchStart = tokens.indexOf('?');\n\t        var hashStart = tokens.indexOf('#');\n\t        if (searchStart >= 0) {\n\t            if (hashStart >= 0) {\n\t                // Either `/foo?bar#baz` or `/foo#bar?baz`\n\t                pathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t                searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1, hashStart).join(''));\n\t            }\n\t            else {\n\t                // `/foo?bar`\n\t                pathnameTokens = tokens.slice(0, searchStart);\n\t                searchParams = new UrlSearchParams_1.default(tokens.slice(searchStart + 1).join(''));\n\t            }\n\t        }\n\t        else {\n\t            searchParams = new UrlSearchParams_1.default();\n\t            if (hashStart >= 0) {\n\t                // `/foo#bar`\n\t                pathnameTokens = tokens.slice(0, hashStart);\n\t            }\n\t        }\n\t        var segments = pathnameTokens.filter(function (t) { return t !== '/'; });\n\t        var trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\t        return {\n\t            searchParams: searchParams,\n\t            segments: segments,\n\t            trailingSlash: trailingSlash\n\t        };\n\t    }\n\t    exports.parse = parse;\n\t    /**\n\t     * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n\t     * @param expectedSegments Part of a DeconstructedPath object.\n\t     * @param segments Pathname segments as returned by `parse()`\n\t     * @return A result object.\n\t     */\n\t    function match(_a, segments) {\n\t        var expectedSegments = _a.expectedSegments;\n\t        if (expectedSegments.length === 0) {\n\t            return {\n\t                hasRemaining: segments.length > 0,\n\t                offset: 0,\n\t                values: []\n\t            };\n\t        }\n\t        if (expectedSegments.length > segments.length) {\n\t            return null;\n\t        }\n\t        var isMatch = true;\n\t        var values = [];\n\t        for (var i = 0; isMatch && i < expectedSegments.length; i++) {\n\t            var value = segments[i];\n\t            var expected = expectedSegments[i];\n\t            if (isNamedSegment(expected)) {\n\t                values.push(value);\n\t            }\n\t            else if (expected.literal !== value) {\n\t                isMatch = false;\n\t            }\n\t        }\n\t        if (!isMatch) {\n\t            return null;\n\t        }\n\t        return {\n\t            hasRemaining: expectedSegments.length < segments.length,\n\t            offset: expectedSegments.length,\n\t            values: values\n\t        };\n\t    }\n\t    exports.match = match;\n\t    /**\n\t     * Determine whether the segment is a NamedSegment.\n\t     *\n\t     * @param segment The segment to be checked\n\t     * @return true if the segment is a NamedSegment, false otherwise\n\t     */\n\t    function isNamedSegment(segment) {\n\t        return segment.name !== undefined;\n\t    }\n\t    exports.isNamedSegment = isNamedSegment;\n\t    /**\n\t     * Deconstruct a route path into its constituent parts.\n\t     * @param path The path to deconstruct.\n\t     * @return An object describing the path's constituent parts.\n\t     */\n\t    function deconstruct(path) {\n\t        var expectedSegments = [];\n\t        var parameters = [];\n\t        var searchParameters = [];\n\t        var trailingSlash = false;\n\t        var tokens = path.split(/([/{}?&])/).filter(Boolean);\n\t        var leadingSlash = tokens[0] === '/';\n\t        var i = 0;\n\t        var consume = function () { return tokens[i++]; };\n\t        var peek = function () { return tokens[i]; };\n\t        var inSearchComponent = false;\n\t        while (i < tokens.length) {\n\t            var t = consume();\n\t            switch (t) {\n\t                case '{': {\n\t                    var name_1 = consume();\n\t                    if (!name_1 || name_1 === '}') {\n\t                        throw new TypeError('Parameter must have a name');\n\t                    }\n\t                    // Reserve : for future use, e.g. including type data in the parameter declaration.\n\t                    if (name_1 === '{' || name_1 === '&' || /:/.test(name_1)) {\n\t                        throw new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t                    }\n\t                    if (parameters.indexOf(name_1) !== -1 || searchParameters.indexOf(name_1) !== -1) {\n\t                        throw new TypeError(\"Parameter must have a unique name, got '\" + name_1 + \"'\");\n\t                    }\n\t                    var closing = consume();\n\t                    if (!closing || closing !== '}') {\n\t                        throw new TypeError(\"Parameter name must be followed by '}', got '\" + closing + \"'\");\n\t                    }\n\t                    var separator = peek();\n\t                    if (separator) {\n\t                        if (inSearchComponent) {\n\t                            if (separator !== '&') {\n\t                                throw new TypeError(\"Search parameter must be followed by '&', got '\" + separator + \"'\");\n\t                            }\n\t                        }\n\t                        else if (separator !== '/' && separator !== '?') {\n\t                            throw new TypeError(\"Parameter must be followed by '/' or '?', got '\" + separator + \"'\");\n\t                        }\n\t                    }\n\t                    if (inSearchComponent) {\n\t                        searchParameters.push(name_1);\n\t                    }\n\t                    else {\n\t                        parameters.push(name_1);\n\t                        expectedSegments.push(Object.freeze({ name: name_1 }));\n\t                    }\n\t                    break;\n\t                }\n\t                case '?':\n\t                case '/':\n\t                    if (inSearchComponent) {\n\t                        throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                    }\n\t                    if (t === '?') {\n\t                        inSearchComponent = true;\n\t                        if (expectedSegments.length === 0) {\n\t                            throw new TypeError('Path must contain at least one segment');\n\t                        }\n\t                    }\n\t                    if (t === '/') {\n\t                        var next_1 = peek();\n\t                        if (next_1 === '/') {\n\t                            throw new TypeError('Path segment must not be empty');\n\t                        }\n\t                        if (expectedSegments.length > 0 && (!next_1 || next_1 === '?')) {\n\t                            trailingSlash = true;\n\t                        }\n\t                    }\n\t                    break;\n\t                case '&':\n\t                    if (!inSearchComponent) {\n\t                        throw new TypeError('Path segment must not contain \\'&\\'');\n\t                    }\n\t                    var next = peek();\n\t                    if (next === '&') {\n\t                        throw new TypeError('Expected parameter in search component, got \\'&\\'');\n\t                    }\n\t                    break;\n\t                default:\n\t                    if (inSearchComponent) {\n\t                        throw new TypeError(\"Expected parameter in search component, got '\" + t + \"'\");\n\t                    }\n\t                    expectedSegments.push(Object.freeze({ literal: t }));\n\t            }\n\t        }\n\t        return Object.freeze({\n\t            expectedSegments: Object.freeze(expectedSegments),\n\t            leadingSlash: leadingSlash,\n\t            parameters: Object.freeze(parameters),\n\t            searchParameters: Object.freeze(searchParameters),\n\t            trailingSlash: trailingSlash\n\t        });\n\t    }\n\t    exports.deconstruct = deconstruct;\n\t});\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(76), __webpack_require__(22), __webpack_require__(75), __webpack_require__(77)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var UrlSearchParams_1 = __webpack_require__(76);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var createRouter_1 = __webpack_require__(75);\n\t    var path_1 = __webpack_require__(77);\n\t    var privateStateMap = new WeakMap_1.default();\n\t    // Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n\t    // change the private state of their children.\n\t    var parentMap = new WeakMap_1.default();\n\t    var noop = function () { };\n\t    function computeDefaultParams(parameters, searchParameters, fromPathname, searchParams) {\n\t        var params = {};\n\t        parameters.forEach(function (name, index) {\n\t            params[name] = fromPathname[index];\n\t        });\n\t        searchParameters.forEach(function (name) {\n\t            var value = searchParams.get(name);\n\t            if (value !== undefined) {\n\t                params[name] = value;\n\t            }\n\t        });\n\t        return params;\n\t    }\n\t    var createRoute = compose_1.default({\n\t        get parent() {\n\t            return parentMap.get(this);\n\t        },\n\t        get path() {\n\t            return privateStateMap.get(this).path;\n\t        },\n\t        append: function (add) {\n\t            var _this = this;\n\t            var routes = privateStateMap.get(this).routes;\n\t            var append = function (route) {\n\t                if (createRouter_1.hasBeenAppended(route)) {\n\t                    throw new Error('Cannot append route that has already been appended');\n\t                }\n\t                routes.push(route);\n\t                parentMap.set(route, _this);\n\t            };\n\t            if (Array.isArray(add)) {\n\t                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {\n\t                    var route = add_1[_i];\n\t                    append(route);\n\t                }\n\t            }\n\t            else {\n\t                append(add);\n\t            }\n\t        },\n\t        match: function (segments, hasTrailingSlash, searchParams) {\n\t            var _a = privateStateMap.get(this), computeParams = _a.computeParams, path = _a.path, trailingSlashMustMatch = _a.trailingSlashMustMatch;\n\t            var result = path_1.match(path, segments);\n\t            if (result === null) {\n\t                return null;\n\t            }\n\t            if (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n\t                return null;\n\t            }\n\t            // Only extract the search params defined in the route's path.\n\t            var knownSearchParams = path.searchParameters.reduce(function (list, name) {\n\t                var value = searchParams.getAll(name);\n\t                if (value !== undefined) {\n\t                    list[name] = value;\n\t                }\n\t                return list;\n\t            }, {});\n\t            var params = computeParams(result.values, new UrlSearchParams_1.default(knownSearchParams));\n\t            if (params === null) {\n\t                return null;\n\t            }\n\t            return {\n\t                hasRemaining: result.hasRemaining,\n\t                offset: result.offset,\n\t                params: params,\n\t                rawPathValues: result.values,\n\t                rawSearchParams: knownSearchParams\n\t            };\n\t        },\n\t        select: function (context, segments, hasTrailingSlash, searchParams) {\n\t            var _a = privateStateMap.get(this), exec = _a.exec, index = _a.index, fallback = _a.fallback, guard = _a.guard, path = _a.path, routes = _a.routes;\n\t            var matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\t            // Return early if possible.\n\t            if (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n\t                return [];\n\t            }\n\t            var params = matchResult.params;\n\t            if (guard) {\n\t                var guardResult = guard({ context: context, params: params });\n\t                if (typeof guardResult === 'string') {\n\t                    return guardResult;\n\t                }\n\t                if (!guardResult) {\n\t                    return [];\n\t                }\n\t            }\n\t            var handler = exec;\n\t            var redirect;\n\t            var remainingSelection;\n\t            var selected = false;\n\t            if (matchResult.hasRemaining) {\n\t                // Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t                var remainingSegments_1 = segments.slice(matchResult.offset);\n\t                selected = routes.some(function (nested) {\n\t                    var nestedResult = nested.select(context, remainingSegments_1, hasTrailingSlash, searchParams);\n\t                    if (typeof nestedResult === 'string') {\n\t                        redirect = nestedResult;\n\t                        return true;\n\t                    }\n\t                    if (nestedResult.length > 0) {\n\t                        remainingSelection = nestedResult;\n\t                        return true;\n\t                    }\n\t                    return false;\n\t                });\n\t                // No remaining segments matched, only select this route if a fallback handler was specified.\n\t                if (!selected && fallback) {\n\t                    selected = true;\n\t                    handler = fallback;\n\t                }\n\t            }\n\t            else {\n\t                selected = true;\n\t                if (index) {\n\t                    handler = index;\n\t                }\n\t            }\n\t            if (!selected) {\n\t                return [];\n\t            }\n\t            if (redirect !== undefined) {\n\t                return redirect;\n\t            }\n\t            var rawPathValues = matchResult.rawPathValues, rawSearchParams = matchResult.rawSearchParams;\n\t            var selection = {\n\t                // Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t                // think no routes were selected.\n\t                handler: handler || noop,\n\t                path: path,\n\t                params: params,\n\t                rawPathValues: rawPathValues,\n\t                rawSearchParams: rawSearchParams,\n\t                route: this\n\t            };\n\t            return remainingSelection ? [selection].concat(remainingSelection) : [selection];\n\t        }\n\t    }, function (instance, _a) {\n\t        var _b = _a === void 0 ? {} : _a, exec = _b.exec, fallback = _b.fallback, guard = _b.guard, index = _b.index, computeParams = _b.params, path = _b.path, _c = _b.trailingSlashMustMatch, trailingSlashMustMatch = _c === void 0 ? true : _c;\n\t        if (path && /#/.test(path)) {\n\t            throw new TypeError('Path must not contain \\'#\\'');\n\t        }\n\t        var deconstructedPath = path_1.deconstruct(path || '/');\n\t        var parameters = deconstructedPath.parameters, searchParameters = deconstructedPath.searchParameters;\n\t        if (computeParams) {\n\t            if (parameters.length === 0 && searchParameters.length === 0) {\n\t                throw new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t            }\n\t        }\n\t        else {\n\t            computeParams = function (fromPathname, searchParams) {\n\t                return computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t            };\n\t        }\n\t        privateStateMap.set(instance, {\n\t            computeParams: computeParams,\n\t            exec: exec,\n\t            fallback: fallback,\n\t            guard: guard,\n\t            index: index,\n\t            path: deconstructedPath,\n\t            routes: [],\n\t            trailingSlashMustMatch: trailingSlashMustMatch\n\t        });\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createRoute;\n\t});\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(80), __webpack_require__(39), __webpack_require__(65)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createParentListMixin_1 = __webpack_require__(80);\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createStatefulChildrenMixin_1 = __webpack_require__(65);\n\t    function filterCompleted(children) {\n\t        return children.filter(function (child) {\n\t            return child.state.completed;\n\t        });\n\t    }\n\t    function filterActive(children) {\n\t        return children.filter(function (child) {\n\t            return !child.state.completed;\n\t        });\n\t    }\n\t    var createTodoList = createRenderMixin_1.default\n\t        .mixin(createParentListMixin_1.default)\n\t        .mixin(createStatefulChildrenMixin_1.default)\n\t        .extend({\n\t        getChildrenNodes: function () {\n\t            var results = [];\n\t            var children = this.children;\n\t            var filteredChildren = children;\n\t            if (this.state.activeFilter === 'completed') {\n\t                filteredChildren = filterCompleted(children);\n\t            }\n\t            else if (this.state.activeFilter === 'active') {\n\t                filteredChildren = filterActive(children);\n\t            }\n\t            filteredChildren.forEach(function (child) { return results.push(child.render()); });\n\t            return results;\n\t        },\n\t        tagName: 'ul'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createTodoList;\n\t});\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(18), __webpack_require__(22), __webpack_require__(36), __webpack_require__(35)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var createEvented_1 = __webpack_require__(18);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var immutable_1 = __webpack_require__(36);\n\t    var lang_1 = __webpack_require__(35);\n\t    /**\n\t     * Contains a List of children per instance\n\t     */\n\t    var childrenMap = new WeakMap_1.default();\n\t    var createParentMixin = compose_1.default({\n\t        get children() {\n\t            return childrenMap.get(this);\n\t        },\n\t        set children(value) {\n\t            var _this = this;\n\t            if (!value.equals(childrenMap.get(this))) {\n\t                value.forEach(function (widget) {\n\t                    // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                    // istanbul ignore else\n\t                    if (widget) {\n\t                        if (widget.parent !== _this) {\n\t                            widget.parent = _this;\n\t                            /* TODO: If a child gets attached and reattached it may own multiple handles */\n\t                            lang_1.getRemoveHandle(_this, widget);\n\t                        }\n\t                    }\n\t                });\n\t                childrenMap.set(this, value);\n\t                this.emit({\n\t                    type: 'childlist',\n\t                    target: this,\n\t                    children: value\n\t                });\n\t                if (this.invalidate) {\n\t                    this.invalidate();\n\t                }\n\t            }\n\t        },\n\t        append: function (child) {\n\t            this.children = Array.isArray(child) ? this.children.concat(child) : this.children.push(child);\n\t            return lang_1.getRemoveHandle(this, child);\n\t        },\n\t        clear: function () {\n\t            var children = childrenMap.get(this);\n\t            if (children) {\n\t                children.forEach(function (child) {\n\t                    // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                    // istanbul ignore else\n\t                    if (child) {\n\t                        child.parent === undefined;\n\t                    }\n\t                });\n\t                this.children = immutable_1.List();\n\t            }\n\t        },\n\t        insert: function (child, position, reference) {\n\t            child.parent = this;\n\t            this.children = lang_1.insertInList(childrenMap.get(this), child, position, reference);\n\t            return lang_1.getRemoveHandle(this, child);\n\t        }\n\t    })\n\t        .mixin({\n\t        mixin: createEvented_1.default,\n\t        initialize: function (instance, options) {\n\t            childrenMap.set(instance, immutable_1.List());\n\t            if (options && options.children && options.children.length) {\n\t                instance.own(instance.append(options.children));\n\t            }\n\t            instance.own({\n\t                destroy: function () {\n\t                    var children = childrenMap.get(instance);\n\t                    children.forEach(function (child) {\n\t                        // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                        // istanbul ignore else\n\t                        if (child) {\n\t                            child.destroy();\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createParentMixin;\n\t});\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(39), __webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createRenderMixin_1 = __webpack_require__(39);\n\t    var createVNodeEvented_1 = __webpack_require__(7);\n\t    var createWidget = createRenderMixin_1.default\n\t        .mixin(createVNodeEvented_1.default);\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createWidget;\n\t});\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(81), __webpack_require__(84), __webpack_require__(80), __webpack_require__(83), __webpack_require__(65)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createWidget_1 = __webpack_require__(81);\n\t    var createCloseableMixin_1 = __webpack_require__(84);\n\t    var createParentListMixin_1 = __webpack_require__(80);\n\t    var createRenderableChildrenMixin_1 = __webpack_require__(83);\n\t    var createStatefulChildrenMixin_1 = __webpack_require__(65);\n\t    var createPanel = createWidget_1.default\n\t        .mixin(createCloseableMixin_1.default)\n\t        .mixin(createParentListMixin_1.default)\n\t        .mixin(createRenderableChildrenMixin_1.default)\n\t        .mixin(createStatefulChildrenMixin_1.default)\n\t        .extend({\n\t        tagName: 'dojo-panel'\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createPanel;\n\t});\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(23)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var array_1 = __webpack_require__(23);\n\t    var createRenderableChildrenMixin = compose_1.default({\n\t        /* When this gets mixed in, if we had the children as part of the interface, we would end up overwritting what is\n\t         * likely a get accessor for the children, so to protect ourselves, we won't have it part of the interface */\n\t        getChildrenNodes: function () {\n\t            var _a = this, children = _a.children, sort = _a.sort;\n\t            /* children is not guarunteed to be set, therefore need to guard against it */\n\t            if (children) {\n\t                var results_1 = [];\n\t                if (sort) {\n\t                    array_1.from(children.entries()).sort(sort)\n\t                        .forEach(function (_a) {\n\t                        var child = _a[1];\n\t                        return results_1.push(child.render());\n\t                    });\n\t                }\n\t                else {\n\t                    children.forEach(function (child) {\n\t                        // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                        // istanbul ignore else\n\t                        if (child) {\n\t                            results_1.push(child.render());\n\t                        }\n\t                    });\n\t                }\n\t                return results_1;\n\t            }\n\t            else {\n\t                return [];\n\t            }\n\t        }\n\t    }, function (instance, options) {\n\t        if (options) {\n\t            instance.sort = options.sort;\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createRenderableChildrenMixin;\n\t});\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(37), __webpack_require__(38), __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var createCancelableEvent_1 = __webpack_require__(37);\n\t    var createStateful_1 = __webpack_require__(38);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var createCloseableMixin = createStateful_1.default\n\t        .mixin({\n\t        mixin: {\n\t            close: function () {\n\t                if (this.state.closeable) {\n\t                    var event_1 = createCancelableEvent_1.default({ type: 'close', target: this });\n\t                    this.emit(event_1);\n\t                    return event_1.defaultPrevented ? Promise_1.default.resolve(false) : this.destroy();\n\t                }\n\t                return Promise_1.default.resolve(false);\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createCloseableMixin;\n\t});\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(20), __webpack_require__(100), __webpack_require__(25), __webpack_require__(28), __webpack_require__(8), __webpack_require__(9), __webpack_require__(22), __webpack_require__(98), __webpack_require__(97), __webpack_require__(96), __webpack_require__(88), __webpack_require__(94), __webpack_require__(86), __webpack_require__(99)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var compose_1 = __webpack_require__(20);\n\t    var IdentityRegistry_1 = __webpack_require__(100);\n\t    var lang_1 = __webpack_require__(25);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var Set_1 = __webpack_require__(8);\n\t    var Symbol_1 = __webpack_require__(9);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var extractRegistrationElements_1 = __webpack_require__(98);\n\t    var factories_1 = __webpack_require__(97);\n\t    var InstanceRegistry_1 = __webpack_require__(96);\n\t    var makeIdGenerator_1 = __webpack_require__(88);\n\t    var moduleResolver_1 = __webpack_require__(94);\n\t    var realizeCustomElements_1 = __webpack_require__(86);\n\t    var RegistryProvider_1 = __webpack_require__(99);\n\t    exports.RegistryProvider = RegistryProvider_1.default;\n\t    /**\n\t     * Identifier for the default action store, if any.\n\t     */\n\t    exports.DEFAULT_ACTION_STORE = Symbol_1.default('Identifier for default action stores');\n\t    /**\n\t     * Identifier for the default widget store, if any.\n\t     */\n\t    exports.DEFAULT_WIDGET_STORE = Symbol_1.default('Identifier for default widget stores');\n\t    var generateWidgetId = makeIdGenerator_1.default('app-widget-');\n\t    var noop = function () { };\n\t    var privateStateMap = new WeakMap_1.default();\n\t    function addIdentifier(app, id) {\n\t        var identifiers = privateStateMap.get(app).identifiers;\n\t        if (identifiers.has(id)) {\n\t            throw new Error(\"'\" + id + \"' has already been used as an identifier\");\n\t        }\n\t        identifiers.add(id);\n\t        return {\n\t            destroy: function () {\n\t                this.destroy = noop;\n\t                identifiers.delete(id);\n\t            }\n\t        };\n\t    }\n\t    function createCustomWidget(app, id) {\n\t        var registryProvider = app.registryProvider, defaultWidgetStore = app.defaultWidgetStore;\n\t        var factoryHandle;\n\t        // istanbul ignore if\n\t        if (!defaultWidgetStore) {\n\t            throw new Error('A default widget store must be configured in order to create custom widgets');\n\t        }\n\t        return defaultWidgetStore.get(id).then(function (state) {\n\t            var _a = privateStateMap.get(app), customElementFactories = _a.customElementFactories, widgetFactories = _a.widgetFactories, widgetInstances = _a.widgetInstances;\n\t            var hasRegisteredFactory = widgetFactories.has(id);\n\t            var hasRegisteredInstance = widgetInstances.has(id);\n\t            if (!hasRegisteredFactory && !hasRegisteredInstance) {\n\t                var customFactory = customElementFactories.get(state.type);\n\t                factoryHandle = app.registerWidgetFactory(id, customFactory);\n\t            }\n\t            return app.getWidget(id);\n\t        }).then(function (widget) {\n\t            widget.own(factoryHandle);\n\t            return widget;\n\t        });\n\t    }\n\t    function registerInstance(app, instance, id) {\n\t        var _a = privateStateMap.get(app), instanceRegistry = _a.instanceRegistry, widgetInstances = _a.widgetInstances;\n\t        // Maps the instance to its ID\n\t        var instanceHandle = instanceRegistry.addWidget(instance, id);\n\t        // Maps the ID to the instance\n\t        var idHandle = widgetInstances.register(id, instance);\n\t        return {\n\t            destroy: function () {\n\t                this.destroy = noop;\n\t                instanceHandle.destroy();\n\t                idHandle.destroy();\n\t            }\n\t        };\n\t    }\n\t    var createApp = compose_1.default({\n\t        set defaultActionStore(store) {\n\t            var _a = privateStateMap.get(this), instanceRegistry = _a.instanceRegistry, storeFactories = _a.storeFactories;\n\t            instanceRegistry.addStore(store, exports.DEFAULT_ACTION_STORE);\n\t            storeFactories.register(exports.DEFAULT_ACTION_STORE, function () { return store; });\n\t        },\n\t        get defaultActionStore() {\n\t            var storeFactories = privateStateMap.get(this).storeFactories;\n\t            if (storeFactories.has(exports.DEFAULT_ACTION_STORE)) {\n\t                return storeFactories.get(exports.DEFAULT_ACTION_STORE)();\n\t            }\n\t        },\n\t        set defaultWidgetStore(store) {\n\t            var _a = privateStateMap.get(this), instanceRegistry = _a.instanceRegistry, storeFactories = _a.storeFactories;\n\t            instanceRegistry.addStore(store, exports.DEFAULT_WIDGET_STORE);\n\t            storeFactories.register(exports.DEFAULT_WIDGET_STORE, function () { return store; });\n\t        },\n\t        get defaultWidgetStore() {\n\t            var storeFactories = privateStateMap.get(this).storeFactories;\n\t            if (storeFactories.has(exports.DEFAULT_WIDGET_STORE)) {\n\t                return storeFactories.get(exports.DEFAULT_WIDGET_STORE)();\n\t            }\n\t        },\n\t        get registryProvider() {\n\t            return privateStateMap.get(this).registryProvider;\n\t        },\n\t        registerAction: function (id, action) {\n\t            var _this = this;\n\t            var _a = privateStateMap.get(this), actionFactories = _a.actionFactories, instanceRegistry = _a.instanceRegistry;\n\t            var idHandle = addIdentifier(this, id);\n\t            var instanceHandle = instanceRegistry.addAction(action, id);\n\t            var registryHandle = actionFactories.register(id, function () {\n\t                var promise = new Promise_1.default(function (resolve) {\n\t                    resolve(action.configure(_this.registryProvider));\n\t                })\n\t                    .then(function () { return action; });\n\t                // Replace the registered factory to ensure the action is not configured twice.\n\t                registryHandle.destroy();\n\t                registryHandle = actionFactories.register(id, function () { return promise; });\n\t                return promise;\n\t            });\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    idHandle.destroy();\n\t                    instanceHandle.destroy();\n\t                    registryHandle.destroy();\n\t                }\n\t            };\n\t        },\n\t        registerActionFactory: function (id, factory) {\n\t            var _this = this;\n\t            var _a = privateStateMap.get(this), actionFactories = _a.actionFactories, instanceRegistry = _a.instanceRegistry;\n\t            var idHandle = addIdentifier(this, id);\n\t            var destroyed = false;\n\t            var instanceHandle;\n\t            var registryHandle = actionFactories.register(id, function () {\n\t                var promise = Promise_1.default.resolve()\n\t                    .then(function () {\n\t                    // Always call the factory in a future turn. This harmonizes behavior regardless of whether the\n\t                    // factory is registered through this method or loaded from a definition.\n\t                    var _a = _this, stateFrom = _a.defaultActionStore, registryProvider = _a.registryProvider;\n\t                    return factory({ registryProvider: registryProvider, stateFrom: stateFrom });\n\t                })\n\t                    .then(function (action) {\n\t                    if (!destroyed) {\n\t                        instanceHandle = instanceRegistry.addAction(action, id);\n\t                    }\n\t                    // Configure the action, allow for a promise to be returned.\n\t                    return Promise_1.default.resolve(action.configure(_this.registryProvider)).then(function () {\n\t                        return action;\n\t                    });\n\t                });\n\t                // Replace the registered factory to ensure next time this action is needed, the same action is returned.\n\t                registryHandle.destroy();\n\t                registryHandle = actionFactories.register(id, function () { return promise; });\n\t                return promise;\n\t            });\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    destroyed = true;\n\t                    idHandle.destroy();\n\t                    registryHandle.destroy();\n\t                    if (instanceHandle) {\n\t                        instanceHandle.destroy();\n\t                    }\n\t                }\n\t            };\n\t        },\n\t        registerCustomElementFactory: function (name, factory) {\n\t            if (!realizeCustomElements_1.isValidName(name)) {\n\t                throw new SyntaxError(\"'\" + name + \"' is not a valid custom element name\");\n\t            }\n\t            // Wrap the factory since the registry cannot store frozen factories, and dojo-compose creates\n\t            // frozen factories\n\t            var wrapped = function (options) { return factory(options); };\n\t            // Note that each custom element requires a new widget, so there's no need to replace the\n\t            // registered factory.\n\t            var registryHandle = privateStateMap.get(this).customElementFactories.register(realizeCustomElements_1.normalizeName(name), wrapped);\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    registryHandle.destroy();\n\t                }\n\t            };\n\t        },\n\t        registerStore: function (id, store) {\n\t            var _a = privateStateMap.get(this), instanceRegistry = _a.instanceRegistry, storeFactories = _a.storeFactories;\n\t            var idHandle = addIdentifier(this, id);\n\t            var instanceHandle = instanceRegistry.addStore(store, id);\n\t            var registryHandle = storeFactories.register(id, function () { return store; });\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    idHandle.destroy();\n\t                    instanceHandle.destroy();\n\t                    registryHandle.destroy();\n\t                }\n\t            };\n\t        },\n\t        registerStoreFactory: function (id, factory) {\n\t            var _a = privateStateMap.get(this), instanceRegistry = _a.instanceRegistry, storeFactories = _a.storeFactories;\n\t            var idHandle = addIdentifier(this, id);\n\t            var destroyed = false;\n\t            var instanceHandle;\n\t            var registryHandle = storeFactories.register(id, function () {\n\t                var promise = Promise_1.default.resolve().then(function () {\n\t                    // Always call the factory in a future turn. This harmonizes behavior regardless of whether the\n\t                    // factory is registered through this method or loaded from a definition.\n\t                    return factory();\n\t                }).then(function (store) {\n\t                    if (!destroyed) {\n\t                        instanceHandle = instanceRegistry.addStore(store, id);\n\t                    }\n\t                    return store;\n\t                });\n\t                // Replace the registered factory to ensure next time this store is needed, the same store is returned.\n\t                registryHandle.destroy();\n\t                registryHandle = storeFactories.register(id, function () { return promise; });\n\t                return promise;\n\t            });\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    destroyed = true;\n\t                    idHandle.destroy();\n\t                    registryHandle.destroy();\n\t                    if (instanceHandle) {\n\t                        instanceHandle.destroy();\n\t                    }\n\t                }\n\t            };\n\t        },\n\t        registerWidget: function (id, widget) {\n\t            var _a = privateStateMap.get(this), instanceRegistry = _a.instanceRegistry, widgetFactories = _a.widgetFactories;\n\t            var idHandle = addIdentifier(this, id);\n\t            var instanceHandle = instanceRegistry.addWidget(widget, id);\n\t            var registryHandle = widgetFactories.register(id, function () { return widget; });\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    idHandle.destroy();\n\t                    instanceHandle.destroy();\n\t                    registryHandle.destroy();\n\t                }\n\t            };\n\t        },\n\t        registerWidgetFactory: function (id, factory) {\n\t            var _this = this;\n\t            var _a = privateStateMap.get(this), instanceRegistry = _a.instanceRegistry, widgetFactories = _a.widgetFactories;\n\t            var idHandle = addIdentifier(this, id);\n\t            var destroyed = false;\n\t            var instanceHandle;\n\t            var registryHandle = widgetFactories.register(id, function () {\n\t                var promise = Promise_1.default.resolve().then(function () {\n\t                    // Always call the factory in a future turn. This harmonizes behavior regardless of whether the\n\t                    // factory is registered through this method or loaded from a definition.\n\t                    var _a = _this, registryProvider = _a.registryProvider, defaultWidgetStore = _a.defaultWidgetStore;\n\t                    var options = { id: id, registryProvider: registryProvider };\n\t                    if (defaultWidgetStore) {\n\t                        options.stateFrom = defaultWidgetStore;\n\t                    }\n\t                    return factory(options);\n\t                }).then(function (widget) {\n\t                    if (!destroyed) {\n\t                        instanceHandle = instanceRegistry.addWidget(widget, id);\n\t                    }\n\t                    return widget;\n\t                });\n\t                // Replace the registered factory to ensure next time this widget is needed, the same widget is returned.\n\t                registryHandle.destroy();\n\t                registryHandle = widgetFactories.register(id, function () { return promise; });\n\t                return promise;\n\t            });\n\t            return {\n\t                destroy: function () {\n\t                    this.destroy = noop;\n\t                    destroyed = true;\n\t                    idHandle.destroy();\n\t                    registryHandle.destroy();\n\t                    if (instanceHandle) {\n\t                        instanceHandle.destroy();\n\t                    }\n\t                }\n\t            };\n\t        },\n\t        loadDefinition: function (_a) {\n\t            var actions = _a.actions, customElements = _a.customElements, stores = _a.stores, widgets = _a.widgets;\n\t            var resolveMid = privateStateMap.get(this).resolveMid;\n\t            var handles = [];\n\t            if (actions) {\n\t                for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {\n\t                    var definition = actions_1[_i];\n\t                    var factory = factories_1.makeActionFactory(definition, resolveMid, this);\n\t                    var handle = this.registerActionFactory(definition.id, factory);\n\t                    handles.push(handle);\n\t                }\n\t            }\n\t            if (customElements) {\n\t                for (var _b = 0, customElements_1 = customElements; _b < customElements_1.length; _b++) {\n\t                    var definition = customElements_1[_b];\n\t                    var factory = factories_1.makeCustomElementFactory(definition, resolveMid);\n\t                    var handle = this.registerCustomElementFactory(definition.name, factory);\n\t                    handles.push(handle);\n\t                }\n\t            }\n\t            if (stores) {\n\t                for (var _c = 0, stores_1 = stores; _c < stores_1.length; _c++) {\n\t                    var definition = stores_1[_c];\n\t                    var factory = factories_1.makeStoreFactory(definition, resolveMid);\n\t                    var handle = this.registerStoreFactory(definition.id, factory);\n\t                    handles.push(handle);\n\t                }\n\t            }\n\t            if (widgets) {\n\t                for (var _d = 0, widgets_1 = widgets; _d < widgets_1.length; _d++) {\n\t                    var definition = widgets_1[_d];\n\t                    var factory = factories_1.makeWidgetFactory(definition, resolveMid, this);\n\t                    var handle = this.registerWidgetFactory(definition.id, factory);\n\t                    handles.push(handle);\n\t                }\n\t            }\n\t            return {\n\t                destroy: function () {\n\t                    for (var _i = 0, _a = handles.splice(0, handles.length); _i < _a.length; _i++) {\n\t                        var handle = _a[_i];\n\t                        handle.destroy();\n\t                    }\n\t                }\n\t            };\n\t        },\n\t        realize: function (root) {\n\t            var _this = this;\n\t            var resolveMid = privateStateMap.get(this).resolveMid;\n\t            return extractRegistrationElements_1.default(resolveMid, root)\n\t                .then(function (_a) {\n\t                var actions = _a.actions, customElements = _a.customElements, defaultStores = _a.defaultStores, stores = _a.stores, widgets = _a.widgets;\n\t                var definitionHandle = _this.loadDefinition({ actions: actions, customElements: customElements, stores: stores, widgets: widgets });\n\t                if (defaultStores.length === 0) {\n\t                    return definitionHandle;\n\t                }\n\t                return Promise_1.default.all(defaultStores.map(function (definition) {\n\t                    // N.B. The ID is ignored by the store factory\n\t                    var type = definition.id;\n\t                    var factory = factories_1.makeStoreFactory(definition, resolveMid);\n\t                    return Promise_1.default.resolve(factory())\n\t                        .then(function (store) {\n\t                        if (type === 'action') {\n\t                            _this.defaultActionStore = store;\n\t                        }\n\t                        else {\n\t                            _this.defaultWidgetStore = store;\n\t                        }\n\t                    });\n\t                }))\n\t                    .then(function () { return definitionHandle; });\n\t            })\n\t                .then(function (definitionHandle) {\n\t                return realizeCustomElements_1.default(function (id) { return addIdentifier(_this, id); }, function (instance, id) { return registerInstance(_this, instance, id); }, _this, _this.registryProvider, root, _this.defaultWidgetStore)\n\t                    .then(function (realizationHandle) {\n\t                    return {\n\t                        destroy: function () {\n\t                            this.destroy = noop;\n\t                            definitionHandle.destroy();\n\t                            realizationHandle.destroy();\n\t                        }\n\t                    };\n\t                });\n\t            });\n\t        }\n\t    })\n\t        .mixin({\n\t        mixin: {\n\t            getAction: function (id) {\n\t                var _this = this;\n\t                return new Promise_1.default(function (resolve) {\n\t                    resolve(privateStateMap.get(_this).actionFactories.get(id)());\n\t                });\n\t            },\n\t            hasAction: function (id) {\n\t                return privateStateMap.get(this).actionFactories.has(id);\n\t            },\n\t            identifyAction: function (action) {\n\t                return privateStateMap.get(this).instanceRegistry.identifyAction(action);\n\t            },\n\t            getCustomElementFactory: function (name) {\n\t                return privateStateMap.get(this).customElementFactories.get(name);\n\t            },\n\t            hasCustomElementFactory: function (name) {\n\t                return privateStateMap.get(this).customElementFactories.has(name);\n\t            },\n\t            getStore: function (id) {\n\t                var _this = this;\n\t                return new Promise_1.default(function (resolve) {\n\t                    resolve(privateStateMap.get(_this).storeFactories.get(id)());\n\t                });\n\t            },\n\t            hasStore: function (id) {\n\t                return privateStateMap.get(this).storeFactories.has(id);\n\t            },\n\t            identifyStore: function (store) {\n\t                return privateStateMap.get(this).instanceRegistry.identifyStore(store);\n\t            },\n\t            createWidget: function (factory, options) {\n\t                var _this = this;\n\t                if (options === void 0) { options = {}; }\n\t                var _a = this, defaultWidgetStore = _a.defaultWidgetStore, registryProvider = _a.registryProvider;\n\t                var _b = options.id, id = _b === void 0 ? generateWidgetId() : _b;\n\t                // Like for custom elements, don't add the generated ID to the options.\n\t                var _c = privateStateMap.get(this), widgetFactories = _c.widgetFactories, widgetInstances = _c.widgetInstances;\n\t                // Ensure no other widget with this ID exists.\n\t                if (widgetFactories.has(id) || widgetInstances.has(id)) {\n\t                    return Promise_1.default.reject(new Error(\"A widget with ID '\" + id + \"' already exists\"));\n\t                }\n\t                if (!options.registryProvider) {\n\t                    options.registryProvider = registryProvider;\n\t                }\n\t                return new Promise_1.default(function (resolve) {\n\t                    if (options.id && (options.stateFrom || defaultWidgetStore)) {\n\t                        var store = options.stateFrom = options.stateFrom || defaultWidgetStore;\n\t                        // We will attempt to create an initial state, if it isn't present in the store\n\t                        var state = { id: id };\n\t                        if (options.state) {\n\t                            lang_1.assign(state, options.state);\n\t                        }\n\t                        // TODO: What happens if the store rejects?\n\t                        resolve(store.add(state));\n\t                    }\n\t                    else {\n\t                        resolve();\n\t                    }\n\t                })\n\t                    .then(function () {\n\t                    var widget = factory(options);\n\t                    // Add the instance to the various registries the app may maintain.\n\t                    //\n\t                    // No need to trap registerInstance for duplicates, because we are creating new\n\t                    // in this function\n\t                    widget.own(registerInstance(_this, widget, id));\n\t                    return [id, widget];\n\t                });\n\t            },\n\t            getWidget: function (id) {\n\t                var _this = this;\n\t                // Widgets either need to be resolved from a factory, or have been created when realizing\n\t                // custom elements.\n\t                var _a = privateStateMap.get(this), factories = _a.widgetFactories, instances = _a.widgetInstances;\n\t                var missingFactory;\n\t                return new Promise_1.default(function (resolve) {\n\t                    var factory;\n\t                    try {\n\t                        factory = factories.get(id);\n\t                    }\n\t                    catch (err) {\n\t                        missingFactory = err;\n\t                        resolve(Promise_1.default.reject(err));\n\t                        return;\n\t                    }\n\t                    // Be sure to call the factory synchronously.\n\t                    resolve(factory());\n\t                }).catch(function (err) {\n\t                    if (missingFactory && instances.has(id)) {\n\t                        return instances.get(id);\n\t                    }\n\t                    else {\n\t                        return Promise_1.default.reject(err);\n\t                    }\n\t                }).catch(function (err) {\n\t                    if (missingFactory && _this.defaultWidgetStore) {\n\t                        // Note that errors thrown by the createCustomWidget are masked by the missingFactory error.\n\t                        return createCustomWidget(_this, id);\n\t                    }\n\t                    else {\n\t                        return Promise_1.default.reject(err);\n\t                    }\n\t                }).catch(function (err) {\n\t                    return Promise_1.default.reject(missingFactory || err);\n\t                });\n\t            },\n\t            hasWidget: function (id) {\n\t                var _a = privateStateMap.get(this), customElementFactories = _a.customElementFactories, widgetFactories = _a.widgetFactories, widgetInstances = _a.widgetInstances;\n\t                var defaultWidgetStore = this.defaultWidgetStore;\n\t                var exists = widgetFactories.has(id) || widgetInstances.has(id);\n\t                if (exists || !defaultWidgetStore) {\n\t                    return Promise_1.default.resolve(exists);\n\t                }\n\t                else {\n\t                    return defaultWidgetStore.get(id).then(function (_a) {\n\t                        var type = _a.type;\n\t                        return customElementFactories.has(type);\n\t                    });\n\t                }\n\t            },\n\t            identifyWidget: function (widget) {\n\t                return privateStateMap.get(this).instanceRegistry.identifyWidget(widget);\n\t            }\n\t        },\n\t        initialize: function (instance, _a) {\n\t            var _b = _a === void 0 ? {} : _a, defaultActionStore = _b.defaultActionStore, defaultWidgetStore = _b.defaultWidgetStore, _c = _b.toAbsMid, toAbsMid = _c === void 0 ? function (moduleId) { return moduleId; } : _c;\n\t            privateStateMap.set(instance, {\n\t                actionFactories: new IdentityRegistry_1.default(),\n\t                customElementFactories: new IdentityRegistry_1.default(),\n\t                identifiers: new Set_1.default(),\n\t                instanceRegistry: new InstanceRegistry_1.default(),\n\t                registryProvider: new RegistryProvider_1.default(instance),\n\t                resolveMid: moduleResolver_1.default(toAbsMid),\n\t                storeFactories: new IdentityRegistry_1.default(),\n\t                widgetFactories: new IdentityRegistry_1.default(),\n\t                widgetInstances: new IdentityRegistry_1.default()\n\t            });\n\t            if (defaultActionStore) {\n\t                instance.defaultActionStore = defaultActionStore;\n\t            }\n\t            if (defaultWidgetStore) {\n\t                instance.defaultWidgetStore = defaultWidgetStore;\n\t            }\n\t        }\n\t    });\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = createApp;\n\t});\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(23), __webpack_require__(28), __webpack_require__(8), __webpack_require__(31), __webpack_require__(91), __webpack_require__(89), __webpack_require__(88), __webpack_require__(87), __webpack_require__(93)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var array_1 = __webpack_require__(23);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var Set_1 = __webpack_require__(8);\n\t    var Map_1 = __webpack_require__(31);\n\t    var dom_1 = __webpack_require__(91);\n\t    var projector_1 = __webpack_require__(89);\n\t    var makeIdGenerator_1 = __webpack_require__(88);\n\t    var parseJsonAttribute_1 = __webpack_require__(87);\n\t    var resolveListenersMap_1 = __webpack_require__(93);\n\t    var reservedNames = new Set_1.default([\n\t        // According to <https://www.w3.org/TR/custom-elements/#valid-custom-element-name>.\n\t        'annotation-xml',\n\t        'color-profile',\n\t        'font-face',\n\t        'font-face-src',\n\t        'font-face-uri',\n\t        'font-face-format',\n\t        'font-face-name',\n\t        'missing-glyph'\n\t    ]);\n\t    // According to <https://www.w3.org/TR/custom-elements/#valid-custom-element-name>.\n\t    function isValidName(name) {\n\t        if (!/^[a-z]/.test(name)) {\n\t            return false;\n\t        }\n\t        if (name.indexOf('-') === -1) {\n\t            return false;\n\t        }\n\t        if (/[A-Z]/.test(name)) {\n\t            return false;\n\t        }\n\t        if (reservedNames.has(name)) {\n\t            return false;\n\t        }\n\t        if (/^app-/.test(name)) {\n\t            return false;\n\t        }\n\t        // Assume name does not contain other invalid characters.\n\t        // TODO: Are the above rules sufficiently exclusive given the allowed PCENChar characters in the\n\t        // <https://www.w3.org/TR/custom-elements/#valid-custom-element-name> specification?\n\t        return true;\n\t    }\n\t    exports.isValidName = isValidName;\n\t    // <https://www.w3.org/TR/custom-elements/#look-up-a-custom-element-definition> doesn't define *how* names\n\t    // are to be compared. Additionally browsers and document modes differ in the case used for Element#tagName\n\t    // values. Lowercasing the name is the most compatible solution. This is also the approach taken by the\n\t    // Web Components polyfill:\n\t    // <https://github.com/webcomponents/webcomponentsjs/blob/251f4afedec0ce649728fa1cf22e4fc16bf2bea5/src/CustomElements/register.js#L93>\n\t    function normalizeName(name) {\n\t        return name.toLowerCase();\n\t    }\n\t    exports.normalizeName = normalizeName;\n\t    function isCustomElement(registry, name) {\n\t        return name === 'app-projector' || name === 'app-widget' || registry.hasCustomElementFactory(name);\n\t    }\n\t    function getCustomElementsByWidgetProjector(registry, root) {\n\t        var allElements = array_1.from(root.getElementsByTagName('*'));\n\t        allElements.unshift(root); // Be inclusive!\n\t        var customElements = [];\n\t        for (var _i = 0, allElements_1 = allElements; _i < allElements_1.length; _i++) {\n\t            var element = allElements_1[_i];\n\t            var name_1 = void 0;\n\t            var tagName = normalizeName(element.tagName);\n\t            if (isCustomElement(registry, tagName)) {\n\t                name_1 = tagName;\n\t            }\n\t            else {\n\t                var attrIs = normalizeName(element.getAttribute('is') || '');\n\t                if (attrIs !== '' && isCustomElement(registry, attrIs)) {\n\t                    name_1 = attrIs;\n\t                }\n\t            }\n\t            if (name_1) {\n\t                customElements.push({ children: [], element: element, name: name_1 });\n\t            }\n\t        }\n\t        // A list of trees, reconstructed from the `customElements`.\n\t        var widgetProjectors = [];\n\t        // Inverse stack of the nodes in the current tree. The deepest node is at the start of the list.\n\t        var inverseStack = [];\n\t        var discardFirstNode = function (element) {\n\t            if (inverseStack.length === 0) {\n\t                return false;\n\t            }\n\t            // Return `true` if the top-most element in the stack does *not* contain `element`.\n\t            return !(inverseStack[0].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n\t        };\n\t        // `customElements` is a flat list of elements, in document order. Reconstruct a tree structure where each\n\t        // root is assumed to be a widget projector.\n\t        for (var _a = 0, customElements_1 = customElements; _a < customElements_1.length; _a++) {\n\t            var custom = customElements_1[_a];\n\t            // Remove nodes from the stack that do not contain the element.\n\t            while (discardFirstNode(custom.element)) {\n\t                inverseStack.shift();\n\t            }\n\t            // Start a new tree if the element is not contained in any existing node.\n\t            if (inverseStack.length === 0) {\n\t                // Don't costruct an invalid tree.\n\t                if (custom.name !== 'app-projector') {\n\t                    throw new Error('Custom tags must be rooted in a app-projector');\n\t                }\n\t                widgetProjectors.push(custom);\n\t            }\n\t            else {\n\t                // Don't costruct an invalid tree.\n\t                if (custom.name === 'app-projector') {\n\t                    throw new Error('app-projector cannot contain another app-projector');\n\t                }\n\t                inverseStack[0].children.push(custom);\n\t            }\n\t            // Prepare for the next iteration.\n\t            inverseStack.unshift(custom);\n\t        }\n\t        return widgetProjectors;\n\t    }\n\t    function getIdFromAttributes(element) {\n\t        return element.getAttribute('data-uid') || element.getAttribute('id') || undefined;\n\t    }\n\t    function resolveListeners(registry, element) {\n\t        var str = element.getAttribute('data-listeners');\n\t        if (!str) {\n\t            return null;\n\t        }\n\t        var listeners = parseJsonAttribute_1.default('data-listeners', str);\n\t        var valid = true;\n\t        // Prefer breaking a labeled loop over nesting Array#some() calls or repeating the throwing of\n\t        // the TypeError.\n\t        check: for (var eventType in listeners) {\n\t            var value = listeners[eventType];\n\t            if (Array.isArray(value)) {\n\t                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {\n\t                    var identifier = value_1[_i];\n\t                    if (typeof identifier !== 'string') {\n\t                        valid = false;\n\t                        break check;\n\t                    }\n\t                }\n\t            }\n\t            else if (typeof value !== 'string') {\n\t                valid = false;\n\t                break check;\n\t            }\n\t        }\n\t        if (!valid) {\n\t            throw new TypeError(\"Expected data-listeners to be a widget listeners map with action identifiers (in \" + JSON.stringify(str) + \")\");\n\t        }\n\t        return resolveListenersMap_1.default(registry, listeners);\n\t    }\n\t    function resolveOptions(registry, registryProvider, element, idFromAttributes) {\n\t        var str = element.getAttribute('data-options') || '';\n\t        if (!str) {\n\t            return idFromAttributes ? { id: idFromAttributes, registryProvider: registryProvider } : { registryProvider: registryProvider };\n\t        }\n\t        var json = parseJsonAttribute_1.default('data-options', str);\n\t        if ('id' in json) {\n\t            throw new Error(\"Unexpected id value in data-options (in \" + JSON.stringify(str) + \")\");\n\t        }\n\t        if ('listeners' in json) {\n\t            throw new Error(\"Unexpected listeners value in data-options (in \" + JSON.stringify(str) + \")\");\n\t        }\n\t        if ('registryProvider' in json) {\n\t            throw new Error(\"Unexpected registryProvider value in data-options (in \" + JSON.stringify(str) + \")\");\n\t        }\n\t        if ('state' in json) {\n\t            throw new Error(\"Unexpected state value in data-options (in \" + JSON.stringify(str) + \")\");\n\t        }\n\t        if ('stateFrom' in json) {\n\t            throw new Error(\"Unexpected stateFrom value in data-options (in \" + JSON.stringify(str) + \")\");\n\t        }\n\t        // Reassign, casted to the correct interface.\n\t        var options = json;\n\t        options.registryProvider = registryProvider;\n\t        if (idFromAttributes) {\n\t            options.id = idFromAttributes;\n\t        }\n\t        return options;\n\t    }\n\t    function getTransitionOptionFromProjector(element) {\n\t        if (!element.hasAttribute('data-css-transitions')) {\n\t            return false;\n\t        }\n\t        var value = element.getAttribute('data-css-transitions');\n\t        return value ? value === 'true' : true;\n\t    }\n\t    function resolveStateFromAttribute(registry, element) {\n\t        var stateFrom = element.getAttribute('data-state-from');\n\t        return stateFrom ? registry.getStore(stateFrom) : null;\n\t    }\n\t    function getInitialState(element) {\n\t        var str = element.getAttribute('data-state') || '';\n\t        if (!str) {\n\t            return null;\n\t        }\n\t        return parseJsonAttribute_1.default('data-state', str);\n\t    }\n\t    var generateId = makeIdGenerator_1.default('custom-element-');\n\t    /**\n\t     * Realizes custom elements within a root element.\n\t     *\n\t     * @param defaultWidgetStore The default widget store of the app, may be null.\n\t     * @param registerInstance Callback for registering new widget instances with the app\n\t     * @param registry Read-only registry of actions, custom element factories, stores and widgets\n\t     * @param registryProvider Registry provider, to be passed to custom element factories\n\t     * @param root The element within which custom elements are realized\n\t     *\n\t     * @return A handle to detach rendered widgets from the DOM and remove them from the widget registry\n\t     */\n\t    function realizeCustomElements(addIdentifier, registerInstance, registry, registryProvider, root, defaultWidgetStore) {\n\t        // Bottom up, breadth first queue of custom elements who's children's widgets need to be appended to\n\t        // their own widget. Combined for all widget projectors.\n\t        var appendQueue = [];\n\t        // For each projector, track the immediate custom element descendants. These placeholder\n\t        // elements will be replaced with rendered widgets.\n\t        var immediatePlaceholderLookup = new Map_1.default();\n\t        // Projector instances for each widget projector.\n\t        var projectors = [];\n\t        // Widgets that are created during realization (not registered instances).\n\t        var managedWidgets = [];\n\t        // Other handles that need to be cleaned up.\n\t        var handles = [];\n\t        // Return a new promise here so API errors can be thrown in the executor, while still resulting in a\n\t        // promise rejection.\n\t        return new Promise_1.default(function (resolve) {\n\t            // Flat list of all widgets that are being loaded.\n\t            var loadedWidgets = [];\n\t            var widgetProjectors = getCustomElementsByWidgetProjector(registry, root);\n\t            for (var _i = 0, widgetProjectors_1 = widgetProjectors; _i < widgetProjectors_1.length; _i++) {\n\t                var _a = widgetProjectors_1[_i], children = _a.children, root_1 = _a.element;\n\t                var cssTransitions = getTransitionOptionFromProjector(root_1);\n\t                var projector = projector_1.createProjector({ root: root_1, cssTransitions: cssTransitions });\n\t                immediatePlaceholderLookup.set(projector, children);\n\t                projectors.push(projector);\n\t                var projectorStateFrom = resolveStateFromAttribute(registry, root_1);\n\t                // Recursion-free, depth first processing of the tree.\n\t                var processing = [children];\n\t                while (true) {\n\t                    var next = processing.shift();\n\t                    if (!next) {\n\t                        break;\n\t                    }\n\t                    var _loop_1 = function(custom) {\n\t                        var isWidgetInstance = custom.name === 'app-widget';\n\t                        var id = getIdFromAttributes(custom.element);\n\t                        var promise = void 0;\n\t                        if (isWidgetInstance) {\n\t                            if (!id) {\n\t                                throw new Error('app-widget requires data-uid or id attribute');\n\t                            }\n\t                            promise = registry.getWidget(id);\n\t                        }\n\t                        else {\n\t                            promise = Promise_1.default.all([\n\t                                registry.getCustomElementFactory(custom.name),\n\t                                resolveListeners(registry, custom.element),\n\t                                resolveOptions(registry, registryProvider, custom.element, id),\n\t                                resolveStateFromAttribute(registry, custom.element),\n\t                                projectorStateFrom\n\t                            ]).then(function (_a) {\n\t                                var _factory = _a[0], _listeners = _a[1], _options = _a[2], _store = _a[3], projectorStore = _a[4];\n\t                                var factory = _factory;\n\t                                var listeners = _listeners;\n\t                                var options = _options;\n\t                                // `data-state-from` store of the element takes precedence, then of the projector, then\n\t                                // the application's default widget store.\n\t                                var store = _store || projectorStore || defaultWidgetStore;\n\t                                id = options.id;\n\t                                if (listeners) {\n\t                                    options.listeners = listeners;\n\t                                }\n\t                                // If the widget has an ID, and either its `data-state-from` attribute resolved to a store,\n\t                                // or there is a default store, set the stateFrom option to the `data-state-from` or default\n\t                                // widget store.\n\t                                if (id && store) {\n\t                                    options.stateFrom = store;\n\t                                    var initialState = getInitialState(custom.element);\n\t                                    if (initialState) {\n\t                                        return store.add(initialState, { id: id })\n\t                                            .catch(function () { return undefined; })\n\t                                            .then(function () { return factory(options); });\n\t                                    }\n\t                                }\n\t                                return factory(options);\n\t                            });\n\t                        }\n\t                        loadedWidgets.push(promise.then(function (widget) {\n\t                            // Store the widget for easy access.\n\t                            custom.widget = widget;\n\t                            // Widget instances come straight from the registry, but the other widgets were created\n\t                            // whilst realizing the custom elements. These should be managed.\n\t                            if (!isWidgetInstance) {\n\t                                managedWidgets.push(widget);\n\t                                // Assign a presumably unique ID if necessary. It's OK for the widget to not be aware of its\n\t                                // generated ID.\n\t                                if (!id) {\n\t                                    id = generateId();\n\t                                }\n\t                                // Belatedly ensure no other widget with this ID exists.\n\t                                handles.push(addIdentifier(id));\n\t                                // Add the instance to the various registries the app may maintain.\n\t                                try {\n\t                                    handles.push(registerInstance(widget, id));\n\t                                }\n\t                                catch (_) {\n\t                                    // registerInstance() will throw if the widget has already been registered. Throw a\n\t                                    // friendlier error message.\n\t                                    throw new Error('Cannot attach a widget multiple times');\n\t                                }\n\t                            }\n\t                            return widget;\n\t                        }));\n\t                        if (custom.children.length > 0) {\n\t                            // Ensure the children are processed.\n\t                            processing.push(custom.children);\n\t                            // Ensure the children are appended to their parent.\n\t                            appendQueue.unshift(custom);\n\t                        }\n\t                    };\n\t                    for (var _b = 0, next_1 = next; _b < next_1.length; _b++) {\n\t                        var custom = next_1[_b];\n\t                        _loop_1(custom);\n\t                    }\n\t                }\n\t            }\n\t            // Wait for all widgets to be loaded in parallel.\n\t            resolve(Promise_1.default.all(loadedWidgets));\n\t        }).then(function (widgets) {\n\t            // Guard against improper widget usage.\n\t            for (var _i = 0, widgets_1 = widgets; _i < widgets_1.length; _i++) {\n\t                var widget = widgets_1[_i];\n\t                // <any> hammer because `widget` could be anything.\n\t                if (widget.parent) {\n\t                    throw new Error('Cannot attach a widget that already has a parent');\n\t                }\n\t            }\n\t            // Build up the widget hierarchy.\n\t            for (var _a = 0, appendQueue_1 = appendQueue; _a < appendQueue_1.length; _a++) {\n\t                var custom = appendQueue_1[_a];\n\t                var widgets_2 = custom.children.map(function (child) { return child.widget; });\n\t                // Assume the widget has an append() method. Don't bother typing it since it's resolved dynamically anyway.\n\t                custom.widget.append(widgets_2);\n\t            }\n\t            // Attach all projectors at the same time.\n\t            var attachedProjectors = projectors.map(function (projector) {\n\t                var immediatePlaceholders = immediatePlaceholderLookup.get(projector);\n\t                immediatePlaceholderLookup.delete(projector);\n\t                // Append the top-level widgets to the projector.\n\t                projector.append(immediatePlaceholders.map(function (custom) { return custom.widget; }));\n\t                // Get ready to replace the placeholder elements as soon as the widgets have rendered.\n\t                var handle = projector.on('attach', function () {\n\t                    handle.destroy();\n\t                    var root = projector.root;\n\t                    // Rendered widgets start at this offset.\n\t                    var offset = root.childNodes.length - immediatePlaceholders.length;\n\t                    for (var _i = 0, immediatePlaceholders_1 = immediatePlaceholders; _i < immediatePlaceholders_1.length; _i++) {\n\t                        var placeholder = immediatePlaceholders_1[_i].element;\n\t                        dom_1.place(root.childNodes[offset], dom_1.Position.Replace, placeholder);\n\t                    }\n\t                });\n\t                // Now attach the projector.\n\t                return projector.attach({ type: 'merge' });\n\t            });\n\t            // Wait for the projectors to be attached.\n\t            return Promise_1.default.all(attachedProjectors);\n\t        }).then(function () {\n\t            return {\n\t                destroy: function () {\n\t                    for (var _i = 0, projectors_1 = projectors; _i < projectors_1.length; _i++) {\n\t                        var p = projectors_1[_i];\n\t                        p.destroy();\n\t                    }\n\t                    for (var _a = 0, managedWidgets_1 = managedWidgets; _a < managedWidgets_1.length; _a++) {\n\t                        var w = managedWidgets_1[_a];\n\t                        w.destroy();\n\t                    }\n\t                    for (var _b = 0, handles_1 = handles; _b < handles_1.length; _b++) {\n\t                        var h = handles_1[_b];\n\t                        h.destroy();\n\t                    }\n\t                }\n\t            };\n\t        });\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = realizeCustomElements;\n\t    ;\n\t});\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    function parseJsonAttribute(name, value) {\n\t        var object;\n\t        try {\n\t            object = JSON.parse(value);\n\t        }\n\t        catch (err) {\n\t            throw new SyntaxError(\"Invalid \" + name + \": \" + err.message + \" (in \" + JSON.stringify(value) + \")\");\n\t        }\n\t        if (!object || typeof object !== 'object') {\n\t            throw new TypeError(\"Expected object from \" + name + \" (in \" + JSON.stringify(value) + \")\");\n\t        }\n\t        return object;\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = parseJsonAttribute;\n\t});\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    function makeIdGenerator(prefix) {\n\t        var count = 0;\n\t        return function () { return prefix + (++count); };\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = makeIdGenerator;\n\t});\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(40), __webpack_require__(20), __webpack_require__(27), __webpack_require__(25), __webpack_require__(90), __webpack_require__(28), __webpack_require__(22), __webpack_require__(7), __webpack_require__(80)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var maquette_1 = __webpack_require__(40);\n\t    var compose_1 = __webpack_require__(20);\n\t    var global_1 = __webpack_require__(27);\n\t    var lang_1 = __webpack_require__(25);\n\t    var queue_1 = __webpack_require__(90);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var createVNodeEvented_1 = __webpack_require__(7);\n\t    var createParentListMixin_1 = __webpack_require__(80);\n\t    (function (ProjectorState) {\n\t        ProjectorState[ProjectorState[\"Attached\"] = 1] = \"Attached\";\n\t        ProjectorState[ProjectorState[\"Detached\"] = 2] = \"Detached\";\n\t    })(exports.ProjectorState || (exports.ProjectorState = {}));\n\t    var ProjectorState = exports.ProjectorState;\n\t    ;\n\t    var projectorDataMap = new WeakMap_1.default();\n\t    var noopHandle = { destroy: function () { } };\n\t    var emptyVNode = maquette_1.h('div');\n\t    var noopVNode = function () { return emptyVNode; };\n\t    exports.createProjector = compose_1.default({\n\t        getNodeAttributes: function (overrides) {\n\t            /* TODO: This is the same logic as createCachedRenderMixin, merge somehow */\n\t            var props = {};\n\t            for (var key in this.listeners) {\n\t                props[key] = this.listeners[key];\n\t            }\n\t            var classes = {};\n\t            if (this.classes) {\n\t                this.classes.forEach(function (c) { return classes[c] = true; });\n\t            }\n\t            props.classes = classes;\n\t            props.styles = this.styles || {};\n\t            if (overrides) {\n\t                lang_1.assign(props, overrides);\n\t            }\n\t            return props;\n\t        },\n\t        render: function () {\n\t            var projectorData = projectorDataMap.get(this);\n\t            var childVNodes = [];\n\t            this.children.forEach(function (child) {\n\t                // Workaround for https://github.com/facebook/immutable-js/pull/919\n\t                // istanbul ignore else\n\t                if (child) {\n\t                    childVNodes.push(child.render());\n\t                }\n\t            });\n\t            var props = this.getNodeAttributes();\n\t            props.afterCreate = projectorData.afterInitialCreate;\n\t            return maquette_1.h(projectorData.tagName, props, childVNodes);\n\t        },\n\t        attach: function (_a) {\n\t            var _this = this;\n\t            var _b = _a === void 0 ? {} : _a, type = _b.type, tagName = _b.tagName;\n\t            var projectorData = projectorDataMap.get(this);\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                return projectorData.attachPromise || Promise_1.default.resolve(noopHandle);\n\t            }\n\t            projectorData.boundRender = this.render.bind(this);\n\t            if (tagName !== undefined) {\n\t                projectorData.tagName = tagName;\n\t            }\n\t            projectorData.state = ProjectorState.Attached;\n\t            projectorData.attachHandle = this.own({\n\t                destroy: function () {\n\t                    if (projectorData.state === ProjectorState.Attached) {\n\t                        projectorData.projector.stop();\n\t                        try {\n\t                            /* Sometimes Maquette can't seem to find function */\n\t                            projectorData.projector.detach(projectorData.boundRender);\n\t                        }\n\t                        catch (e) {\n\t                            if (e.message !== 'renderMaquetteFunction was not found') {\n\t                                throw e;\n\t                            }\n\t                        }\n\t                        /* for some reason, Maquette still trys to call this in some situations, so the noopVNode is\n\t                         * used to return an empty structure */\n\t                        projectorData.boundRender = noopVNode;\n\t                        projectorData.state = ProjectorState.Detached;\n\t                    }\n\t                    projectorData.attachHandle = noopHandle;\n\t                }\n\t            });\n\t            projectorData.attachPromise = new Promise_1.default(function (resolve, reject) {\n\t                projectorData.afterInitialCreate = function () {\n\t                    try {\n\t                        _this.emit({ type: 'attach' });\n\t                        resolve(projectorData.attachHandle);\n\t                    }\n\t                    catch (err) {\n\t                        reject(err);\n\t                    }\n\t                };\n\t            });\n\t            /* attaching async, in order to help ensure that if there are any other async behaviours scheduled at the end of the\n\t             * turn, they are executed before this, since the attachement is actually done in turn, but subsequent schedule\n\t             * renders are done out of turn */\n\t            queue_1.queueTask(function () {\n\t                var projector = projectorData.projector;\n\t                switch (type) {\n\t                    case 'append':\n\t                        projector.append(projectorData.root, projectorData.boundRender);\n\t                        break;\n\t                    case 'replace':\n\t                        projector.replace(projectorData.root, projectorData.boundRender);\n\t                        break;\n\t                    case 'merge':\n\t                    default:\n\t                        projector.merge(projectorData.root, projectorData.boundRender);\n\t                        break;\n\t                }\n\t            });\n\t            return projectorData.attachPromise;\n\t        },\n\t        invalidate: function () {\n\t            var projectorData = projectorDataMap.get(this);\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                this.emit({\n\t                    type: 'schedulerender',\n\t                    target: this\n\t                });\n\t                projectorData.projector.scheduleRender();\n\t            }\n\t        },\n\t        setRoot: function (root) {\n\t            var projectorData = projectorDataMap.get(this);\n\t            if (projectorData.state === ProjectorState.Attached) {\n\t                throw new Error('Projector already attached, cannot change root element');\n\t            }\n\t            projectorData.root = root;\n\t        },\n\t        get root() {\n\t            var projectorData = projectorDataMap.get(this);\n\t            return projectorData && projectorData.root;\n\t        },\n\t        get projector() {\n\t            return projectorDataMap.get(this).projector;\n\t        },\n\t        get document() {\n\t            var projectorData = projectorDataMap.get(this);\n\t            return projectorData && projectorData.root && projectorData.root.ownerDocument;\n\t        },\n\t        get state() {\n\t            var projectorData = projectorDataMap.get(this);\n\t            return projectorData && projectorData.state;\n\t        }\n\t    })\n\t        .mixin({\n\t        mixin: createVNodeEvented_1.default,\n\t        initialize: function (instance) {\n\t            /* We have to stub out listeners for Maquette, otherwise it won't allow us to change them down the road */\n\t            instance.on('touchend', function () { });\n\t            instance.on('touchmove', function () { });\n\t        }\n\t    })\n\t        .mixin({\n\t        mixin: createParentListMixin_1.default,\n\t        initialize: function (instance, _a) {\n\t            var _b = _a === void 0 ? {} : _a, _c = _b.cssTransitions, cssTransitions = _c === void 0 ? false : _c, _d = _b.autoAttach, autoAttach = _d === void 0 ? false : _d, _e = _b.root, root = _e === void 0 ? document.body : _e;\n\t            var options = {};\n\t            if (cssTransitions) {\n\t                if (global_1.default.cssTransitions) {\n\t                    options.transitions = global_1.default.cssTransitions;\n\t                }\n\t                else {\n\t                    throw new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n\t                }\n\t            }\n\t            var projector = maquette_1.createProjector(options);\n\t            projectorDataMap.set(instance, {\n\t                attachHandle: noopHandle,\n\t                boundRender: noopVNode,\n\t                projector: projector,\n\t                root: root,\n\t                state: ProjectorState.Detached,\n\t                tagName: 'div'\n\t            });\n\t            if (autoAttach === true) {\n\t                instance.attach({ type: 'merge' });\n\t            }\n\t            else if (typeof autoAttach === 'string') {\n\t                instance.attach({ type: autoAttach });\n\t            }\n\t        },\n\t        aspectAdvice: {\n\t            after: {\n\t                clear: function () {\n\t                    this.invalidate();\n\t                }\n\t            }\n\t        }\n\t    });\n\t    // Projectors cannot be created outside of browser environments. Ensure that a default projector can always be\n\t    // exported, even if it can't do anything.\n\t    var createStubbedProjector = compose_1.default({\n\t        getNodeAttributes: function () {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        render: function () {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        attach: function () {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        invalidate: function () {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        setRoot: function (root) {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        get projector() {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        get root() {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        get document() {\n\t            throw new Error('Projector is stubbed');\n\t        },\n\t        get state() {\n\t            throw new Error('Projector is stubbed');\n\t        }\n\t    })\n\t        .mixin(createVNodeEvented_1.default)\n\t        .mixin(createParentListMixin_1.default);\n\t    var defaultProjector = typeof global_1.default.document === 'undefined' ?\n\t        createStubbedProjector() :\n\t        exports.createProjector();\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = defaultProjector;\n\t});\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(27), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var global_1 = __webpack_require__(27);\n\t    var has_1 = __webpack_require__(26);\n\t    function executeTask(item) {\n\t        if (item && item.isActive && item.callback) {\n\t            item.callback();\n\t        }\n\t    }\n\t    function getQueueHandle(item, destructor) {\n\t        return {\n\t            destroy: function () {\n\t                this.destroy = function () { };\n\t                item.isActive = false;\n\t                item.callback = null;\n\t                if (destructor) {\n\t                    destructor();\n\t                }\n\t            }\n\t        };\n\t    }\n\t    var checkMicroTaskQueue;\n\t    var microTasks;\n\t    /**\n\t     * Schedules a callback to the macrotask queue.\n\t     *\n\t     * @param callback the function to be queued and later executed.\n\t     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t     */\n\t    exports.queueTask = (function () {\n\t        var destructor;\n\t        var enqueue;\n\t        // Since the IE implementation of `setImmediate` is not flawless, we will test for `postMessage` first.\n\t        if (has_1.default('postmessage')) {\n\t            var queue_1 = [];\n\t            global_1.default.addEventListener('message', function (event) {\n\t                // Confirm that the event was triggered by the current window and by this particular implementation.\n\t                if (event.source === global_1.default && event.data === 'dojo-queue-message') {\n\t                    event.stopPropagation();\n\t                    if (queue_1.length) {\n\t                        executeTask(queue_1.shift());\n\t                    }\n\t                }\n\t            });\n\t            enqueue = function (item) {\n\t                queue_1.push(item);\n\t                global_1.default.postMessage('dojo-queue-message', '*');\n\t            };\n\t        }\n\t        else if (has_1.default('setimmediate')) {\n\t            destructor = global_1.default.clearImmediate;\n\t            enqueue = function (item) {\n\t                return setImmediate(executeTask.bind(null, item));\n\t            };\n\t        }\n\t        else {\n\t            destructor = global_1.default.clearTimeout;\n\t            enqueue = function (item) {\n\t                return setTimeout(executeTask.bind(null, item), 0);\n\t            };\n\t        }\n\t        function queueTask(callback) {\n\t            var item = {\n\t                isActive: true,\n\t                callback: callback\n\t            };\n\t            var id = enqueue(item);\n\t            return getQueueHandle(item, destructor && function () {\n\t                destructor(id);\n\t            });\n\t        }\n\t        ;\n\t        // TODO: Use aspect.before when it is available.\n\t        return has_1.default('microtasks') ? queueTask : function (callback) {\n\t            checkMicroTaskQueue();\n\t            return queueTask(callback);\n\t        };\n\t    })();\n\t    // When no mechanism for registering microtasks is exposed by the environment, microtasks will\n\t    // be queued and then executed in a single macrotask before the other macrotasks are executed.\n\t    if (!has_1.default('microtasks')) {\n\t        var isMicroTaskQueued_1 = false;\n\t        microTasks = [];\n\t        checkMicroTaskQueue = function () {\n\t            if (!isMicroTaskQueued_1) {\n\t                isMicroTaskQueued_1 = true;\n\t                exports.queueTask(function () {\n\t                    isMicroTaskQueued_1 = false;\n\t                    if (microTasks.length) {\n\t                        var item = void 0;\n\t                        while (item = microTasks.shift()) {\n\t                            executeTask(item);\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        };\n\t    }\n\t    /**\n\t     * Schedules an animation task with `window.requestAnimationFrame` if it exists, or with `queueTask` otherwise.\n\t     *\n\t     * Since requestAnimationFrame's behavior does not match that expected from `queueTask`, it is not used there.\n\t     * However, at times it makes more sense to delegate to requestAnimationFrame; hence the following method.\n\t     *\n\t     * @param callback the function to be queued and later executed.\n\t     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t     */\n\t    exports.queueAnimationTask = (function () {\n\t        if (!has_1.default('raf')) {\n\t            return exports.queueTask;\n\t        }\n\t        function queueAnimationTask(callback) {\n\t            var item = {\n\t                isActive: true,\n\t                callback: callback\n\t            };\n\t            var rafId = requestAnimationFrame(executeTask.bind(null, item));\n\t            return getQueueHandle(item, function () {\n\t                cancelAnimationFrame(rafId);\n\t            });\n\t        }\n\t        // TODO: Use aspect.before when it is available.\n\t        return has_1.default('microtasks') ? queueAnimationTask : function (callback) {\n\t            checkMicroTaskQueue();\n\t            return queueAnimationTask(callback);\n\t        };\n\t    })();\n\t    /**\n\t     * Schedules a callback to the microtask queue.\n\t     *\n\t     * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n\t     * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n\t     * registered with `queueTask` or `queueAnimationTask`.\n\t     *\n\t     * @param callback the function to be queued and later executed.\n\t     * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n\t     */\n\t    exports.queueMicroTask = (function () {\n\t        var enqueue;\n\t        if (has_1.default('host-node')) {\n\t            enqueue = function (item) {\n\t                global_1.default.process.nextTick(executeTask.bind(null, item));\n\t            };\n\t        }\n\t        else if (has_1.default('es6-promise')) {\n\t            enqueue = function (item) {\n\t                global_1.default.Promise.resolve(item).then(executeTask);\n\t            };\n\t        }\n\t        else if (has_1.default('dom-mutationobserver')) {\n\t            /* tslint:disable-next-line:variable-name */\n\t            var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;\n\t            var node_1 = document.createElement('div');\n\t            var queue_2 = [];\n\t            var observer = new HostMutationObserver(function () {\n\t                while (queue_2.length > 0) {\n\t                    var item = queue_2.shift();\n\t                    if (item && item.isActive && item.callback) {\n\t                        item.callback();\n\t                    }\n\t                }\n\t            });\n\t            observer.observe(node_1, { attributes: true });\n\t            enqueue = function (item) {\n\t                queue_2.push(item);\n\t                node_1.setAttribute('queueStatus', '1');\n\t            };\n\t        }\n\t        else {\n\t            enqueue = function (item) {\n\t                checkMicroTaskQueue();\n\t                microTasks.push(item);\n\t            };\n\t        }\n\t        return function (callback) {\n\t            var item = {\n\t                isActive: true,\n\t                callback: callback\n\t            };\n\t            enqueue(item);\n\t            return getQueueHandle(item);\n\t        };\n\t    })();\n\t});\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30).setImmediate))\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(92)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var has_1 = __webpack_require__(92);\n\t    /**\n\t     * Validates a token for the CSS class manipulation methods.\n\t     */\n\t    function validateToken(token) {\n\t        if (token === '') {\n\t            throw new Error('An invalid or illegal string was specified');\n\t        }\n\t        if (/\\s/.test(token)) {\n\t            throw new Error('String contains an invalid character');\n\t        }\n\t    }\n\t    /**\n\t     * Adds one or more CSS class names to an HTMLElement, without duplication.\n\t     *\n\t     * @param element The Element to which to add CSS classes\n\t     * @param classes One or more CSS class strings to add to the Element\n\t     *\n\t     * @example\n\t     * dom.addClass(document.body, 'loaded');\n\t     *\n\t     * @example\n\t     * dom.addClass(document.body, 'loaded', 'ready');\n\t     */\n\t    function addClass(element) {\n\t        var classes = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            classes[_i - 1] = arguments[_i];\n\t        }\n\t        // Cast to <any> to support multiple Element types. For more info,\n\t        // see https://github.com/Microsoft/TypeScript/issues/3220\n\t        var targetElement = element;\n\t        if (!targetElement || !classes.length) {\n\t            return;\n\t        }\n\t        var newClasses = [];\n\t        for (var _a = 0, classes_1 = classes; _a < classes_1.length; _a++) {\n\t            var className = classes_1[_a];\n\t            validateToken(className);\n\t            if (!containsClass(targetElement, className)) {\n\t                // Convert to string to match native classList implementations for values like null\n\t                newClasses.push(String(className));\n\t            }\n\t        }\n\t        if (newClasses.length) {\n\t            targetElement.className += (targetElement.className.length ? ' ' : '') + newClasses.join(' ');\n\t        }\n\t    }\n\t    exports.addClass = addClass;\n\t    /**\n\t     * Applies CSS classes to the root element if the specified has features have truthy values.\n\t     *\n\t     * @param features One or more features to test and potentially apply CSS classes based on\n\t     */\n\t    function applyFeatureClass() {\n\t        var features = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            features[_i - 0] = arguments[_i];\n\t        }\n\t        // args will be applied to addClass, so start with the element classes will be added to\n\t        var args = [document.documentElement];\n\t        for (var _a = 0, features_1 = features; _a < features_1.length; _a++) {\n\t            var feature = features_1[_a];\n\t            if (has_1.default(feature)) {\n\t                args.push('has-' + feature.replace(/\\s/g, '-'));\n\t            }\n\t        }\n\t        addClass.apply(null, args);\n\t    }\n\t    exports.applyFeatureClass = applyFeatureClass;\n\t    /**\n\t     * Retrieves an element from the document by its ID attribute.\n\t     *\n\t     * @param id ID to match in the DOM\n\t     * @return the element with a matching ID attribute if found, otherwise null\n\t     *\n\t     * @example\n\t     * let element = dom.byId('anElement');\n\t     */\n\t    function byId(id) {\n\t        return document.getElementById(id);\n\t    }\n\t    exports.byId = byId;\n\t    /**\n\t     * Indicates whether the given parent contains the given node.\n\t     * @param parent The parent node to check within\n\t     * @param node The node to test whether parent is its ancestor\n\t     * @return `true` if parent contains node, `false` otherwise\n\t     */\n\t    function contains(parent, node) {\n\t        // While modern browsers do support parent.contains, some support it only on HTML elements,\n\t        // and IE has a known bug involving passing a text node as the argument:\n\t        // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n\t        // Meanwhile, compareDocumentPosition works in all supported browsers.\n\t        if (node == null) {\n\t            return false;\n\t        }\n\t        if (parent === node) {\n\t            return true;\n\t        }\n\t        return Boolean(node.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS);\n\t    }\n\t    exports.contains = contains;\n\t    /*\n\t     * Creates an Element.\n\t     *\n\t     * @param tagName Type of Element to create\n\t     * @param kwArgs An object containing properties to add to the Element.\n\t     *               If an \"attributes\" property is present, each member of this sub-object will be added to the Element\n\t     *               via element.setAttribute\n\t     * @param children An array of Nodes or strings, the latter of which will be converted to Text nodes\n\t     * @return The created Element, with any passed properties/attributes applied\n\t     *\n\t     * @example\n\t     * let div = dom.create('div', { className: 'loaded', attributes: { 'data-index': '1' } });\n\t     *\n\t     * @example\n\t     * let div = dom.create('ul', null, [ dom.create('li'), dom.create('li') ]);\n\t     *\n\t     * @example\n\t     * let div = dom.create('div', null, [ 'hello', ' ', 'world' ]);\n\t     */\n\t    exports.create = function (tagName, kwArgs, children) {\n\t        var element = document.createElement(tagName);\n\t        if (children) {\n\t            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n\t                var child = children_1[_i];\n\t                if (typeof child === 'string') {\n\t                    child = document.createTextNode(child);\n\t                }\n\t                element.appendChild(child);\n\t            }\n\t        }\n\t        if (kwArgs) {\n\t            for (var property in kwArgs) {\n\t                if (property === 'attributes') {\n\t                    if (kwArgs.attributes) {\n\t                        for (var attribute in kwArgs.attributes) {\n\t                            element.setAttribute(attribute, kwArgs.attributes[attribute]);\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    element[property] = kwArgs[property];\n\t                }\n\t            }\n\t        }\n\t        return element;\n\t    };\n\t    // Tag trees for element creation, used by fromString\n\t    var tagWrap = {\n\t        caption: ['table'],\n\t        col: ['table', 'colgroup'],\n\t        colgroup: ['table'],\n\t        optgroup: ['select'],\n\t        option: ['select'],\n\t        rp: ['ruby'],\n\t        rt: ['ruby'],\n\t        rtc: ['ruby'],\n\t        source: ['audio'],\n\t        tbody: ['table'],\n\t        td: ['table', 'tbody', 'tr'],\n\t        tfoot: ['table'],\n\t        th: ['table', 'thead', 'tr'],\n\t        thead: ['table'],\n\t        tr: ['table', 'tbody']\n\t    };\n\t    for (var param in tagWrap) {\n\t        var tw = tagWrap[param];\n\t        tw.pre = param === 'option' ? '<select multiple=\"multiple\">' : '<' + tw.join('><') + '>';\n\t        tw.post = '</' + tw.reverse().join('></') + '>';\n\t    }\n\t    /**\n\t     * Determines whether an HTMLElement has a given CSS class name.\n\t     *\n\t     * @param element The Element to check for a CSS class\n\t     * @param className The CSS class name to check for\n\t     *\n\t     * @example\n\t     * let hasLoaded = dom.containsClass(document.body, 'loaded');\n\t     */\n\t    function containsClass(element, className) {\n\t        var targetElement = element;\n\t        if (!targetElement) {\n\t            return;\n\t        }\n\t        validateToken(className);\n\t        var targetClass = ' ' + targetElement.className + ' ';\n\t        return targetClass.indexOf(' ' + className + ' ') > -1;\n\t    }\n\t    exports.containsClass = containsClass;\n\t    /**\n\t     * Creates a DocumentFragment from a string.\n\t     *\n\t     * @param html string representation of nodes to create\n\t     * @return DocumentFragment containing childNodes based on html string\n\t     *\n\t     * @example\n\t     * let fragment = dom.fromString('<div></div>');\n\t     *\n\t     * @example\n\t     * let fragment = dom.fromString('<div></div><span></span>');\n\t     *\n\t     * @example\n\t     * let fragment = dom.fromString('<tr>');\n\t     */\n\t    function fromString(html) {\n\t        var fragment;\n\t        var useContextualFragment = has_1.default('dom-contextual-fragment');\n\t        var master = document.createElement('div');\n\t        var match = String(html).match(/<\\s*([\\w\\:]+)/);\n\t        var tag = match ? match[1].toLowerCase() : '';\n\t        function unwrapElement(element, levels) {\n\t            for (var i = 0; i < levels; i++) {\n\t                element = element.firstChild;\n\t            }\n\t            return element;\n\t        }\n\t        if (useContextualFragment) {\n\t            master.style.display = 'none';\n\t            document.body.appendChild(master);\n\t            var range = document.createRange();\n\t            range.selectNode(master);\n\t            if (match && tagWrap[tag]) {\n\t                var wrap = tagWrap[tag];\n\t                var wrappedHTML = wrap.pre + html + wrap.post;\n\t                fragment = range.createContextualFragment(wrappedHTML);\n\t                fragment = unwrapElement(fragment, wrap.length);\n\t            }\n\t            else {\n\t                fragment = range.createContextualFragment(html);\n\t            }\n\t        }\n\t        else {\n\t            if (match && tagWrap[tag]) {\n\t                var wrap = tagWrap[tag];\n\t                var wrappedHTML = wrap.pre + html + wrap.post;\n\t                master.innerHTML = wrappedHTML;\n\t                master = unwrapElement(master, wrap.length);\n\t            }\n\t            else {\n\t                master.innerHTML = html;\n\t            }\n\t            fragment = document.createDocumentFragment();\n\t            var firstChild = void 0;\n\t            while (firstChild = master.firstChild) {\n\t                fragment.appendChild(firstChild);\n\t            }\n\t        }\n\t        return fragment;\n\t    }\n\t    exports.fromString = fromString;\n\t    /*\n\t     * Positions used with the place API for node placement.\n\t     */\n\t    (function (Position) {\n\t        Position[Position[\"After\"] = 0] = \"After\";\n\t        Position[Position[\"Before\"] = 1] = \"Before\";\n\t        Position[Position[\"FirstIn\"] = 2] = \"FirstIn\";\n\t        Position[Position[\"LastIn\"] = 3] = \"LastIn\";\n\t        Position[Position[\"Replace\"] = 4] = \"Replace\";\n\t    })(exports.Position || (exports.Position = {}));\n\t    var Position = exports.Position;\n\t    /**\n\t     * Places a node in the DOM relative to another node.\n\t     *\n\t     * @param node The node to place in the DOM\n\t     * @param position The position to place the node, relative to relativeElement\n\t     * @param relativeElement The node to use as a reference when placing\n\t     *\n\t     * @example\n\t     * dom.place(node, dom.Position.After, anotherNode);\n\t     */\n\t    function place(node, position, relativeElement) {\n\t        var parent;\n\t        if (position === Position.After || position === Position.Before || position === Position.Replace) {\n\t            parent = relativeElement.parentNode;\n\t            if (!parent) {\n\t                throw new ReferenceError('dom.place: Reference node must have a parent to determine placement');\n\t            }\n\t            if (position === Position.After) {\n\t                if (parent.lastChild === relativeElement) {\n\t                    parent.appendChild(node);\n\t                }\n\t                else {\n\t                    parent.insertBefore(node, relativeElement.nextSibling);\n\t                }\n\t            }\n\t            else if (position === Position.Before) {\n\t                parent.insertBefore(node, relativeElement);\n\t            }\n\t            else if (position === Position.Replace) {\n\t                parent.replaceChild(node, relativeElement);\n\t            }\n\t        }\n\t        else if (position === Position.FirstIn) {\n\t            relativeElement.insertBefore(node, relativeElement.firstChild);\n\t        }\n\t        else {\n\t            // LastIn\n\t            relativeElement.appendChild(node);\n\t        }\n\t    }\n\t    exports.place = place;\n\t    /**\n\t     * Removes a node from the DOM.\n\t     *\n\t     * @param node The node to remove\n\t     */\n\t    function remove(node) {\n\t        if (node.parentNode) {\n\t            node.parentNode.removeChild(node);\n\t        }\n\t    }\n\t    exports.remove = remove;\n\t    /**\n\t     * Removes all instances of one ore more CSS class names from an HTMLElement.\n\t     *\n\t     * @param element The Element from which to remove CSS classes\n\t     * @param classes An array of string CSS classes to remove from the Element\n\t     *\n\t     * @example\n\t     * dom.removeClass(document.body, 'loading');\n\t     *\n\t     * @example\n\t     * dom.removeClass(document.body, 'loading', 'pending');\n\t     */\n\t    function removeClass(element) {\n\t        var classes = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            classes[_i - 1] = arguments[_i];\n\t        }\n\t        var targetElement = element;\n\t        if (!targetElement) {\n\t            return;\n\t        }\n\t        var oldClasses = targetElement.className.split(/\\s+/);\n\t        var length = oldClasses.length;\n\t        for (var _a = 0, classes_2 = classes; _a < classes_2.length; _a++) {\n\t            var className = classes_2[_a];\n\t            className = String(className);\n\t            validateToken(className);\n\t            var index = oldClasses.indexOf(className);\n\t            while (index !== -1) {\n\t                oldClasses.splice(index, 1);\n\t                index = oldClasses.indexOf(className);\n\t            }\n\t        }\n\t        if (oldClasses.length < length) {\n\t            targetElement.className = oldClasses.join(' ');\n\t        }\n\t    }\n\t    exports.removeClass = removeClass;\n\t    /**\n\t     * Toggles the presence of a CSS class name on an HTMLElement. An optional\n\t     * second parameter can be used to force class addition or removal.\n\t     *\n\t     * @param element The Element to add or remove classes to or from\n\t     * @param className The CSS class name add or remove\n\t     * @param force Forces either class addition if true or class removal if false\n\t     *\n\t     * @example\n\t     * dom.toggleClass(button, 'active');\n\t     *\n\t     * @example\n\t     * dom.toggleClass(button, 'active', isActive);\n\t     */\n\t    function toggleClass(element, className, force) {\n\t        if (force === void 0) { force = !containsClass(element, className); }\n\t        var func = force ? addClass : removeClass;\n\t        func(element, className);\n\t        return force;\n\t    }\n\t    exports.toggleClass = toggleClass;\n\t});\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(26), __webpack_require__(26), __webpack_require__(26)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    function __export(m) {\n\t        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n\t    }\n\t    var has_1 = __webpack_require__(26);\n\t    has_1.add('dom-element-matches', function () {\n\t        var node = document.body;\n\t        // TS typings include the vendor-prefixed methods used here, but not the standard\n\t        if (typeof node.matches === 'function') {\n\t            return 'matches';\n\t        }\n\t        if (typeof node.msMatchesSelector === 'function') {\n\t            return 'msMatchesSelector';\n\t        }\n\t        if (typeof node.webkitMatchesSelector === 'function') {\n\t            return 'webkitMatchesSelector';\n\t        }\n\t    });\n\t    has_1.add('dom-contextual-fragment', function () {\n\t        return Boolean(Range && Range.prototype.createContextualFragment);\n\t    });\n\t    var has_2 = __webpack_require__(26);\n\t    exports.default = has_2.default;\n\t    __export(__webpack_require__(26));\n\t});\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(28)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var Promise_1 = __webpack_require__(28);\n\t    function carriesValue(result) {\n\t        return result[0] !== undefined;\n\t    }\n\t    function withoutPromises(mixed) {\n\t        return mixed.containsPromises !== true;\n\t    }\n\t    function resolveListeners(registry, ref) {\n\t        if (Array.isArray(ref)) {\n\t            var mixed = [];\n\t            for (var _i = 0, ref_1 = ref; _i < ref_1.length; _i++) {\n\t                var item = ref_1[_i];\n\t                var result = resolveListeners(registry, item);\n\t                if (carriesValue(result)) {\n\t                    mixed.push(result[0]);\n\t                }\n\t                else {\n\t                    mixed.containsPromises = true;\n\t                    mixed.push(result[1]);\n\t                }\n\t            }\n\t            var flattened_1 = [];\n\t            if (withoutPromises(mixed)) {\n\t                return [flattened_1.concat.apply(flattened_1, mixed), undefined];\n\t            }\n\t            return [\n\t                undefined,\n\t                Promise_1.default.all(mixed)\n\t                    .then(function (results) { return flattened_1.concat.apply(flattened_1, results); })\n\t            ];\n\t        }\n\t        if (typeof ref !== 'string') {\n\t            return [[ref], undefined];\n\t        }\n\t        return [\n\t            undefined,\n\t            registry.getAction(ref).then(function (action) { return [action]; })\n\t        ];\n\t    }\n\t    function resolveListenersMap(registry, listeners) {\n\t        if (!listeners) {\n\t            return null;\n\t        }\n\t        var map = {};\n\t        var eventTypes = Object.keys(listeners);\n\t        return eventTypes.reduce(function (promise, eventType) {\n\t            var result = resolveListeners(registry, listeners[eventType]);\n\t            if (carriesValue(result)) {\n\t                var arr = result[0];\n\t                map[eventType] = arr.length > 1 ? arr : arr[0];\n\t                return promise;\n\t            }\n\t            return result[1].then(function (arr) {\n\t                map[eventType] = arr.length > 1 ? arr : arr[0];\n\t                return promise;\n\t            });\n\t        }, Promise_1.default.resolve(map));\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = resolveListenersMap;\n\t});\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(28), __webpack_require__(9)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var Promise_1 = __webpack_require__(28);\n\t    var Symbol_1 = __webpack_require__(9);\n\t    /**\n\t     * Special value that can be provided to the module resolver, indicating it should resolve the module contents, not\n\t     * just a particular export.\n\t     */\n\t    exports.RESOLVE_CONTENTS = Symbol_1.default();\n\t    /**\n\t     * Creates a module resolver.\n\t     *\n\t     * @param toAbsMid Function to resolve relative module identifiers\n\t     * @return The resolver function\n\t     */\n\t    function makeResolver(toAbsMid) {\n\t        return function resolveMid(mid, member) {\n\t            if (member === void 0) { member = 'default'; }\n\t            return new Promise_1.default(function (resolve) {\n\t                // Assumes require() is an AMD loader!\n\t                __webpack_require__.e/* require */(1, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\".\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())]; (resolve.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}.bind(this));\n\t            })\n\t                .then(function (module) {\n\t                if (member === 'default') {\n\t                    return module.__esModule ? module.default : module;\n\t                }\n\t                else if (member === exports.RESOLVE_CONTENTS) {\n\t                    var contents = {};\n\t                    for (var _i = 0, _a = Object.keys(module); _i < _a.length; _i++) {\n\t                        var member_1 = _a[_i];\n\t                        if (member_1 !== '__esModule' && member_1 !== 'default') {\n\t                            contents[member_1] = module[member_1];\n\t                        }\n\t                    }\n\t                    return contents;\n\t                }\n\t                else {\n\t                    return module[member];\n\t                }\n\t            });\n\t        };\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = makeResolver;\n\t});\n\n\n/***/ },\n/* 95 */,\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(22)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var Type;\n\t    (function (Type) {\n\t        Type[Type[\"Action\"] = 0] = \"Action\";\n\t        Type[Type[\"Store\"] = 1] = \"Store\";\n\t        Type[Type[\"Widget\"] = 2] = \"Widget\";\n\t    })(Type || (Type = {}));\n\t    ;\n\t    var errorStrings = (_a = {},\n\t        _a[Type.Action] = 'action',\n\t        _a[Type.Store] = 'store',\n\t        _a[Type.Widget] = 'widget',\n\t        _a\n\t    );\n\t    var InstanceRegistry = (function () {\n\t        function InstanceRegistry() {\n\t            this.map = new WeakMap_1.default();\n\t        }\n\t        InstanceRegistry.prototype.addAction = function (action, id) {\n\t            return this.add(action, id, Type.Action);\n\t        };\n\t        InstanceRegistry.prototype.identifyAction = function (action) {\n\t            return this.identify(action, Type.Action);\n\t        };\n\t        InstanceRegistry.prototype.addStore = function (store, id) {\n\t            return this.add(store, id, Type.Store);\n\t        };\n\t        InstanceRegistry.prototype.identifyStore = function (store) {\n\t            return this.identify(store, Type.Store);\n\t        };\n\t        InstanceRegistry.prototype.addWidget = function (widget, id) {\n\t            return this.add(widget, id, Type.Widget);\n\t        };\n\t        InstanceRegistry.prototype.identifyWidget = function (widget) {\n\t            return this.identify(widget, Type.Widget);\n\t        };\n\t        InstanceRegistry.prototype.add = function (instance, id, type) {\n\t            var _this = this;\n\t            if (this.map.has(instance)) {\n\t                var existing = this.map.get(instance);\n\t                throw new Error(\"Could not add \" + errorStrings[type] + \", already registered as \" + errorStrings[existing.type] + \" with identity \" + existing.id);\n\t            }\n\t            this.map.set(instance, { id: id, type: type });\n\t            var handle = {\n\t                destroy: function () {\n\t                    _this.map.delete(instance);\n\t                }\n\t            };\n\t            return handle;\n\t        };\n\t        InstanceRegistry.prototype.identify = function (instance, expectedType) {\n\t            if (!this.map.has(instance)) {\n\t                throw new Error(\"Could not identify \" + errorStrings[expectedType]);\n\t            }\n\t            var _a = this.map.get(instance), id = _a.id, type = _a.type;\n\t            if (type !== expectedType) {\n\t                throw new Error(\"Could not identify \" + errorStrings[expectedType]);\n\t            }\n\t            return id;\n\t        };\n\t        return InstanceRegistry;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = InstanceRegistry;\n\t    var _a;\n\t});\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(25), __webpack_require__(28), __webpack_require__(93)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var lang_1 = __webpack_require__(25);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var resolveListenersMap_1 = __webpack_require__(93);\n\t    function resolveStore(registry, definition) {\n\t        var stateFrom = definition.stateFrom;\n\t        if (!stateFrom) {\n\t            return null;\n\t        }\n\t        if (typeof stateFrom !== 'string') {\n\t            return stateFrom;\n\t        }\n\t        return registry.getStore(stateFrom);\n\t    }\n\t    var errorStrings = {\n\t        action: 'an action',\n\t        customElement: 'a widget',\n\t        store: 'a store',\n\t        widget: 'a widget'\n\t    };\n\t    function isInstance(value) {\n\t        return value && typeof value === 'object';\n\t    }\n\t    function resolveFactory(type, definition, resolveMid) {\n\t        var _a = definition, factory = _a.factory, instance = _a.instance;\n\t        if (typeof factory === 'function') {\n\t            return Promise_1.default.resolve(factory);\n\t        }\n\t        else if (isInstance(instance)) {\n\t            // Cast to Factory since TypeScript gets confused with the overloaded Factory types that can return promises.\n\t            var factory_1 = (function () { return instance; });\n\t            return Promise_1.default.resolve(factory_1);\n\t        }\n\t        else {\n\t            return new Promise_1.default(function (resolve, reject) {\n\t                if (instance) {\n\t                    resolveMid(instance)\n\t                        .then(function (defaultExport) {\n\t                        if (!defaultExport || typeof defaultExport !== 'object') {\n\t                            reject(new Error(\"Could not resolve '\" + instance + \"' to \" + errorStrings[type] + \" instance\"));\n\t                        }\n\t                        else {\n\t                            resolve(function () { return defaultExport; });\n\t                        }\n\t                    })\n\t                        .catch(reject);\n\t                }\n\t                else {\n\t                    // Calling code ensures that factory at this point is a string, even though TypeScript can't infer that.\n\t                    resolveMid(factory)\n\t                        .then(function (defaultExport) {\n\t                        if (typeof defaultExport !== 'function') {\n\t                            reject(new Error(\"Could not resolve '\" + factory + \"' to \" + errorStrings[type] + \" factory function\"));\n\t                        }\n\t                        else {\n\t                            resolve(defaultExport);\n\t                        }\n\t                    })\n\t                        .catch(reject);\n\t                }\n\t            });\n\t        }\n\t    }\n\t    function makeActionFactory(definition, resolveMid, registry) {\n\t        if (!('factory' in definition || 'instance' in definition)) {\n\t            throw new TypeError('Action definitions must specify either the factory or instance option');\n\t        }\n\t        if ('instance' in definition) {\n\t            if ('state' in definition) {\n\t                throw new TypeError('Cannot specify state option when action definition points directly at an instance');\n\t            }\n\t            if ('stateFrom' in definition) {\n\t                throw new TypeError('Cannot specify stateFrom option when action definition points directly at an instance');\n\t            }\n\t        }\n\t        var id = definition.id, initialState = definition.state;\n\t        return function (_a) {\n\t            var registryProvider = _a.registryProvider, defaultActionStore = _a.stateFrom;\n\t            return Promise_1.default.all([\n\t                resolveFactory('action', definition, resolveMid),\n\t                resolveStore(registry, definition)\n\t            ]).then(function (_a) {\n\t                var _factory = _a[0], _store = _a[1];\n\t                var factory = _factory;\n\t                var store = _store || defaultActionStore;\n\t                var options = { registryProvider: registryProvider, stateFrom: store };\n\t                if (store && initialState) {\n\t                    return store.add(initialState, { id: id })\n\t                        .catch(function () { })\n\t                        .then(function () { return factory(options); });\n\t                }\n\t                return factory(options);\n\t            });\n\t        };\n\t    }\n\t    exports.makeActionFactory = makeActionFactory;\n\t    function makeCustomElementFactory(definition, resolveMid) {\n\t        var promise = null;\n\t        var factory;\n\t        return function (options) {\n\t            if (factory) {\n\t                return factory(options);\n\t            }\n\t            if (!promise) {\n\t                // Memoize the factory resolution.\n\t                promise = resolveFactory('customElement', definition, resolveMid).then(function (result) {\n\t                    factory = result;\n\t                    promise = null;\n\t                });\n\t            }\n\t            return promise.then(function () {\n\t                return factory(options);\n\t            });\n\t        };\n\t    }\n\t    exports.makeCustomElementFactory = makeCustomElementFactory;\n\t    function makeStoreFactory(definition, resolveMid) {\n\t        if (!('factory' in definition || 'instance' in definition)) {\n\t            throw new TypeError('Store definitions must specify either the factory or instance option');\n\t        }\n\t        if ('instance' in definition && 'options' in definition) {\n\t            throw new TypeError('Cannot specify options when store definition points directly at an instance');\n\t        }\n\t        var options = lang_1.assign({}, definition.options);\n\t        return function () {\n\t            return resolveFactory('store', definition, resolveMid).then(function (factory) {\n\t                return factory(options);\n\t            });\n\t        };\n\t    }\n\t    exports.makeStoreFactory = makeStoreFactory;\n\t    function makeWidgetFactory(definition, resolveMid, registry) {\n\t        if (!('factory' in definition || 'instance' in definition)) {\n\t            throw new TypeError('Widget definitions must specify either the factory or instance option');\n\t        }\n\t        if ('instance' in definition) {\n\t            if ('listeners' in definition) {\n\t                throw new TypeError('Cannot specify listeners option when widget definition points directly at an instance');\n\t            }\n\t            if ('state' in definition) {\n\t                throw new TypeError('Cannot specify state option when widget definition points directly at an instance');\n\t            }\n\t            if ('stateFrom' in definition) {\n\t                throw new TypeError('Cannot specify stateFrom option when widget definition points directly at an instance');\n\t            }\n\t            if ('options' in definition) {\n\t                throw new TypeError('Cannot specify options when widget definition points directly at an instance');\n\t            }\n\t        }\n\t        var rawOptions = definition.options;\n\t        if (rawOptions) {\n\t            if ('id' in rawOptions || 'listeners' in rawOptions || 'stateFrom' in rawOptions) {\n\t                throw new TypeError('id, listeners and stateFrom options should be in the widget definition itself, not its options value');\n\t            }\n\t            if ('registryProvider' in rawOptions) {\n\t                throw new TypeError('registryProvider option must not be specified');\n\t            }\n\t        }\n\t        return function (_a) {\n\t            var registryProvider = _a.registryProvider, defaultWidgetStore = _a.stateFrom;\n\t            var id = definition.id, initialState = definition.state;\n\t            var options = lang_1.assign({\n\t                id: id,\n\t                registryProvider: registryProvider\n\t            }, rawOptions);\n\t            return Promise_1.default.all([\n\t                resolveFactory('widget', definition, resolveMid),\n\t                resolveListenersMap_1.default(registry, definition.listeners),\n\t                resolveStore(registry, definition)\n\t            ]).then(function (_a) {\n\t                var _factory = _a[0], _listeners = _a[1], _store = _a[2];\n\t                var factory = _factory;\n\t                var listeners = _listeners;\n\t                var store = _store || defaultWidgetStore;\n\t                if (listeners) {\n\t                    options.listeners = listeners;\n\t                }\n\t                if (store) {\n\t                    options.stateFrom = store;\n\t                }\n\t                if (store && initialState) {\n\t                    return store.add(initialState, { id: id })\n\t                        .catch(function () { return undefined; })\n\t                        .then(function () { return factory(options); });\n\t                }\n\t                return factory(options);\n\t            });\n\t        };\n\t    }\n\t    exports.makeWidgetFactory = makeWidgetFactory;\n\t});\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(91), __webpack_require__(23), __webpack_require__(28), __webpack_require__(8), __webpack_require__(94), __webpack_require__(87)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var dom_1 = __webpack_require__(91);\n\t    var array_1 = __webpack_require__(23);\n\t    var Promise_1 = __webpack_require__(28);\n\t    var Set_1 = __webpack_require__(8);\n\t    var moduleResolver_1 = __webpack_require__(94);\n\t    var parseJsonAttribute_1 = __webpack_require__(87);\n\t    function isFactoryResolver(resolver) {\n\t        return resolver.factory;\n\t    }\n\t    function get(element, name) {\n\t        var value = element.getAttribute(name);\n\t        return value === null ? undefined : value;\n\t    }\n\t    var TAG_NAMES = new Set_1.default(['app-action', 'app-actions', 'app-element', 'app-store', 'app-widget']);\n\t    var parsers = {\n\t        action: function (element) {\n\t            var id = get(element, 'data-uid') || get(element, 'id');\n\t            var factory = get(element, 'data-factory');\n\t            var from = get(element, 'data-from');\n\t            var importName = get(element, 'data-import');\n\t            var stateFrom = get(element, 'data-state-from');\n\t            var stateJson = get(element, 'data-state');\n\t            if (factory && !id) {\n\t                throw new Error('app-action requires data-uid or id attribute if data-factory is given');\n\t            }\n\t            if (!factory && !from) {\n\t                throw new Error('app-action requires data-from attribute if data-factory is not given');\n\t            }\n\t            if (factory && from) {\n\t                throw new Error('app-action cannot be used with both data-from and data-factory attributes');\n\t            }\n\t            if (stateFrom && !factory) {\n\t                throw new Error('app-action requires data-factory attribute if data-state-from is given');\n\t            }\n\t            if (stateJson && !factory) {\n\t                throw new Error('app-action requires data-factory attribute if data-state is given');\n\t            }\n\t            if (from && !id) {\n\t                if (importName) {\n\t                    id = importName;\n\t                }\n\t                else {\n\t                    id = from.split('/').pop();\n\t                }\n\t            }\n\t            if (!id) {\n\t                throw new Error(\"Could not determine ID for app-action (from=\" + from + \" and import=\" + importName + \")\");\n\t            }\n\t            var resolver = factory ? { factory: factory } : { from: from, importName: importName };\n\t            var state = stateJson ? parseJsonAttribute_1.default('data-state', stateJson) : undefined;\n\t            return {\n\t                element: element,\n\t                id: id,\n\t                resolver: resolver,\n\t                state: state,\n\t                stateFrom: stateFrom,\n\t                type: 'action'\n\t            };\n\t        },\n\t        actions: function (element) {\n\t            var from = get(element, 'data-from');\n\t            if (!from) {\n\t                throw new Error('app-actions requires data-from attribute');\n\t            }\n\t            return {\n\t                element: element,\n\t                from: from,\n\t                type: 'multiple-actions'\n\t            };\n\t        },\n\t        element: function (element) {\n\t            var factory = get(element, 'data-factory');\n\t            var name = get(element, 'data-name');\n\t            if (!factory) {\n\t                throw new Error('app-element requires data-factory');\n\t            }\n\t            if (!name) {\n\t                throw new Error('app-element requires data-name');\n\t            }\n\t            return {\n\t                element: element,\n\t                factory: factory,\n\t                name: name,\n\t                type: 'element'\n\t            };\n\t        },\n\t        store: function (element) {\n\t            var id = get(element, 'data-uid') || get(element, 'id');\n\t            var factory = get(element, 'data-factory');\n\t            var from = get(element, 'data-from');\n\t            var importName = get(element, 'data-import');\n\t            var type = get(element, 'data-type');\n\t            var optionsJson = get(element, 'data-options');\n\t            if (factory && !id && !type) {\n\t                throw new Error('app-store requires data-uid, id or data-type attribute if data-factory is given');\n\t            }\n\t            if (!factory && !from) {\n\t                throw new Error('app-store requires data-from attribute if data-factory is not given');\n\t            }\n\t            if (factory && from) {\n\t                throw new Error('app-store cannot be used with both data-from and data-factory attributes');\n\t            }\n\t            if (type && id) {\n\t                throw new Error('data-type attribute must not be provided if app-store has data-uid or id attribute');\n\t            }\n\t            if (type && type !== 'action' && type !== 'widget') {\n\t                throw new Error('data-type attribute of app-store must have a value of \\'action\\' or \\'widget\\'');\n\t            }\n\t            if (optionsJson && !factory) {\n\t                throw new Error('app-store requires data-factory attribute if data-options is given');\n\t            }\n\t            if (from && !type && !id) {\n\t                if (importName) {\n\t                    id = importName;\n\t                }\n\t                else {\n\t                    id = from.split('/').pop();\n\t                }\n\t            }\n\t            if (!type && !id) {\n\t                throw new Error(\"Could not determine ID for app-store (from=\" + from + \" and import=\" + importName + \")\");\n\t            }\n\t            var options = optionsJson ? parseJsonAttribute_1.default('data-options', optionsJson) : undefined;\n\t            var resolver = factory ? { factory: factory } : { from: from, importName: importName };\n\t            var isDefault = Boolean(type);\n\t            if (isDefault) {\n\t                id = type;\n\t            }\n\t            return {\n\t                id: id,\n\t                isDefault: isDefault,\n\t                element: element,\n\t                options: options,\n\t                resolver: resolver,\n\t                type: 'store'\n\t            };\n\t        },\n\t        widget: function (element) {\n\t            var id = get(element, 'data-uid') || get(element, 'id');\n\t            var factory = get(element, 'data-factory');\n\t            var from = get(element, 'data-from');\n\t            var importName = get(element, 'data-import');\n\t            var listenersJson = get(element, 'data-listeners');\n\t            var optionsJson = get(element, 'data-options');\n\t            var stateFrom = get(element, 'data-state-from');\n\t            var stateJson = get(element, 'data-state');\n\t            if (stateFrom && !factory) {\n\t                throw new Error('app-widget requires data-factory attribute if data-state-from is given');\n\t            }\n\t            if (listenersJson && !factory) {\n\t                throw new Error('app-widget requires data-factory attribute if data-listeners is given');\n\t            }\n\t            if (optionsJson && !factory) {\n\t                throw new Error('app-widget requires data-factory attribute if data-options is given');\n\t            }\n\t            if (stateJson && !factory) {\n\t                throw new Error('app-widget requires data-factory attribute if data-state is given');\n\t            }\n\t            // Without factory or from, assume the widget has already been defined elsewhere.\n\t            if (!factory && !from) {\n\t                return null;\n\t            }\n\t            if (factory && from) {\n\t                throw new Error('app-widget cannot be used with both data-from and data-factory attributes');\n\t            }\n\t            if (factory && !id) {\n\t                throw new Error('app-widget requires data-uid or id attribute if data-factory is given');\n\t            }\n\t            if (from && !id) {\n\t                if (importName) {\n\t                    id = importName;\n\t                }\n\t                else {\n\t                    id = from.split('/').pop();\n\t                }\n\t            }\n\t            if (!id) {\n\t                throw new Error(\"Could not determine ID for app-widget (from=\" + from + \" and import=\" + importName + \")\");\n\t            }\n\t            var listeners = listenersJson ? parseJsonAttribute_1.default('data-listeners', listenersJson) : undefined;\n\t            var options = optionsJson ? parseJsonAttribute_1.default('data-options', optionsJson) : undefined;\n\t            var state = stateJson ? parseJsonAttribute_1.default('data-state', stateJson) : undefined;\n\t            var resolver = factory ? { factory: factory } : { from: from, importName: importName };\n\t            return {\n\t                element: element,\n\t                id: id,\n\t                listeners: listeners,\n\t                options: options,\n\t                resolver: resolver,\n\t                state: state,\n\t                stateFrom: stateFrom,\n\t                type: 'widget'\n\t            };\n\t        }\n\t    };\n\t    function getRegistrationTasks(root) {\n\t        var allElements = array_1.from(root.getElementsByTagName('*'));\n\t        allElements.unshift(root); // Be inclusive!\n\t        var tasks = [];\n\t        for (var _i = 0, allElements_1 = allElements; _i < allElements_1.length; _i++) {\n\t            var element = allElements_1[_i];\n\t            var name_1 = void 0;\n\t            var tagName = element.tagName.toLowerCase();\n\t            if (TAG_NAMES.has(tagName)) {\n\t                name_1 = tagName;\n\t            }\n\t            else {\n\t                var attrIs = (get(element, 'is') || '').toLowerCase();\n\t                if (TAG_NAMES.has(attrIs)) {\n\t                    name_1 = attrIs;\n\t                }\n\t            }\n\t            var task = null;\n\t            switch (name_1) {\n\t                case 'app-action':\n\t                    task = parsers.action(element);\n\t                    break;\n\t                case 'app-actions':\n\t                    task = parsers.actions(element);\n\t                    break;\n\t                case 'app-element':\n\t                    task = parsers.element(element);\n\t                    break;\n\t                case 'app-store':\n\t                    task = parsers.store(element);\n\t                    break;\n\t                case 'app-widget':\n\t                    task = parsers.widget(element);\n\t                    break;\n\t            }\n\t            if (task) {\n\t                tasks.push(task);\n\t            }\n\t        }\n\t        return tasks;\n\t    }\n\t    function createActionDefinition(resolveMid, _a) {\n\t        var id = _a.id, resolver = _a.resolver, state = _a.state, stateFrom = _a.stateFrom;\n\t        return {\n\t            id: id,\n\t            factory: function (options) {\n\t                if (isFactoryResolver(resolver)) {\n\t                    return resolveMid(resolver.factory).then(function (factory) {\n\t                        return factory(options);\n\t                    });\n\t                }\n\t                else {\n\t                    return resolveMid(resolver.from, resolver.importName || 'default');\n\t                }\n\t            },\n\t            state: state,\n\t            stateFrom: stateFrom\n\t        };\n\t    }\n\t    function loadMultipleActions(resolveMid, _a) {\n\t        var from = _a.from;\n\t        return resolveMid(from, moduleResolver_1.RESOLVE_CONTENTS).then(function (contents) {\n\t            return Object.keys(contents).map(function (member) {\n\t                return {\n\t                    id: member,\n\t                    instance: contents[member]\n\t                };\n\t            });\n\t        });\n\t    }\n\t    function createCustomElementDefinition(resolveMid, _a) {\n\t        var factory = _a.factory, name = _a.name;\n\t        return {\n\t            factory: function (options) {\n\t                return resolveMid(factory)\n\t                    .then(function (factory) { return factory(options); });\n\t            },\n\t            name: name\n\t        };\n\t    }\n\t    function createStoreDefinition(resolveMid, _a) {\n\t        var id = _a.id, options = _a.options, resolver = _a.resolver;\n\t        return {\n\t            id: id,\n\t            factory: function (options) {\n\t                if (isFactoryResolver(resolver)) {\n\t                    return resolveMid(resolver.factory)\n\t                        .then(function (factory) { return factory(options); });\n\t                }\n\t                else {\n\t                    return resolveMid(resolver.from, resolver.importName || 'default');\n\t                }\n\t            },\n\t            options: options\n\t        };\n\t    }\n\t    function createWidgetDefinition(resolveMid, _a) {\n\t        var id = _a.id, listeners = _a.listeners, options = _a.options, resolver = _a.resolver, state = _a.state, stateFrom = _a.stateFrom;\n\t        return {\n\t            id: id,\n\t            factory: function (options) {\n\t                if (isFactoryResolver(resolver)) {\n\t                    return resolveMid(resolver.factory)\n\t                        .then(function (factory) { return factory(options); });\n\t                }\n\t                else {\n\t                    return resolveMid(resolver.from, resolver.importName || 'default');\n\t                }\n\t            },\n\t            listeners: listeners,\n\t            options: options,\n\t            state: state,\n\t            stateFrom: stateFrom\n\t        };\n\t    }\n\t    /**\n\t     * Extract action, custom element, store and widget definitions that should be loaded into the app.\n\t     *\n\t     * @param resolveMid Function to asynchronously resolve a module identifier\n\t     * @param root The element within which registration elements can be found\n\t     * @return A promise for the definition objects\n\t     */\n\t    function extractRegistrationElements(resolveMid, root) {\n\t        return new Promise_1.default(function (resolve, reject) {\n\t            var result = {\n\t                actions: [],\n\t                customElements: [],\n\t                defaultStores: [],\n\t                stores: [],\n\t                widgets: []\n\t            };\n\t            var promises = [];\n\t            for (var _i = 0, _a = getRegistrationTasks(root); _i < _a.length; _i++) {\n\t                var task = _a[_i];\n\t                switch (task.type) {\n\t                    case 'action':\n\t                        result.actions.push(createActionDefinition(resolveMid, task));\n\t                        break;\n\t                    case 'element':\n\t                        result.customElements.push(createCustomElementDefinition(resolveMid, task));\n\t                        break;\n\t                    case 'multiple-actions': {\n\t                        var promise = loadMultipleActions(resolveMid, task)\n\t                            .then(function (actions) {\n\t                            (_a = result.actions).push.apply(_a, actions);\n\t                            var _a;\n\t                        });\n\t                        promises.push(promise);\n\t                        break;\n\t                    }\n\t                    case 'store': {\n\t                        var isDefault = task.isDefault;\n\t                        var definition = createStoreDefinition(resolveMid, task);\n\t                        if (isDefault) {\n\t                            result.defaultStores.push(definition);\n\t                        }\n\t                        else {\n\t                            result.stores.push(definition);\n\t                        }\n\t                        break;\n\t                    }\n\t                    case 'widget':\n\t                        result.widgets.push(createWidgetDefinition(resolveMid, task));\n\t                        // Forcibly add the possibly derived ID to the element, so the <app-widget> can be realized.\n\t                        task.element.setAttribute('data-uid', task.id);\n\t                        break;\n\t                }\n\t                if (task.type !== 'widget') {\n\t                    dom_1.remove(task.element);\n\t                }\n\t            }\n\t            if (promises.length > 0) {\n\t                Promise_1.default.all(promises)\n\t                    .then(function () { return resolve(result); })\n\t                    .catch(reject);\n\t            }\n\t            else {\n\t                resolve(result);\n\t            }\n\t        });\n\t    }\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = extractRegistrationElements;\n\t});\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    /**\n\t     * Provides access to read-only registries for actions, stores and widgets.\n\t     */\n\t    var RegistryProvider = (function () {\n\t        function RegistryProvider(registry) {\n\t            this.underlyingRegistry = Object.freeze({\n\t                getAction: registry.getAction.bind(registry),\n\t                identifyAction: registry.identifyAction.bind(registry),\n\t                getStore: registry.getStore.bind(registry),\n\t                identifyStore: registry.identifyStore.bind(registry),\n\t                createWidget: registry.createWidget.bind(registry),\n\t                getWidget: registry.getWidget.bind(registry),\n\t                hasWidget: registry.hasWidget.bind(registry),\n\t                identifyWidget: registry.identifyWidget.bind(registry)\n\t            });\n\t        }\n\t        RegistryProvider.prototype.get = function (type) {\n\t            switch (type) {\n\t                case 'actions':\n\t                    return this.actionRegistry || (this.actionRegistry = {\n\t                        get: this.underlyingRegistry.getAction,\n\t                        identify: this.underlyingRegistry.identifyAction\n\t                    });\n\t                case 'stores':\n\t                    return this.storeRegistry || (this.storeRegistry = {\n\t                        get: this.underlyingRegistry.getStore,\n\t                        identify: this.underlyingRegistry.identifyStore\n\t                    });\n\t                case 'widgets':\n\t                    return this.widgetRegistry || (this.widgetRegistry = {\n\t                        create: this.underlyingRegistry.createWidget,\n\t                        get: this.underlyingRegistry.getWidget,\n\t                        has: this.underlyingRegistry.hasWidget,\n\t                        identify: this.underlyingRegistry.identifyWidget\n\t                    });\n\t                default:\n\t                    throw new Error(\"No such store: \" + type);\n\t            }\n\t        };\n\t        return RegistryProvider;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = RegistryProvider;\n\t});\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {\n\t    if (typeof module === 'object' && typeof module.exports === 'object') {\n\t        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n\t    }\n\t    else if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(31), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t})(function (require, exports) {\n\t    \"use strict\";\n\t    var Map_1 = __webpack_require__(31);\n\t    var WeakMap_1 = __webpack_require__(22);\n\t    var noop = function () { };\n\t    var privateStateMap = new WeakMap_1.default();\n\t    function getState(instance) {\n\t        return privateStateMap.get(instance);\n\t    }\n\t    /**\n\t     * A registry of values, mapped by identities.\n\t     */\n\t    var IdentityRegistry = (function () {\n\t        function IdentityRegistry() {\n\t            privateStateMap.set(this, {\n\t                entryMap: new Map_1.default(),\n\t                idMap: new WeakMap_1.default()\n\t            });\n\t        }\n\t        /**\n\t         * Look up a value by its identifier.\n\t         *\n\t         * Throws if no value has been registered for the given identifier.\n\t         *\n\t         * @param id The identifier\n\t         * @return The value\n\t         */\n\t        IdentityRegistry.prototype.get = function (id) {\n\t            var entry = getState(this).entryMap.get(id);\n\t            if (!entry) {\n\t                throw new Error(\"Could not find a value for identity '\" + id.toString() + \"'\");\n\t            }\n\t            return entry.value;\n\t        };\n\t        /**\n\t         * Determine whether the value has been registered.\n\t         * @param value The value\n\t         * @return `true` if the value has been registered, `false` otherwise\n\t         */\n\t        IdentityRegistry.prototype.contains = function (value) {\n\t            return getState(this).idMap.has(value);\n\t        };\n\t        /**\n\t         * Remove from the registry the value for a given identifier.\n\t         * @param id The identifier\n\t         * @return `true` if the value was removed, `false` otherwise\n\t         */\n\t        IdentityRegistry.prototype.delete = function (id) {\n\t            var entry = getState(this).entryMap.get(id);\n\t            if (!entry) {\n\t                return false;\n\t            }\n\t            entry.handle.destroy();\n\t            return true;\n\t        };\n\t        /**\n\t         * Determine whether a value has been registered for the given identifier.\n\t         * @param id The identifier\n\t         * @return `true` if a value has been registered, `false` otherwise\n\t         */\n\t        IdentityRegistry.prototype.has = function (id) {\n\t            return getState(this).entryMap.has(id);\n\t        };\n\t        /**\n\t         * Look up the identifier for which the given value has been registered.\n\t         *\n\t         * Throws if the value hasn't been registered.\n\t         *\n\t         * @param value The value\n\t         * @return The identifier otherwise\n\t         */\n\t        IdentityRegistry.prototype.identify = function (value) {\n\t            if (!this.contains(value)) {\n\t                throw new Error('Could not identify non-registered value');\n\t            }\n\t            return getState(this).idMap.get(value);\n\t        };\n\t        /**\n\t         * Register a new value with a new identity.\n\t         *\n\t         * Throws if a different value has already been registered for the given identity,\n\t         * or if the value has already been registered with a different identity.\n\t         *\n\t         * @param id The identifier\n\t         * @param value The value\n\t         * @return A handle for deregistering the value. Note that when called repeatedly with\n\t         *   the same identifier and value combination, the same handle is returned\n\t         */\n\t        IdentityRegistry.prototype.register = function (id, value) {\n\t            var _this = this;\n\t            var entryMap = getState(this).entryMap;\n\t            var existingEntry = entryMap.get(id);\n\t            if (existingEntry && existingEntry.value !== value) {\n\t                var str = id.toString();\n\t                throw new Error(\"A value has already been registered for the given identity (\" + str + \")\");\n\t            }\n\t            var existingId = this.contains(value) ? this.identify(value) : null;\n\t            if (existingId && existingId !== id) {\n\t                var str = existingId.toString();\n\t                throw new Error(\"The value has already been registered with a different identity (\" + str + \")\");\n\t            }\n\t            // Adding the same value with the same id is a noop, return the original handle.\n\t            if (existingEntry && existingId) {\n\t                return existingEntry.handle;\n\t            }\n\t            var handle = {\n\t                destroy: function () {\n\t                    handle.destroy = noop;\n\t                    getState(_this).entryMap.delete(id);\n\t                }\n\t            };\n\t            entryMap.set(id, { handle: handle, value: value });\n\t            getState(this).idMap.set(value, id);\n\t            return handle;\n\t        };\n\t        return IdentityRegistry;\n\t    }());\n\t    Object.defineProperty(exports, \"__esModule\", { value: true });\n\t    exports.default = IdentityRegistry;\n\t    ;\n\t});\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// src/main.js"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({}[chunkId]||chunkId) + \".js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8faf4fb77a7b09923762","import createApp from 'dojo-app/createApp';\nimport global from 'dojo-core/global';\nimport ShimPromise from 'dojo-shim/Promise';\nimport createPanel from 'dojo-widgets/createPanel';\nimport createWidget from 'dojo-widgets/createWidget';\n\nimport { todoToggleAll, todoInput } from './actions/userActions';\nimport router from './routes';\nimport todoStore, { bindActions as bindTodoStoreActions } from './stores/todoStore';\nimport widgetStore from './stores/widgetStore';\nimport createCheckboxInput from './widgets/createCheckboxInput';\nimport createFocusableTextInput from './widgets/createFocusableTextInput';\nimport createTodoFooter from './widgets/createTodoFooter';\nimport createTodoItem from './widgets/createTodoItem';\nimport createTodoList from './widgets/createTodoList';\n\nconst app = createApp({ defaultWidgetStore: widgetStore });\n\napp.registerStore('todo-store', todoStore);\napp.loadDefinition({\n\twidgets: [\n\t\t{\n\t\t\tid: 'new-todo',\n\t\t\tfactory: createFocusableTextInput,\n\t\t\tlisteners: {\n\t\t\t\tkeypress: todoInput\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 'main-section',\n\t\t\tfactory: createPanel,\n\t\t\toptions: {\n\t\t\t\ttagName: 'section'\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 'todo-list',\n\t\t\tfactory: createTodoList\n\t\t},\n\t\t{\n\t\t\tid: 'todo-toggle',\n\t\t\tfactory: createCheckboxInput,\n\t\t\tlisteners: {\n\t\t\t\tchange: todoToggleAll\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tid: 'todo-footer',\n\t\t\tfactory: createTodoFooter\n\t\t}\n\t],\n\tcustomElements: [\n\t\t{\n\t\t\tname: 'dojo-widget',\n\t\t\tfactory: createWidget\n\t\t},\n\t\t{\n\t\t\tname: 'todo-item',\n\t\t\tfactory: createTodoItem\n\t\t}\n\t]\n});\n\n// Try to use the native promise so the browser can report unhandled rejections.\nconst { /* tslint:disable */Promise/* tslint:enable */ = ShimPromise } = global;\nPromise.resolve(app.realize(document.body))\n\t.then(() => bindTodoStoreActions())\n\t.then(() => router.start());\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.ts","import WeakMap from 'dojo-shim/WeakMap';\nimport createButton from 'dojo-widgets/createButton';\nimport createRenderMixin, { RenderMixin, RenderMixinState, RenderMixinOptions } from 'dojo-widgets/mixins/createRenderMixin';\nimport createStatefulChildrenMixin, { StatefulChildrenState, StatefulChildrenOptions, CreateChildrenResults, CreateChildrenResultsItem } from 'dojo-widgets/mixins/createStatefulChildrenMixin';\nimport { Child } from 'dojo-widgets/mixins/interfaces';\n\nimport { h, VNode } from 'maquette';\n\nimport {\n\ttodoEdit,\n\ttodoEditInput,\n\ttodoRemove,\n\ttodoSave,\n\ttodoToggleComplete\n} from '../actions/userActions';\nimport createCheckboxInput from './createCheckboxInput';\nimport createFocusableTextInput from './createFocusableTextInput';\n\ntype TodoItemState = RenderMixinState & StatefulChildrenState & {\n\tediting?: boolean;\n\tcompleted?: boolean;\n};\n\nexport type TodoItemOptions = RenderMixinOptions<TodoItemState> & StatefulChildrenOptions<Child, TodoItemState>;\n\nexport type TodoItem = RenderMixin<TodoItemState>;\n\ninterface TodoItemChildren<C extends Child> extends CreateChildrenResults<C> {\n\tlabel: CreateChildrenResultsItem<C>;\n\tcheckbox: CreateChildrenResultsItem<C>;\n\teditInput: CreateChildrenResultsItem<C>;\n\tbutton: CreateChildrenResultsItem<C>;\n}\n\n/**\n * Internal map of sub children IDs\n */\nconst childrenMap = new WeakMap<TodoItem, TodoItemChildren<RenderMixin<any>>>();\n\n/**\n * Internal function to manage the children widgets\n */\nfunction manageChildren(this: TodoItem) {\n\t/* Obtain references to children widgets */\n\tconst { checkbox, label, editInput } = childrenMap.get(this);\n\n\t/* Adjust the state of the children to reflect parent */\n\n\tlabel.widget.setState({\n\t\tlabel: this.state.label\n\t});\n\n\teditInput.widget.setState({\n\t\tvalue: this.state.label,\n\t\tfocused: this.state.editing\n\t});\n\n\tcheckbox.widget.setState({\n\t\tchecked: this.state.completed\n\t});\n}\n\nconst createTodoItem = createRenderMixin\n\t.mixin({\n\t\tmixin: createStatefulChildrenMixin,\n\t\tinitialize(instance, options) {\n\t\t\tlet destroyed = false;\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tdestroyed = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn instance.createChildren({\n\t\t\t\tcheckbox: {\n\t\t\t\t\tfactory: createCheckboxInput,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tstate: {\n\t\t\t\t\t\t\tclasses: [ 'toggle' ]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlisteners: {\n\t\t\t\t\t\t\tchange: () => { todoToggleComplete.do(instance.state); }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tbutton: {\n\t\t\t\t\tfactory: createButton,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tstate: {\n\t\t\t\t\t\t\tclasses: [ 'destroy' ]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlisteners: {\n\t\t\t\t\t\t\tclick: () => { todoRemove.do(instance.state); }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tlabel: {\n\t\t\t\t\tfactory: createRenderMixin,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tlisteners: {\n\t\t\t\t\t\t\tdblclick: () => { todoEdit.do(instance.state); }\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttagName: 'label'\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\teditInput: {\n\t\t\t\t\tfactory: createFocusableTextInput,\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tstate: {\n\t\t\t\t\t\t\tclasses: [ 'edit' ]\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlisteners: {\n\t\t\t\t\t\t\tblur: (event: Event) => { todoSave.do({state: instance.state, event}); },\n\t\t\t\t\t\t\tkeyup: (event: Event) => { todoEditInput.do({state: instance.state, event}); }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then((children: TodoItemChildren<RenderMixin<any>>) => {\n\t\t\t\tif (destroyed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/* TODO: We are only using the label.widget but we are storing label: { id, widget }, is\n\t\t\t\t\t* that necessary? */\n\t\t\t\tchildrenMap.set(instance, children);\n\t\t\t\tinstance.on('statechange', manageChildren);\n\n\t\t\t\t/* We have missed the widgets initial state change because we created the widgets async\n\t\t\t\t\t* so we should set state on the instance, so it will re-calculate its children */\n\t\t\t\tinstance.setState({});\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\tinstance.emit({\n\t\t\t\t\ttype: 'error',\n\t\t\t\t\ttarget: instance,\n\t\t\t\t\terror: err\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t})\n\t.extend({\n\t\tget classes(this: TodoItem): string[] {\n\t\t\t/* TODO: Deal with this in nodeAttributes when class classes are implementend */\n\t\t\tconst classes: string[] = [];\n\t\t\tif (this.state.editing) {\n\t\t\t\tclasses.push('editing');\n\t\t\t}\n\t\t\treturn this.state.completed ? [ 'completed', ...classes ] : classes;\n\t\t},\n\n\t\tgetChildrenNodes(this: TodoItem): VNode[] {\n\t\t\tconst { checkbox, label, button, editInput } = childrenMap.get(this);\n\t\t\treturn [\n\t\t\t\th('div.view', [\n\t\t\t\t\tcheckbox.widget.render(),\n\t\t\t\t\tlabel.widget.render(),\n\t\t\t\t\tbutton.widget.render()\n\t\t\t\t]),\n\t\t\t\teditInput.widget.render()\n\t\t\t];\n\t\t},\n\n\t\ttagName: 'li'\n\t});\n\nexport default createTodoItem;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoItem.ts","import createRenderMixin, { RenderMixin, RenderMixinOptions, RenderMixinState } from 'dojo-widgets/mixins/createRenderMixin';\nimport createFormFieldMixin, { FormFieldMixin, FormFieldMixinOptions, FormFieldMixinState } from 'dojo-widgets/mixins/createFormFieldMixin';\nimport createVNodeEvented, { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';\nimport { VNodeProperties } from 'maquette';\n\n/* I suspect this needs to go somewhere else */\nexport interface TypedTargetEvent<T extends EventTarget> extends Event {\n\ttarget: T;\n}\n\nexport type CheckboxInputState = RenderMixinState & FormFieldMixinState<string> & {\n\tchecked?: boolean;\n};\n\nexport type CheckboxInputOptions = RenderMixinOptions<CheckboxInputState> & FormFieldMixinOptions<string, CheckboxInputState>;\n\nexport type CheckboxInput = RenderMixin<CheckboxInputState> & FormFieldMixin<string, CheckboxInputState> & VNodeEvented;\n\nconst createCheckboxInput = createRenderMixin\n\t.mixin(createFormFieldMixin)\n\t.mixin({\n\t\tmixin: createVNodeEvented,\n\t\tinitialize(instance) {\n\t\t\tinstance.own(instance.on('input', (event: TypedTargetEvent<HTMLInputElement>) => {\n\t\t\t\tinstance.value = event.target.value;\n\t\t\t}));\n\t\t}\n\t})\n\t.extend({\n\t\tnodeAttributes: [\n\t\t\tfunction (this: CheckboxInput): VNodeProperties {\n\t\t\t\tconst { checked } = this.state;\n\t\t\t\treturn checked !== undefined ? { checked } : {};\n\t\t\t}\n\t\t],\n\n\t\ttagName: 'input',\n\n\t\ttype: 'checkbox'\n\t});\n\nexport default createCheckboxInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createCheckboxInput.ts","import { EventObject, Handle } from 'dojo-core/interfaces';\nimport { on } from 'dojo-core/aspect';\nimport { assign } from 'dojo-core/lang';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, {\n\tEvented,\n\tEventedOptions,\n\tEventedListenerOrArray,\n\tEventedListenersMap,\n\tresolveListener,\n\tTargettedEventObject\n} from 'dojo-compose/mixins/createEvented';\nimport Set from 'dojo-shim/Set';\nimport { VNodeProperties } from 'maquette';\nimport { NodeAttributeFunction } from './createRenderMixin';\n\nexport type VNodeListenerReturn = boolean | undefined | null;\n\nexport interface VNodeListeners {\n\t[on: string]: undefined | ((ev?: TargettedEventObject) => VNodeListenerReturn);\n\tontouchcancel?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchend?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchmove?(ev?: TouchEvent): VNodeListenerReturn;\n\tontouchstart?(ev?: TouchEvent): VNodeListenerReturn;\n\tonblur?(ev?: FocusEvent): VNodeListenerReturn;\n\tonchange?(ev?: Event): VNodeListenerReturn;\n\tonclick?(ev?: MouseEvent): VNodeListenerReturn;\n\tondblclick?(ev?: MouseEvent): VNodeListenerReturn;\n\tonfocus?(ev?: FocusEvent): VNodeListenerReturn;\n\toninput?(ev?: Event): VNodeListenerReturn;\n\tonkeydown?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonkeypress?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonkeyup?(ev?: KeyboardEvent): VNodeListenerReturn;\n\tonload?(ev?: Event): VNodeListenerReturn;\n\tonmousedown?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseenter?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseleave?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmousemove?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseout?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseover?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmouseup?(ev?: MouseEvent): VNodeListenerReturn;\n\tonmousewheel?(ev?: MouseWheelEvent): VNodeListenerReturn;\n\tonscroll?(ev?: UIEvent): VNodeListenerReturn;\n\tonsubmit?(ev?: Event): VNodeListenerReturn;\n}\n\nconst vnodeEvents = new Set([\n\t'touchcancel',\n\t'touchend',\n\t'touchmove',\n\t'touchstart',\n\t'blur',\n\t'change',\n\t'click',\n\t'dblclick',\n\t'focus',\n\t'input',\n\t'keydown',\n\t'keypress',\n\t'keyup',\n\t'load',\n\t'mousedown',\n\t'mouseenter',\n\t'mouseleave',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'mousewheel',\n\t'scroll',\n\t'submit'\n]);\n\nexport interface VNodeEventedMixin {\n\t/**\n\t * A map of listeners that are exposed for use by the virutal DOM\n\t */\n\tlisteners: VNodeListeners;\n\n\t/**\n\t * An array of functions the provide the VNode attributes when rendering\n\t */\n\tnodeAttributes: NodeAttributeFunction[];\n}\n\nexport interface VNodeEventedOverrides {\n\ton(type: 'touchcancel', listener: EventedListenerOrArray<TouchEvent>): Handle;\n\ton(type: 'touchend', listener: EventedListenerOrArray<TouchEvent>): Handle;\n\ton(type: 'touchmove', listener: EventedListenerOrArray<TouchEvent>): Handle;\n\ton(type: 'blur', listener: EventedListenerOrArray<FocusEvent>): Handle;\n\ton(type: 'change', listener: EventedListenerOrArray<Event>): Handle;\n\ton(type: 'click', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'dblclick', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'focus', listener: EventedListenerOrArray<FocusEvent>): Handle;\n\ton(type: 'input', listener: EventedListenerOrArray<Event>): Handle;\n\ton(type: 'keydown', listener: EventedListenerOrArray<KeyboardEvent>): Handle;\n\ton(type: 'keypress', listener: EventedListenerOrArray<KeyboardEvent>): Handle;\n\ton(type: 'keyup', listener: EventedListenerOrArray<KeyboardEvent>): Handle;\n\ton(type: 'load', listener: EventedListenerOrArray<Event>): Handle;\n\ton(type: 'mousedown', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mouseenter', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mouseleave', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mousemove', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mouseout', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mouseover', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mouseup', listener: EventedListenerOrArray<MouseEvent>): Handle;\n\ton(type: 'mousewheel', listener: EventedListenerOrArray<MouseWheelEvent>): Handle;\n\ton(type: 'scroll', listener: EventedListenerOrArray<UIEvent>): Handle;\n\ton(type: 'submit', listener: EventedListenerOrArray<Event>): Handle;\n\t/**\n\t * Add a listener to an event by type\n\t *\n\t * @param type The type of event to listen for\n\t * @param listener The event listener to attach\n\t */\n\ton(type: string, listener: EventedListenerOrArray<TargettedEventObject>): Handle;\n}\n\nexport type VNodeEvented = Evented & VNodeEventedMixin & VNodeEventedOverrides;\n\nexport type VNodeEventedOptions = EventedOptions;\n\nexport interface VNodeEventedFactory extends ComposeFactory<VNodeEvented, VNodeEventedOptions> { }\n\n/**\n * Internal function to convert an array of handles to a single array\n *\n * TODO: This is used in a couple places, maybe should migrate to a better place\n *\n * @params handles An array of handles\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\nconst UNINITIALIZED_LISTENERS = Object.freeze({});\n\nconst createVNodeEvented: VNodeEventedFactory = createEvented\n\t.mixin({\n\t\tmixin: {\n\t\t\tlisteners: UNINITIALIZED_LISTENERS,\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: VNodeEvented): VNodeProperties {\n\t\t\t\t\treturn assign({}, this.listeners);\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\taspectAdvice: {\n\t\t\taround: {\n\t\t\t\ton(origFn): (...args: any[]) => Handle {\n\t\t\t\t\treturn function (this: VNodeEvented, ...args: any[]): Handle {\n\t\t\t\t\t\tif (args.length === 2) { /* overload: on(type, listener) */\n\t\t\t\t\t\t\t/* During initialization, sometimes the initialize functions occur out of order,\n\t\t\t\t\t\t\t* and Evented's initialize function could be called before this mixins, therefore\n\t\t\t\t\t\t\t* leaving this.listeners with an uninitiliazed value, therefore it is better to\n\t\t\t\t\t\t\t* determine if the value is unitialized here, ensuring that this.listeners is\n\t\t\t\t\t\t\t* always valid.\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tif (this.listeners === UNINITIALIZED_LISTENERS) {\n\t\t\t\t\t\t\t\tthis.listeners = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet type: string;\n\t\t\t\t\t\t\tlet listeners: EventedListenerOrArray<TargettedEventObject>;\n\t\t\t\t\t\t\t[ type, listeners ] = args;\n\t\t\t\t\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\t\t\t\t\tconst handles = listeners.map((listener) => vnodeEvents.has(type) ?\n\t\t\t\t\t\t\t\t\ton(this.listeners, 'on' + type, resolveListener(listener)) :\n\t\t\t\t\t\t\t\t\torigFn.call(this, type, listener));\n\t\t\t\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\treturn vnodeEvents.has(type) ?\n\t\t\t\t\t\t\t\t\ton(this.listeners, 'on' + type, resolveListener(listeners)) :\n\t\t\t\t\t\t\t\t\torigFn.call(this, type, listeners);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (args.length === 1) { /* overload: on(listeners) */\n\t\t\t\t\t\t\tconst listenerMapArg: EventedListenersMap = args[0];\n\t\t\t\t\t\t\treturn handlesArraytoHandle(Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { /* unexpected signature */\n\t\t\t\t\t\t\tthrow new TypeError('Invalid arguments');\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\temit(origFn): <T extends EventObject>(event: T) => void {\n\t\t\t\t\treturn function <T extends EventObject>(this: VNodeEvented, event: T): void {\n\t\t\t\t\t\tif (vnodeEvents.has(event.type)) {\n\t\t\t\t\t\t\tif (this.listeners === null) {\n\t\t\t\t\t\t\t\tthis.listeners = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst method = this.listeners['on' + event.type];\n\t\t\t\t\t\t\tif (method) {\n\t\t\t\t\t\t\t\tmethod.call(this, event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\torigFn.call(this, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createVNodeEvented;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createVNodeEvented.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport { forOf, IterableIterator, Iterable, ShimIterator } from './iterator';\nimport './Symbol';\n\nexport namespace Shim {\n\texport class Set<T> {\n\t\tprivate _setData: T[] = [];\n\n\t\tconstructor(iterable?: ArrayLike<T> | Iterable<T>) {\n\t\t\tif (iterable) {\n\t\t\t\tforOf(iterable, (value) => this.add(value));\n\t\t\t}\n\t\t};\n\n\t\tadd(value: T): this {\n\t\t\tif (this.has(value)) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis._setData.push(value);\n\t\t\treturn this;\n\t\t};\n\n\t\tclear(): void {\n\t\t\tthis._setData.length = 0;\n\t\t};\n\n\t\tdelete(value: T): boolean {\n\t\t\tconst idx = this._setData.indexOf(value);\n\t\t\tif (idx === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._setData.splice(idx, 1);\n\t\t\treturn true;\n\t\t};\n\n\t\tentries(): IterableIterator<[T, T]> {\n\t\t\treturn new ShimIterator<[any, any]>(this._setData.map<[any, any]>((value) => [ value, value ]));\n\t\t};\n\n\t\tforEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void {\n\t\t\tconst iterator = this.values();\n\t\t\tlet result = iterator.next();\n\t\t\twhile (!result.done) {\n\t\t\t\tcallbackfn.call(thisArg, result.value, result.value, this);\n\t\t\t\tresult = iterator.next();\n\t\t\t}\n\t\t};\n\n\t\thas(value: T): boolean {\n\t\t\treturn this._setData.indexOf(value) > -1;\n\t\t};\n\n\t\tkeys(): IterableIterator<T> {\n\t\t\treturn new ShimIterator(this._setData);\n\t\t};\n\n\t\tget size(): number {\n\t\t\treturn this._setData.length;\n\t\t};\n\n\t\tvalues(): IterableIterator<T> {\n\t\t\treturn new ShimIterator(this._setData);\n\t\t};\n\n\t\t[Symbol.iterator](): IterableIterator<T> {\n\t\t\treturn new ShimIterator(this._setData);\n\t\t};\n\n\t\t[Symbol.toStringTag]: string = 'Set';\n\t}\n}\n\n@hasClass('es6-set', global.Set, Shim.Set)\nexport default class Set<T> {\n\t/* istanbul ignore next */\n\tconstructor(iterable?: ArrayLike<T> | Iterable<T>) { };\n\n\t/* istanbul ignore next */\n\tadd(value: T): this { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tclear(): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tdelete(value: T): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tentries(): IterableIterator<[T, T]> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tforEach(callbackfn: (value: T, index: T, set: Set<T>) => void, thisArg?: any): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\thas(value: T): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tkeys(): IterableIterator<T> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tget size(): number { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tvalues(): IterableIterator<T> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.iterator](): IterableIterator<T> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.toStringTag]: string = 'Set';\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Set.ts","import has from './support/has';\nimport global from './support/global';\nimport { getValueDescriptor } from './support/util';\n\nexport namespace Shim {\n\t/* tslint:disable-next-line:variable-name */\n\tlet Symbol: SymbolConstructor;\n\t/* tslint:disable-next-line:variable-name */\n\tlet InternalSymbol: SymbolConstructor;\n\n\tconst defineProperties = Object.defineProperties;\n\tconst defineProperty = Object.defineProperty;\n\tconst create = Object.create;\n\n\tconst objPrototype = Object.prototype;\n\n\tinterface GlobalSymbols {\n\t\t[key: string]: symbol;\n\t}\n\n\tconst globalSymbols: GlobalSymbols = {};\n\n\tinterface TypedPropertyDescriptor<T> extends PropertyDescriptor {\n\t\tvalue?: T;\n\t\tget? (): T;\n\t\tset? (v: T): void;\n\t}\n\n\tconst getSymbolName = (function () {\n\t\tconst created = create(null);\n\t\treturn function (desc: string|number): string {\n\t\t\tlet postfix = 0;\n\t\t\tlet name: string;\n\t\t\twhile (created[String(desc) + (postfix || '')]) {\n\t\t\t\t++postfix;\n\t\t\t}\n\t\t\tdesc += String(postfix || '');\n\t\t\tcreated[desc] = true;\n\t\t\tname = '@@' + desc;\n\n\t\t\t// FIXME: Temporary guard until the duplicate execution when testing can be\n\t\t\t// pinned down.\n\t\t\tif (!Object.getOwnPropertyDescriptor(objPrototype, name)) {\n\t\t\t\tdefineProperty(objPrototype, name, {\n\t\t\t\t\tset: function (this: Symbol, value: any) {\n\t\t\t\t\t\tdefineProperty(this, name, getValueDescriptor(value));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn name;\n\t\t};\n\t}());\n\n\tInternalSymbol = function Symbol(this: any, description?: string|number): symbol {\n\t\tif (this instanceof InternalSymbol) {\n\t\t\tthrow new TypeError('TypeError: Symbol is not a constructor');\n\t\t}\n\t\treturn Symbol(description);\n\t} as SymbolConstructor;\n\n\tSymbol = function Symbol(this: Symbol, description?: string|number): symbol {\n\t\tif (this instanceof Symbol) {\n\t\t\tthrow new TypeError('TypeError: Symbol is not a constructor');\n\t\t}\n\t\tconst sym = Object.create(InternalSymbol.prototype);\n\t\tdescription = (description === undefined ? '' : String(description));\n\t\treturn defineProperties(sym, {\n\t\t\t__description__: getValueDescriptor(description),\n\t\t\t__name__: getValueDescriptor(getSymbolName(description))\n\t\t});\n\t} as SymbolConstructor;\n\n\t/**\n\t * A custom guard function that determines if an object is a symbol or not\n\t * @param  {any}       value The value to check to see if it is a symbol or not\n\t * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)\n\t */\n\texport function isSymbol(value: any): value is symbol {\n\t\treturn (value && ((typeof value === 'symbol') || (value['@@toStringTag'] === 'Symbol'))) || false;\n\t}\n\n\t/**\n\t * Throws if the value is not a symbol, used internally within the Shim\n\t * @param  {any}    value The value to check\n\t * @return {symbol}       Returns the symbol or throws\n\t */\n\tfunction validateSymbol(value: any): symbol {\n\t\tif (!isSymbol(value)) {\n\t\t\tthrow new TypeError(value + ' is not a symbol');\n\t\t}\n\t\treturn value;\n\t}\n\n\t/* Decorate the Symbol function with the appropriate properties */\n\tdefineProperty(Symbol, 'for', getValueDescriptor(function (key: string): symbol {\n\t\tif (globalSymbols[key]) {\n\t\t\treturn globalSymbols[key];\n\t\t}\n\t\treturn (globalSymbols[key] = Symbol(String(key)));\n\t}));\n\tdefineProperties(Symbol, {\n\t\tkeyFor: getValueDescriptor(function (sym: symbol): string | undefined {\n\t\t\tlet key: string;\n\t\t\tvalidateSymbol(sym);\n\t\t\tfor (key in globalSymbols) {\n\t\t\t\tif (globalSymbols[key] === sym) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t\thasInstance: getValueDescriptor(Symbol.for('hasInstance'), false, false),\n\t\tisConcatSpreadable: getValueDescriptor(Symbol.for('isConcatSpreadable'), false, false),\n\t\titerator: getValueDescriptor(Symbol.for('iterator'), false, false),\n\t\tmatch: getValueDescriptor(Symbol.for('match'), false, false),\n\t\treplace: getValueDescriptor(Symbol.for('replace'), false, false),\n\t\tsearch: getValueDescriptor(Symbol.for('search'), false, false),\n\t\tspecies: getValueDescriptor(Symbol.for('species'), false, false),\n\t\tsplit: getValueDescriptor(Symbol.for('split'), false, false),\n\t\ttoPrimitive: getValueDescriptor(Symbol.for('toPrimitive'), false, false),\n\t\ttoStringTag: getValueDescriptor(Symbol.for('toStringTag'), false, false),\n\t\tunscopables: getValueDescriptor(Symbol.for('unscopables'), false, false)\n\t});\n\n\t/* Decorate the InternalSymbol object */\n\tdefineProperties(InternalSymbol.prototype, {\n\t\tconstructor: getValueDescriptor(Symbol),\n\t\ttoString: getValueDescriptor(function (this: { __name__: string }) { return this.__name__; }, false, false)\n\t});\n\n\t/* Decorate the Symbol.prototype */\n\tdefineProperties(Symbol.prototype, {\n\t\ttoString: getValueDescriptor(function (this: Symbol) { return 'Symbol (' + (<any> validateSymbol(this)).__description__ + ')'; }),\n\t\tvalueOf: getValueDescriptor(function (this: Symbol) { return validateSymbol(this); })\n\t});\n\n\tdefineProperty(Symbol.prototype, <any> Symbol.toPrimitive, getValueDescriptor(function (this: Symbol) { return validateSymbol(this); }));\n\tdefineProperty(Symbol.prototype, <any> Symbol.toStringTag, getValueDescriptor('Symbol', false, false, true));\n\n\tdefineProperty(InternalSymbol.prototype, <any> Symbol.toPrimitive, getValueDescriptor(Symbol.prototype[Symbol.toPrimitive], false, false, true));\n\tdefineProperty(InternalSymbol.prototype, <any> Symbol.toStringTag, getValueDescriptor(Symbol.prototype[Symbol.toStringTag], false, false, true));\n\n\t/* tslint:disable-next-line:variable-name */\n\texport const Exposed = Symbol;\n}\n\n/* tslint:disable-next-line:variable-name */\nconst SymbolShim: SymbolConstructor = has('es6-symbol') ? global.Symbol : global.Symbol = Shim.Exposed;\n\n/**\n * Fill any missing well known symbols if the native Symbol is missing them\n */\n[ 'hasInstance', 'isConcatSpreadable', 'iterator', 'species', 'replace', 'search', 'split', 'match', 'toPrimitive',\n\t'toStringTag', 'unscopables' ].forEach((wellKnown) => {\n\t\tif (!(<any> Symbol)[wellKnown]) {\n\t\t\tObject.defineProperty(Symbol, wellKnown, getValueDescriptor(Symbol.for(wellKnown), false, false));\n\t\t}\n\t});\n\nexport const isSymbol = Shim.isSymbol;\n\nexport default SymbolShim;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Symbol.ts","/**\n * Helper function to generate a value property descriptor\n *\n * @param value        The value the property descriptor should be set to\n * @param enumerable   If the property should be enumberable, defaults to false\n * @param writable     If the property should be writable, defaults to true\n * @param configurable If the property should be configurable, defaults to true\n * @return             The property descriptor object\n */\nexport function getValueDescriptor<T>(value: T, enumerable: boolean = false, writable: boolean = true, configurable: boolean = true): TypedPropertyDescriptor<T> {\n\treturn {\n\t\tvalue: value,\n\t\tenumerable: enumerable,\n\t\twritable: writable,\n\t\tconfigurable: configurable\n\t};\n}\n\n/**\n * A helper function which wraps a function where the first argument becomes the scope\n * of the call\n *\n * @param nativeFunction The source function to be wrapped\n */\nexport function wrapNative(nativeFunction: Function): any {\n\treturn function (target: any, ...args: any[]) {\n\t\treturn nativeFunction.apply(target, args);\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/util.ts","const globalObject: any = Function('return this')();\nexport default globalObject;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/global.ts","import global from './global';\nimport has from 'dojo-has/has';\nimport { add } from 'dojo-has/has';\n\nexport default has;\nexport * from 'dojo-has/has';\n\n/* ECMAScript 6 and 7 Features */\n\n/* Object */\nadd('es6-object-assign', typeof (<any> Object).assign === 'function');\n\n/* Array */\nadd('es6-array-from', 'from' in global.Array);\nadd('es6-array-of', 'of' in global.Array);\nadd('es6-array-fill', () => {\n\tif ('fill' in global.Array.prototype) {\n\t\t/* Some versions of Safari do not properly implement this */\n\t\treturn (<any> [ 1 ]).fill(9, Number.POSITIVE_INFINITY)[0] === 1;\n\t}\n\treturn false;\n});\nadd('es6-array-findindex', 'findIndex' in global.Array.prototype);\nadd('es6-array-find', 'find' in global.Array.prototype);\nadd('es6-array-copywithin', 'copyWithin' in global.Array.prototype);\nadd('es7-array-includes', 'includes' in global.Array.prototype);\n\n/* String */\nadd('es6-string-raw', 'raw' in global.String);\nadd('es6-string-fromcodepoint', 'fromCodePoint' in global.String);\nadd('es6-string-codepointat', 'codePointAt' in global.String.prototype);\nadd('es6-string-normalize', 'normalize' in global.String.prototype);\nadd('es6-string-repeat', 'repeat' in global.String.prototype);\nadd('es6-string-startswith', 'startsWith' in global.String.prototype);\nadd('es6-string-endswith', 'endsWith' in global.String.prototype);\nadd('es6-string-includes', 'includes' in global.String.prototype);\n\n/* Math */\n\nadd('es6-math-acosh', typeof global.Math.acosh === 'function');\nadd('es6-math-clz32', typeof global.Math.clz32 === 'function');\nadd('es6-math-imul', () => {\n\tif ('imul' in global.Math) {\n\t\t/* Some versions of Safari on ios do not properly implement this */\n\t\treturn (<any> Math).imul(0xffffffff, 5) === -5;\n\t}\n\treturn false;\n});\n\n/* Promise */\nadd('es6-promise', typeof global.Promise !== 'undefined' && typeof global.Symbol !== 'undefined');\n\n/* Set */\nadd('es6-set', () => {\n\tif (typeof global.Set === 'function') {\n\t\t/* IE11 and older versions of Safari are missing critical ES6 Set functionality */\n\t\tconst set = new global.Set([1]);\n\t\treturn set.has(1) && 'keys' in set && typeof set.keys === 'function';\n\t}\n\treturn false;\n});\n\n/* Map */\nadd('es6-map', function () {\n\tif (typeof global.Map === 'function') {\n\t\t/*\n\t\tIE11 and older versions of Safari are missing critical ES6 Map functionality\n\t\tWe wrap this in a try/catch because sometimes the Map constructor exists, but does not\n\t\ttake arguments (iOS 8.4)\n\t\t */\n\t\ttry {\n\t\t\tconst map = new global.Map([ [0, 1] ]);\n\t\t\treturn map.has(0) && typeof map.keys === 'function' &&\n\t\t\t\ttypeof map.values === 'function' && typeof map.entries === 'function';\n\t\t}\n\t\tcatch (e) {\n\t\t\t/* istanbul ignore next: not testing on iOS at the moment */\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n});\n\n/* WeakMap */\nadd('es6-weakmap', function () {\n\tif (typeof global.WeakMap !== 'undefined') {\n\t\t/* IE11 and older versions of Safari are missing critical ES6 Map functionality */\n\t\tconst key1 = {};\n\t\tconst key2 = {};\n\t\tconst map = new global.WeakMap([ [ key1, 1 ] ]);\n\t\treturn map.get(key1) === 1 && map.set(key2, 2) === map;\n\t}\n\treturn false;\n});\n\n/* Symbol */\nadd('es6-symbol', typeof global.Symbol === 'function');\n\n/* Miscellaneous features */\n\nadd('float32array', 'Float32Array' in global);\nadd('setimmediate', typeof global.setImmediate !== 'undefined');\nadd('postmessage', typeof postMessage === 'function');\nadd('microtasks', () => has('es6-promise') || has('host-node') || has('dom-mutationobserver'));\n\n/* DOM Features */\n\nadd('dom-mutationobserver', () => has('host-browser') && Boolean(global.MutationObserver || global.WebKitMutationObserver));\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/has.ts","import { Require, Config } from './loader';\n\n/**\n * The valid return types from a feature test\n */\nexport type FeatureTestResult = boolean | string | number | undefined;\n\n/**\n * A function that tests for a feature and returns a result\n */\nexport type FeatureTest = () => FeatureTestResult;\n\n/**\n * A cache of results of feature tests\n */\nexport const testCache: { [feature: string]: FeatureTestResult } = {};\n\n/**\n * A cache of the un-resolved feature tests\n */\nexport const testFunctions: { [feature: string]: FeatureTest } = {};\n\nexport interface StaticHasFeatures {\n\t[ feature: string ]: FeatureTestResult;\n}\n\nexport interface DojoHasEnvironment {\n\t/**\n\t * Static features defined in the enviornment that should be used by the `has` module\n\t * instead of run-time detection.\n\t */\n\tstaticFeatures?: StaticHasFeatures | (() => StaticHasFeatures);\n}\n\ndeclare global {\n\tinterface Window {\n\t\t/**\n\t\t * The `dojo/has` enviornment which provides configuration when the module is\n\t\t * loaded.\n\t\t */\n\t\tDojoHasEnvironment?: DojoHasEnvironment;\n\t}\n}\n\n/**\n * A reference to the global scope (`window` in a browser, `global` in NodeJS)\n */\nconst globalScope = (function (): any {\n\t/* istanbul ignore else */\n\tif (typeof window !== 'undefined') {\n\t\t// Browsers\n\t\treturn window;\n\t}\n\telse if (typeof global !== 'undefined') {\n\t\t// Node\n\t\treturn global;\n\t}\n\telse if (typeof self !== 'undefined') {\n\t\t// Web workers\n\t\treturn self;\n\t}\n\t/* istanbul ignore next */\n\treturn {};\n})();\n\n/* Grab the staticFeatures if there are available */\nconst { staticFeatures }: DojoHasEnvironment = globalScope.DojoHasEnvironment || {};\n\n/* Cleaning up the DojoHasEnviornment */\nif ('DojoHasEnvironment' in globalScope) {\n\tdelete globalScope.DojoHasEnvironment;\n}\n\n/**\n * Custom type guard to narrow the `staticFeatures` to either a map or a function that\n * returns a map.\n *\n * @param value The value to guard for\n */\nfunction isStaticFeatureFunction(value: any): value is (() => StaticHasFeatures) {\n\treturn typeof value === 'function';\n}\n\n/**\n * The cache of asserted features that were available in the global scope when the\n * module loaded\n */\nconst staticCache: StaticHasFeatures = staticFeatures\n\t? isStaticFeatureFunction(staticFeatures)\n\t\t? staticFeatures.apply(globalScope)\n\t\t: staticFeatures\n\t: {}; /* Providing an empty cache, if none was in the environment\n\n/**\n * AMD plugin function.\n *\n * Conditional loads modules based on a has feature test value.\n *\n * @param resourceId Gives the resolved module id to load.\n * @param require The loader require function with respect to the module that contained the plugin resource in its\n *                dependency list.\n * @param load Callback to loader that consumes result of plugin demand.\n */\nexport function load(resourceId: string, require: Require, load: (value?: any) => void, config?: Config): void {\n\tresourceId ? require([ resourceId ], load) : load();\n}\n\n/**\n * AMD plugin function.\n *\n * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test\n * value(s).\n *\n * @param resourceId The id of the module\n * @param normalize Resolves a relative module id into an absolute module id\n */\nexport function normalize(resourceId: string, normalize: (moduleId: string) => string): string | null {\n\tconst tokens: RegExpMatchArray = resourceId.match(/[\\?:]|[^:\\?]*/g) || [];\n\tlet i = 0;\n\n\tfunction get(skip?: boolean): string | null {\n\t\tconst term = tokens[i++];\n\t\tif (term === ':') {\n\t\t\t// empty string module name, resolves to null\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\tif (tokens[i++] === '?') {\n\t\t\t\tif (!skip && has(term)) {\n\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\treturn get();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\tget(true);\n\t\t\t\t\treturn get(skip);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// a module\n\t\t\treturn term;\n\t\t}\n\t}\n\n\tconst id = get();\n\n\treturn id && normalize(id);\n}\n\n/**\n * Check if a feature has already been registered\n *\n * @param feature the name of the feature\n */\nexport function exists(feature: string): boolean {\n\treturn Boolean(feature in staticCache || feature in testCache || testFunctions[feature]);\n}\n\n/**\n * Register a new test for a named feature.\n *\n * @example\n * has.add('dom-addeventlistener', !!document.addEventListener);\n *\n * @example\n * has.add('touch-events', function () {\n *    return 'ontouchstart' in document\n * });\n *\n * @param feature the name of the feature\n * @param value the value reported of the feature, or a function that will be executed once on first test\n * @param overwrite if an existing value should be overwritten. Defaults to false.\n */\nexport function add(feature: string, value: FeatureTest | FeatureTestResult, overwrite: boolean = false): void {\n\tif (exists(feature) && !overwrite && !(feature in staticCache)) {\n\t\tthrow new TypeError(`Feature \"${feature}\" exists and overwrite not true.`);\n\t}\n\n\tif (typeof value === 'function') {\n\t\ttestFunctions[feature] = value;\n\t}\n\telse {\n\t\ttestCache[feature] = value;\n\t\tdelete testFunctions[feature];\n\t}\n}\n\n/**\n * Return the current value of a named feature.\n *\n * @param feature The name (if a string) or identifier (if an integer) of the feature to test.\n */\nexport default function has(feature: string): FeatureTestResult {\n\tlet result: FeatureTestResult;\n\n\tif (feature in staticCache) {\n\t\tresult = staticCache[feature];\n\t}\n\telse if (testFunctions[feature]) {\n\t\tresult = testCache[feature] = testFunctions[feature].call(null);\n\t\tdelete testFunctions[feature];\n\t}\n\telse if (feature in testCache) {\n\t\tresult = testCache[feature];\n\t}\n\telse {\n\t\tthrow new TypeError(`Attempt to detect unregistered has feature \"${feature}\"`);\n\t}\n\n\treturn result;\n}\n\n/*\n * Out of the box feature tests\n */\n\n/* Evironments */\n\n/* Used as a value to provide a debug only code path */\nadd('debug', true);\n\n/* Detects if the environment is \"browser like\" */\nadd('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\n/* Detects if the enviornment appears to be NodeJS */\nadd('host-node', function () {\n\tif (typeof process === 'object' && process.versions && process.versions.node) {\n\t\treturn process.versions.node;\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-has/has.ts","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 14\n// module chunks = 0","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX } from './string';\nimport './Symbol';\n\nexport interface IteratorResult<T> {\n\tdone: boolean;\n\tvalue: T;\n}\n\nexport interface Iterator<T> {\n\tnext(value?: any): IteratorResult<T>;\n\treturn?(value?: any): IteratorResult<T>;\n\tthrow?(e?: any): IteratorResult<T>;\n}\n\nexport interface Iterable<T> {\n\t[Symbol.iterator](): Iterator<T>;\n}\n\nexport interface IterableIterator<T> extends Iterator<T> {\n\t[Symbol.iterator](): IterableIterator<T>;\n}\n\nconst staticDone: IteratorResult<any> = { done: true, value: undefined };\n\n/**\n * A class that provides \"shims\" an iterator interface on array like\n * objects.\n */\nexport class ShimIterator<T> {\n\tprivate _list: ArrayLike<T>;\n\tprivate _nextIndex: number = -1;\n\tprivate _nativeIterator: Iterator<T>;\n\n\tconstructor(list: ArrayLike<T> | Iterable<T>) {\n\t\tif (isIterable(list)) {\n\t\t\tthis._nativeIterator = list[Symbol.iterator]();\n\t\t}\n\t\telse {\n\t\t\tthis._list = list;\n\t\t}\n\t};\n\n\t/**\n\t * Return the next iteration result for the Iterator\n\t */\n\tnext(): IteratorResult<T> {\n\t\tif (this._nativeIterator) {\n\t\t\treturn this._nativeIterator.next();\n\t\t}\n\t\tif (!this._list) {\n\t\t\treturn staticDone;\n\t\t}\n\t\tif (++this._nextIndex < this._list.length) {\n\t\t\treturn {\n\t\t\t\tdone: false,\n\t\t\t\tvalue: this._list[this._nextIndex]\n\t\t\t};\n\t\t}\n\t\treturn staticDone;\n\t};\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this;\n\t}\n}\n\n/**\n * A type guard for checking if something has an Iterable interface\n *\n * @param value The value to type guard against\n */\nexport function isIterable(value: any): value is Iterable<any> {\n\treturn value && typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * A type guard for checking if something is ArrayLike\n *\n * @param value The value to type guard against\n */\nexport function isArrayLike(value: any): value is ArrayLike<any> {\n\treturn value && typeof value.length === 'number';\n}\n\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nexport function get<T>(iterable: Iterable<T> | ArrayLike<T>): Iterator<T> | undefined {\n\tif (isIterable(iterable)) {\n\t\treturn iterable[Symbol.iterator]();\n\t}\n\telse if (isArrayLike(iterable)) {\n\t\treturn new ShimIterator(iterable);\n\t}\n};\n\nexport interface ForOfCallback<T> {\n\t/**\n\t * A callback function for a forOf() iteration\n\t *\n\t * @param value The current value\n\t * @param object The object being iterated over\n\t * @param doBreak A function, if called, will stop the iteration\n\t */\n\t(value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;\n}\n\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an interator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nexport function forOf<T>(iterable: Iterable<T> | ArrayLike<T> | string, callback: ForOfCallback<T>, thisArg?: any): void {\n\tlet broken = false;\n\n\tfunction doBreak() {\n\t\tbroken = true;\n\t}\n\n\t/* We need to handle iteration of double byte strings properly */\n\tif (!isIterable(iterable) && typeof iterable === 'string') {\n\t\tconst l = iterable.length;\n\t\tfor (let i = 0; i < l; ++i) {\n\t\t\tlet char = iterable[i];\n\t\t\tif ((i + 1) < l) {\n\t\t\t\tconst code = char.charCodeAt(0);\n\t\t\t\tif ((code >= HIGH_SURROGATE_MIN) && (code <= HIGH_SURROGATE_MAX)) {\n\t\t\t\t\tchar += iterable[++i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback.call(thisArg, char, iterable, doBreak);\n\t\t\tif (broken) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tconst iterator = get(iterable);\n\t\tif (iterator) {\n\t\t\tlet result = iterator.next();\n\n\t\t\twhile (!result.done) {\n\t\t\t\tcallback.call(thisArg, result.value, iterable, doBreak);\n\t\t\t\tif (broken) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresult = iterator.next();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/iterator.ts","import has from './support/has';\nimport { wrapNative } from './support/util';\n\n/**\n * The minimum location of high surrogates\n */\nexport const HIGH_SURROGATE_MIN = 0xD800;\n\n/**\n * The maximum location of high surrogates\n */\nexport const HIGH_SURROGATE_MAX = 0xDBFF;\n\n/**\n * The minimum location of low surrogates\n */\nexport const LOW_SURROGATE_MIN = 0xDC00;\n\n/**\n * The maximum location of low surrogates\n */\nexport const LOW_SURROGATE_MAX = 0xDFFF;\n\nexport namespace Shim {\n\t/**\n\t * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).\n\t * Used by startsWith, includes, and endsWith.\n\t *\n\t * @return Normalized position.\n\t */\n\tfunction normalizeSubstringArgs(name: string, text: string, search: string, position: number,\n\t\t\tisEnd: boolean = false): [ string, string, number ] {\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.' + name + ' requires a valid string to search against.');\n\t\t}\n\n\t\tconst length = text.length;\n\t\tposition = position !== position ? (isEnd ? length : 0) : position;\n\t\treturn [ text, String(search), Math.min(Math.max(position, 0), length) ];\n\t}\n\n\texport function raw(callSite: TemplateStringsArray, ...substitutions: any[]): string {\n\t\tlet rawStrings = callSite.raw;\n\t\tlet result = '';\n\t\tlet numSubstitutions = substitutions.length;\n\n\t\tif (callSite == null || callSite.raw == null) {\n\t\t\tthrow new TypeError('string.raw requires a valid callSite object with a raw value');\n\t\t}\n\n\t\tfor (let i = 0, length = rawStrings.length; i < length; i++) {\n\t\t\tresult += rawStrings[i] + (i < numSubstitutions && i < length - 1 ? substitutions[i] : '');\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport function fromCodePoint(...codePoints: number[]): string {\n\t\t// Adapted from https://github.com/mathiasbynens/String.fromCodePoint\n\t\tconst length = arguments.length;\n\t\tif (!length) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst fromCharCode = String.fromCharCode;\n\t\tconst MAX_SIZE = 0x4000;\n\t\tlet codeUnits: number[] = [];\n\t\tlet index = -1;\n\t\tlet result = '';\n\n\t\twhile (++index < length) {\n\t\t\tlet codePoint = Number(arguments[index]);\n\n\t\t\t// Code points must be finite integers within the valid range\n\t\t\tlet isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint &&\n\t\t\t\tcodePoint >= 0 && codePoint <= 0x10FFFF;\n\t\t\tif (!isValid) {\n\t\t\t\tthrow RangeError('string.fromCodePoint: Invalid code point ' + codePoint);\n\t\t\t}\n\n\t\t\tif (codePoint <= 0xFFFF) {\n\t\t\t\t// BMP code point\n\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Astral code point; split in surrogate halves\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\tlet highSurrogate = (codePoint >> 10) + HIGH_SURROGATE_MIN;\n\t\t\t\tlet lowSurrogate = (codePoint % 0x400) + LOW_SURROGATE_MIN;\n\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t}\n\n\t\t\tif (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t\tresult += fromCharCode.apply(null, codeUnits);\n\t\t\t\tcodeUnits.length = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function codePointAt(text: string, position: number = 0): number | undefined {\n\t\t// Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.codePointAt requries a valid string.');\n\t\t}\n\t\tconst length = text.length;\n\n\t\tif (position !== position) {\n\t\t\tposition = 0;\n\t\t}\n\t\tif (position < 0 || position >= length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Get the first code unit\n\t\tconst first = text.charCodeAt(position);\n\t\tif (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > position + 1) {\n\t\t\t// Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate\n\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\tconst second = text.charCodeAt(position + 1);\n\t\t\tif (second >= LOW_SURROGATE_MIN && second <= LOW_SURROGATE_MAX) {\n\t\t\t\treturn (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;\n\t\t\t}\n\t\t}\n\t\treturn first;\n\t}\n\n\t/* TODO: Missing normalize */\n\n\texport function repeat(text: string, count: number = 0): string {\n\t\t// Adapted from https://github.com/mathiasbynens/String.prototype.repeat\n\t\tif (text == null) {\n\t\t\tthrow new TypeError('string.repeat requires a valid string.');\n\t\t}\n\t\tif (count !== count) {\n\t\t\tcount = 0;\n\t\t}\n\t\tif (count < 0 || count === Infinity) {\n\t\t\tthrow new RangeError('string.repeat requires a non-negative finite count.');\n\t\t}\n\n\t\tlet result = '';\n\t\twhile (count) {\n\t\t\tif (count % 2) {\n\t\t\t\tresult += text;\n\t\t\t}\n\t\t\tif (count > 1) {\n\t\t\t\ttext += text;\n\t\t\t}\n\t\t\tcount >>= 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\texport function startsWith(text: string, search: string, position: number = 0): boolean {\n\t\tsearch = String(search);\n\t\t[ text, search, position ] = normalizeSubstringArgs('startsWith', text, search, position);\n\n\t\tconst end = position + search.length;\n\t\tif (end > text.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn text.slice(position, end) === search;\n\t}\n\n\texport function endsWith(text: string, search: string, endPosition?: number): boolean {\n\t\tif (endPosition == null) {\n\t\t\tendPosition = text.length;\n\t\t}\n\n\t\t[ text, search, endPosition ] = normalizeSubstringArgs('endsWith', text, search, endPosition, true);\n\n\t\tconst start = endPosition - search.length;\n\t\tif (start < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn text.slice(start, endPosition) === search;\n\t}\n\n\texport function includes(text: string, search: string, position: number = 0): boolean {\n\t\t[ text, search, position ] = normalizeSubstringArgs('includes', text, search, position);\n\t\treturn text.indexOf(search, position) !== -1;\n\t}\n\n\t/* TODO: Provide an iterator for a string to mimic [Symbol.iterator]? */\n}\n\n/**\n * A tag function for template strings to get the template string's raw string form.\n *\n * @param callSite Call site object (or a template string in TypeScript, which will transpile to one)\n * @param substitutions Values to substitute within the template string (TypeScript will generate these automatically)\n * @return String containing the raw template string with variables substituted\n *\n * @example\n * // Within TypeScript; logs 'The answer is:\\\\n42'\n * let answer = 42;\n * console.log(string.raw`The answer is:\\n${answer}`);\n *\n * @example\n * // The same example as above, but directly specifying a JavaScript object and substitution\n * console.log(string.raw({ raw: [ 'The answer is:\\\\n', '' ] }, 42));\n */\nexport const raw: (callSite: TemplateStringsArray, ...substitutions: any[]) => string = has('es6-string-raw')\n\t? (<any> String).raw\n\t: Shim.raw;\n\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexport const fromCodePoint: (...codePoints: number[]) => string = has('es6-string-fromcodepoint')\n\t? (<any> String).fromCodePoint\n\t: Shim.fromCodePoint;\n\n/**\n * Returns the UTF-16 encoded code point value of a given position in a string.\n *\n * @param text The string containing the element whose code point is to be determined\n * @param position Position of an element within the string to retrieve the code point value from\n * @return A non-negative integer representing the UTF-16 encoded code point value\n */\nexport const codePointAt: (text: string, position?: number) => number = has('es6-string-codepointat')\n\t? wrapNative((<any> String.prototype).codePointAt)\n\t: Shim.codePointAt;\n\n/**\n * Returns a string containing the given string repeated the specified number of times.\n *\n * @param text The string to repeat\n * @param count The number of times to repeat the string\n * @return A string containing the input string repeated count times\n */\nexport const repeat: (text: string, count?: number) => string = has('es6-string-repeat')\n\t? wrapNative((<any> String.prototype).repeat)\n\t: Shim.repeat;\n\n/**\n * Determines whether a string begins with the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found at the beginning of the given string\n */\nexport const startsWith: (text: string, search: string, position?: number) => boolean = has('es6-string-startswith')\n\t? wrapNative((<any> String.prototype).startsWith)\n\t: Shim.startsWith;\n\n/**\n * Determines whether a string ends with the given substring.\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param endPosition The index searching should stop before (defaults to text.length)\n * @return Boolean indicating if the search string was found at the end of the given string\n */\nexport const endsWith: (text: string, search: string, endPosition?: number) => boolean = has('es6-string-endswith')\n\t? wrapNative((<any> String.prototype).endsWith)\n\t: Shim.endsWith;\n\n/**\n * Determines whether a string includes the given substring (optionally starting from a given index).\n *\n * @param text The string to look for the search string within\n * @param search The string to search for\n * @param position The index to begin searching at\n * @return Boolean indicating if the search string was found within the given string\n */\nexport const includes: (text: string, search: string, position?: number) => boolean = has('es6-string-includes')\n\t? wrapNative((<any> String.prototype).includes)\n\t: Shim.includes;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/string.ts","import has from './has';\n\n/**\n * A class decorator that provides either a native class or a shimmed class based on a feature\n * test\n * @param feature The has feature to check\n * @param trueClass The class to use if feature test returns `true`\n * @param falseClass The class to use if the feature test returns `false` or is not defined\n */\nexport function hasClass(feature: string, trueClass: Function, falseClass: Function): ClassDecorator {\n\treturn function (target: Function): Function {\n\t\treturn has(feature) ? trueClass : falseClass;\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/decorators.ts","import { on } from 'dojo-core/aspect';\nimport { EventObject, Handle } from 'dojo-core/interfaces';\nimport Map from 'dojo-shim/Map';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport compose, { ComposeFactory } from '../compose';\nimport createDestroyable, { Destroyable } from './createDestroyable';\n\nexport interface TargettedEventObject extends EventObject {\n\t/**\n\t * The target of the event\n\t */\n\ttarget: any;\n}\n\nexport interface ActionableOptions<E extends TargettedEventObject> {\n\t[ option: string ]: any;\n\t/**\n\t * An event object\n\t */\n\tevent?: E;\n}\n\nexport interface Actionable<E extends TargettedEventObject> {\n\t/**\n\t * The *do* method of an Action, which can take a `options` property of an `event`\n\t *\n\t * @param options Options passed which includes an `event` object\n\t */\n\tdo(options?: ActionableOptions<E>): any;\n}\n\nexport interface EventedCallback<E extends EventObject> {\n\t/**\n\t * A callback that takes an `event` argument\n\t *\n\t * @param event The event object\n\t */\n\t(event: E): boolean | void;\n}\n\n/**\n * Either an `EventedCallback` or something that is `Actionable`\n */\nexport type EventedListener<E extends TargettedEventObject> = EventedCallback<E> | Actionable<E>;\n\n/**\n * Either a single `EventedListener` or an array\n */\nexport type EventedListenerOrArray<E extends TargettedEventObject> = EventedListener<E> | EventedListener<E>[];\n\n/**\n * A map of listeners where the key is the event `type`\n */\nexport interface EventedListenersMap {\n\t[type: string]: EventedListenerOrArray<TargettedEventObject>;\n}\n\n/**\n * A map of callbacks where the key is the event `type`\n */\ntype EventedCallbackMap = Map<string, EventedCallback<EventObject>>;\n\nexport interface EventedOptions {\n\t/**\n\t * Any listeners that should be attached during construction\n\t */\n\tlisteners?: EventedListenersMap;\n}\n\nexport interface EventedMixin {\n\t/**\n\t * Emit an event.\n\t *\n\t * The event is determined by the `event.type`, if there are no listeners for an event type,\n\t * `emit` is essentially a noop.\n\t *\n\t * @param event The `EventObject` to be delivered to listeners based on `event.type`\n\t */\n\temit<E extends EventObject>(event: E): void;\n\n\t/**\n\t * Attach a `listener` to a particular event `type`.\n\t *\n\t * @param type The event to attach the listener to\n\t * @param listener Either a function which takes an emitted `event` object, something that is `Actionable`,\n\t *                 or an array of of such listeners.\n\t * @returns A handle which can be used to remove the listener\n\t */\n\ton(type: string, listener: EventedListenerOrArray<TargettedEventObject>): Handle;\n\n\t/**\n\t * Attach a `listener` to a particular event `type`.\n\t *\n\t * @param type The event to attach the listener to\n\t * @param listeners An object which contains key value pairs of event types and listeners.\n\t */\n\ton(listeners: EventedListenersMap): Handle;\n}\n\nexport type Evented = EventedMixin & Destroyable;\n\nexport interface EventedFactory extends ComposeFactory<Evented, EventedOptions> { }\n\n/**\n * A weak map that contains a map of the listeners for an `Evented`\n */\nconst listenersMap = new WeakMap<Evented, EventedCallbackMap>();\n\n/**\n * A guard which determines if the value is `Actionable`\n *\n * @param value The value to guard against\n */\nfunction isActionable(value: any): value is Actionable<any> {\n\treturn Boolean(value && typeof value.do === 'function');\n}\n\n/**\n * An internal function that always returns an EventedCallback\n *\n * @param listener Either a `EventedCallback` or an `Actionable`\n */\nexport function resolveListener<E extends TargettedEventObject>(listener: EventedListener<E>): EventedCallback<E> {\n\treturn isActionable(listener) ? (event: E) => listener.do({ event }) : listener;\n}\n\n/**\n * Internal function to convert an array of handles to a single handle\n *\n * @param handles The array of handles to convert into a signle handle\n * @return The single handle\n */\nfunction handlesArraytoHandle(handles: Handle[]): Handle {\n\treturn {\n\t\tdestroy() {\n\t\t\thandles.forEach((handle) => handle.destroy());\n\t\t}\n\t};\n}\n\n/**\n * Creates a new instance of an `Evented`\n */\nconst createEvented: EventedFactory = compose<EventedMixin, EventedOptions>({\n\t\temit<E extends EventObject>(this: Evented, event: E): void {\n\t\t\tconst method = listenersMap.get(this).get(event.type);\n\t\t\tif (method) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t},\n\n\t\ton(this: Evented, ...args: any[]): Handle {\n\t\t\tconst listenerMap = listenersMap.get(this);\n\t\t\tif (args.length === 2) { /* overload: on(type, listener) */\n\t\t\t\tconst [ type, listeners ] = <[ string, EventedListenerOrArray<TargettedEventObject>]> args;\n\t\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\t\tconst handles = listeners.map((listener) => on(listenerMap, type, resolveListener(listener)));\n\t\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn on(listenerMap, type, resolveListener(listeners));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (args.length === 1) { /* overload: on(listeners) */\n\t\t\t\tconst [ listenerMapArg ] = <[EventedListenersMap]> args;\n\t\t\t\tconst handles = Object.keys(listenerMapArg).map((type) => this.on(type, listenerMapArg[type]));\n\t\t\t\treturn handlesArraytoHandle(handles);\n\t\t\t}\n\t\t\telse { /* unexpected signature */\n\t\t\t\tthrow new TypeError('Invalid arguments');\n\t\t\t}\n\t\t}\n\t})\n\t.mixin({\n\t\tclassName: 'Evented',\n\t\tmixin: createDestroyable,\n\t\tinitialize(instance, options) {\n\t\t\t/* Initialise listener map */\n\t\t\tlistenersMap.set(instance, new Map<string, EventedCallback<EventObject>>());\n\n\t\t\tif (options && options.listeners) {\n\t\t\t\tinstance.own(instance.on(options.listeners));\n\t\t\t}\n\t\t}\n\t});\n\nexport default createEvented;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/mixins/createEvented.ts","import { Handle } from 'dojo-core/interfaces';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport compose, { ComposeFactory } from '../compose';\n\nexport interface DestroyableOptions { }\n\nexport interface Destroyable {\n\t/**\n\t * Take a handle and *own* it, which ensures that the handle's `destroy()` method is called when the\n\t * *owner* is destroyed.\n\t *\n\t * @param handle The handle to own\n\t * @returns A handle to *unown* the passed handle\n\t */\n\town(handle: Handle): Handle;\n\n\t/**\n\t * Invoke `destroy()` on any owned handles.\n\t *\n\t * @returns A promise that resolves to `true` if successful, otherwise `false`\n\t */\n\tdestroy(): Promise<boolean>;\n}\n\nexport interface DestroyableFactory extends ComposeFactory<Destroyable, DestroyableOptions> { }\n\n/**\n * A reference to a function that always returns a promise which resolves to false\n */\nfunction noop(): Promise<boolean> {\n\treturn Promise.resolve(false);\n};\n\n/**\n * A reference to a function that throws, used to replace the `own()` method after\n * destruction\n */\nfunction destroyed(): never {\n\tthrow new Error('Call made to destroyed method');\n};\n\n/**\n * A weak map for *owning* handles on instances\n */\nconst handlesWeakMap = new WeakMap<Destroyable, Handle[]>();\n\n/**\n * A type guard that determines if the value is a Destroyable\n *\n * @param value The value to guard for\n */\nexport function isDestroyable(value: any): value is Destroyable {\n\treturn Boolean(value && 'destroy' in value && typeof value.destroy === 'function');\n}\n\n/**\n * A mixin which adds the concepts of being able to *destroy* handles which the instance\n * *owns*\n */\nconst createDestroyable: DestroyableFactory = compose('Destroyable', {\n\town(this: Destroyable, handle: Handle): Handle {\n\t\tconst handles = handlesWeakMap.get(this);\n\t\thandles.push(handle);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\thandles.splice(handles.indexOf(handle));\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\n\tdestroy(this: Destroyable) {\n\t\treturn new Promise((resolve) => {\n\t\t\thandlesWeakMap.get(this).forEach((handle) => {\n\t\t\t\thandle && handle.destroy && handle.destroy();\n\t\t\t});\n\t\t\tthis.destroy = noop;\n\t\t\tthis.own = destroyed;\n\t\t\tresolve(true);\n\t\t});\n\t}\n}, (instance) => {\n\thandlesWeakMap.set(instance, []);\n});\n\nexport default createDestroyable;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/mixins/createDestroyable.ts","import { assign } from 'dojo-core/lang';\nimport { from as arrayFrom, includes } from 'dojo-shim/array';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport Symbol from 'dojo-shim/Symbol';\nimport {\n\tbefore as aspectBefore,\n\tafter as aspectAfter,\n\taround as aspectAround,\n\tBeforeAdvice,\n\tAfterAdvice,\n\tAroundAdvice\n} from './aspect';\n\n/**\n * A tuple of advice types and advice\n */\ntype AdviceTuple = ['before', BeforeAdvice] | ['after', AfterAdvice<any>] | ['around', AroundAdvice<any>];\n\n/**\n * A map of advice to apply to a method, with the `method` key being a tuple of advice\n */\ntype AdviceMap = {\n\t[method: string]: AdviceTuple[];\n};\n\n/**\n * Interface for storing the private meta data related to a factory\n */\ninterface PrivateFactoryData {\n\t/**\n\t * A map of advice that should be applied to a prototype of a factory as it is being constructed\n\t */\n\tadvice?: AdviceMap;\n\n\t/**\n\t * The base prototype that contains the methods and properties without advice applied\n\t */\n\tbase?: any;\n\n\t/**\n\t * The array of initialization functions that should be applied to the instance upon creation\n\t */\n\tinitFns: ComposeInitializationFunction<any, any>[];\n\n\t/**\n\t * Any static properties/methods that should be applied when creating a factory\n\t */\n\tstaticProperties?: any;\n}\n\n/**\n * The default factory label if no label can be derived during the factory creation process\n */\nconst DEFAULT_FACTORY_LABEL = 'Compose';\n\n/* References to support minification */\nconst defineProperty = Object.defineProperty;\nconst isArray = Array.isArray;\nconst objectCreate = Object.create;\nconst objectKeys = Object.keys;\n\n/**\n * A weakmap that stores all the private data for a factory\n */\nconst privateFactoryData = new WeakMap<Function, PrivateFactoryData>();\n\n/**\n * An internal function which stubs out a method which, when called at runtime, throws.\n *\n * @param method The name of \"abstract\" method being called\n */\nfunction missingMethod(method: string): () => never {\n\treturn function throwOnMissingMethod(): never {\n\t\tthrow new TypeError(`Advice being applied to missing method named: ${method}`);\n\t};\n}\n\n/**\n * Internal function which can label a factory with a name and also sets\n * the `toString()` method on the prototype to return the approriate\n * name for instances.\n *\n * @param fn The name of the factory to label\n * @param value The name to supply for the label\n */\nfunction assignFactoryName(factory: Function, value: string): void {\n\tif (typeof factory === 'function' && factory.prototype) {\n\t\tassignFunctionName(factory, value);\n\t\tdefineProperty(factory.prototype, <any> Symbol.toStringTag, {\n\t\t\tget() {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n}\n\n/**\n * Internal function which can label a function with a name\n */\nfunction assignFunctionName(fn: Function, value: string): void {\n\tconst nameDescriptor = Object.getOwnPropertyDescriptor(fn, 'name');\n\tif (typeof nameDescriptor === 'undefined' || nameDescriptor.configurable) {\n\t\tdefineProperty(fn, 'name', {\n\t\t\tvalue,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t}\n}\n\n/**\n * A helper function that copies own properties and their descriptors\n * from one or more sources to a target object. Includes non-enumerable properties\n *\n * @param target The target that properties should be copied onto\n * @param sources The rest of the parameters treated as sources to apply\n */\nfunction assignProperties(target: any, ...sources: any[]) {\n\tsources.forEach((source) => {\n\t\tif (!source) {\n\t\t\treturn;\n\t\t}\n\t\tObject.defineProperties(\n\t\t\ttarget,\n\t\t\tObject.getOwnPropertyNames(source).reduce(\n\t\t\t\t(descriptors: PropertyDescriptorMap, key: string) => {\n\t\t\t\t\tif (key !== 'constructor') { /* don't copy constructor */\n\t\t\t\t\t\tconst sourceDescriptor = Object.getOwnPropertyDescriptor(source, key);\n\t\t\t\t\t\tconst sourceValue = sourceDescriptor && sourceDescriptor.value;\n\t\t\t\t\t\tconst targetDescriptor = Object.getOwnPropertyDescriptor(target, key);\n\t\t\t\t\t\tconst targetValue = targetDescriptor && targetDescriptor.value;\n\n\t\t\t\t\t\t/* Special handling to merge array proprties */\n\t\t\t\t\t\tif (isArray(sourceValue) && isArray(targetValue)) {\n\t\t\t\t\t\t\tsourceDescriptor.value = sourceValue.reduce(\n\t\t\t\t\t\t\t\t(value: any[], current: any) => {\n\t\t\t\t\t\t\t\t\tif (!includes(target[key], current)) {\n\t\t\t\t\t\t\t\t\t\tvalue.push(current);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tarrayFrom(targetValue)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdescriptors[key] = sourceDescriptor;\n\t\t\t\t\t}\n\t\t\t\t\treturn descriptors;\n\t\t\t\t},\n\t\t\t\tobjectCreate(null)\n\t\t\t)\n\t\t);\n\t});\n\treturn target;\n}\n\n/**\n * A helper funtion to return a function that is rebased to infer that the\n * first argument of the passed function will be the `this` when the function\n * is executed.\n *\n * @param  fn The function to be rebased\n * @return    The rebased function\n */\nfunction rebase(fn: (base: any, ...args: any[]) => any): (...args: any[]) => any {\n\treturn function(this: any, ...args: any[]) {\n\t\treturn fn.apply(this, [ this ].concat(args));\n\t};\n}\n\n/**\n * For a given factory, return the names of the initialization functions that will be\n * invoked upon construction.\n *\n * @param factory The factory that the array of function names should be returned for\n */\nexport function getInitFunctionNames(factory: ComposeFactory<any, any>): string[] | undefined {\n\tconst initFns = privateFactoryData.get(factory).initFns;\n\tif (initFns) {\n\t\treturn initFns.map((fn) => (<any> fn).name);\n\t}\n}\n\n/* The rebased functions we need to decorate compose constructors with */\n\n/**\n * Perform an extension of a class\n */\nconst doExtend = rebase(extend);\n\n/**\n * Perform a mixin of a class\n */\nconst doMixin = rebase(mixin);\n\n/**\n * Perform an overlay of a class\n */\nconst doOverlay = rebase(overlay);\n\n/**\n * Apply aspect advice to a class\n */\nconst doAspect = rebase(aspect);\n\n/**\n * Add static method/properties to a class\n */\nconst doStatic = rebase(_static);\n\n/**\n * Take a mixin and return a factory descriptor for the mixin\n *\n * @param mixin The factory to return the descriptor for\n * @template T The outer type of the descriptor\n * @template O The outer factory options of the descriptor\n * @template U The inner type of the descriptor\n * @template P The inner factory options of the descriptor\n */\nfunction factoryDescriptor<T, O, U, P>(mixin: ComposeFactory<U, P>): ComposeMixinDescriptor<T, O, U, P> {\n\treturn {\n\t\tmixin,\n\t\tclassName: mixin.name\n\t};\n};\n\n/**\n * Generate a factory descriptor for a class\n */\nconst doFactoryDescriptor = rebase(factoryDescriptor);\n\n/**\n * A set of functions that are used to decorate the compose factories\n */\nconst staticMethods = {\n\textend: doExtend,\n\tmixin: doMixin,\n\toverlay: doOverlay,\n\tfrom: doFrom,\n\tbefore: doBefore,\n\tafter: doAfter,\n\taround: doAround,\n\taspect: doAspect,\n\tfactoryDescriptor: doFactoryDescriptor,\n\tstatic: doStatic\n};\n\n/**\n * A convenience function to decorate compose class factories, including any static prpoerties\n *\n * @param base The target constructor\n */\ninterface FactoryOptions<T, U, O, S> {\n\tadvice?: AdviceMap;\n\tfactories?: ComposeFactory<U, O>[];\n\tinitFunction?: ComposeInitializationFunction<any, O>;\n\tclassName?: string;\n\tproto?: T;\n\tstaticProperties?: S;\n}\n\n/**\n * Internal function that merges (or creates) an advice map\n *\n * @param sources The advice maps to be merged into a single one\n */\nfunction assignAdviceMap(...sources: (AdviceMap | undefined)[]): AdviceMap {\n\tconst result: AdviceMap = {};\n\tsources.forEach((source) => {\n\t\tif (source) {\n\t\t\tfor (const method in source) {\n\t\t\t\tresult[method] = result[method] ? [ ...result[method], ...source[method] ] : [ ...source[method] ];\n\t\t\t}\n\t\t}\n\t});\n\treturn result;\n}\n\n/**\n * An internal function that takes a set of create widget options and returns a set of private factory data\n *\n * @param options The set of factory options to use in creating the private factory data\n */\nfunction createPrivateFactoryData({\n\tadvice: optionsAdvice,\n\tfactories,\n\tinitFunction,\n\tproto,\n\tstaticProperties\n}: FactoryOptions<any, any, any, any>): PrivateFactoryData {\n\tconst factoryData = (factories || []).reduce((factoryData, factory) => {\n\t\tconst { advice, base, initFns } = privateFactoryData.get(factory);\n\t\tif (advice) {\n\t\t\tfactoryData.advice = assignAdviceMap(factoryData.advice, advice);\n\t\t}\n\t\tif (base) {\n\t\t\tassignProperties(factoryData.base, base);\n\t\t}\n\t\tconst optionsInitFns = factoryData.initFns;\n\t\tinitFns.forEach((initFn) => {\n\t\t\tif (!includes(optionsInitFns, initFn)) {\n\t\t\t\toptionsInitFns.push(initFn);\n\t\t\t}\n\t\t});\n\t\treturn factoryData;\n\t}, {\n\t\tbase: {},\n\t\tinitFns: [],\n\t\tstaticProperties: staticProperties ? assign({}, staticProperties) : undefined\n\t} as PrivateFactoryData);\n\n\tif (initFunction) {\n\t\tfactoryData.initFns.push(initFunction);\n\t}\n\n\tif (optionsAdvice) {\n\t\tfactoryData.advice = assignAdviceMap(factoryData.advice, optionsAdvice);\n\t}\n\n\tassignProperties(factoryData.base, proto);\n\n\treturn factoryData;\n}\n\nfunction createFactory<T, U, O, S>(options: FactoryOptions<T, U, O, S>): ComposeFactory<T & U, O> & S;\nfunction createFactory<T, U, O>(options: FactoryOptions<T, U, O, any>): ComposeFactory<T & U, O> & any {\n\n\t/**\n\t * A compose factory\n\t */\n\tfunction factory(this: ComposeFactory<any, any>, ...args: any[]): any {\n\t\tif (this && this.constructor === factory) {\n\t\t\tthrow new SyntaxError('Factories cannot be called with \"new\".');\n\t\t}\n\t\tconst instance = objectCreate(factory.prototype);\n\n\t\t/* clone any arrays in the instance */\n\t\tfor (const key in instance) {\n\t\t\tif (isArray(Object.getOwnPropertyDescriptor(factory.prototype, key).value)) {\n\t\t\t\tinstance[key] = arrayFrom(instance[key]);\n\t\t\t}\n\t\t}\n\n\t\targs.unshift(instance);\n\t\tprivateFactoryData.get(factory).initFns.forEach(fn => {\n\t\t\tfn.apply(null, args);\n\t\t});\n\t\treturn instance;\n\t}\n\n\tconst factoryData = createPrivateFactoryData(options);\n\n\tprivateFactoryData.set(factory, factoryData);\n\n\tconst factoryPrototype = factory.prototype;\n\n\t/* mixin base properties into the prototype */\n\tassignProperties(factoryPrototype, factoryData.base);\n\n\t/* apply any advice to the prototype */\n\tif (factoryData.advice) {\n\t\tfor (const method in factoryData.advice) {\n\t\t\tfactoryData.advice[method].forEach(([ aspect, advice ]) => {\n\t\t\t\tconst sourceMethod = factoryPrototype[method] || missingMethod(method);\n\t\t\t\tswitch (aspect) {\n\t\t\t\tcase 'before':\n\t\t\t\t\tfactoryPrototype[method] = aspectBefore(sourceMethod, <BeforeAdvice> advice);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'after':\n\t\t\t\t\tfactoryPrototype[method] = aspectAfter(sourceMethod, <AfterAdvice<any>> advice);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'around':\n\t\t\t\t\tfactoryPrototype[method] = aspectAround(sourceMethod, <AroundAdvice<any>> advice);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/* assign a constructor to the prototype */\n\tfactoryPrototype.constructor = factory;\n\n\t/* assign static methods/properties */\n\tassign(factory, staticMethods, factoryData.staticProperties);\n\n\t/* assign factory name */\n\tconst className = options.className ||\n\t\t(options.factories && options.factories[0] && options.factories[0].name) ||\n\t\tDEFAULT_FACTORY_LABEL;\n\tassignFactoryName(factory, className);\n\n\t/* freeze the factory, so it cannot be accidently modified */\n\tObject.freeze(factory);\n\n\treturn factory as ComposeFactory<any, any>;\n}\n\n/**\n * A custom type guard that determines if the value is a ComposeFactory\n *\n * @param   value The target to check\n * @returns       Return true if it is a ComposeFactory, otherwise false\n */\nexport function isComposeFactory(value: any): value is ComposeFactory<any, any> {\n\treturn Boolean(value && privateFactoryData.get(value));\n}\n\n/* General Interfaces */\n\n/**\n * Used to adapt any consructor functions or classes to a compose factory\n */\nexport interface GenericClass<T> {\n\tnew (...args: any[]): T;\n\treadonly prototype: T;\n}\n\n/**\n * Used to adapt functions within compose\n */\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\nexport interface ComposeInitializationFunction<T, O> {\n\t/**\n\t * A callback function use to initialize a new created instance\n\t *\n\t * @param instance The newly constructed instance\n\t * @param options Any options that were passed to the factory\n\t * @template T The type of the instance\n\t * @template O The type of the options being passed\n\t */\n\t(instance: T, options?: O): void;\n\n\t/**\n\t * A string name of the function, used for debugging purposes\n\t */\n\treadonly name?: string;\n}\n\n/* Extension API */\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Extend the factory prototype with the supplied object literal, class, or factory\n\t *\n\t * @param extension The object literal, class or factory to extend\n\t * @template T The original type of the factory\n\t * @template U The type of the extension\n\t * @template O The type of the factory options\n\t * @template P The type of the extension factory options\n\t */\n\textend<U>(extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<U>(className: string, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<U, P>(extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n\textend<U, P>(className: string, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n}\n\nexport interface Compose {\n\t/**\n\t * Extend a compose factory prototype with the supplied object literal, class, or\n\t * factory.\n\t *\n\t * @param base The base compose factory to extend\n\t * @param extension The object literal, class or factory that is the extension\n\t * @template T The base type of the factory\n\t * @template U The type of the extension\n\t * @template O The type of the base factory options\n\t * @template P The type of the extension factory options\n\t */\n\textend<T, O, U>(base: ComposeFactory<T, O>, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<T, O, U>(base: ComposeFactory<T, O>, className: string, extension: U | GenericClass<U>): ComposeFactory<T & U, O>;\n\textend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n\textend<T, O, U, P>(base: ComposeFactory<T, O>, className: string, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\n}\n\n/**\n * The internal implementation of extending a compose factory\n *\n * @param base The base compose factory that is being extended\n * @param extension The extension to apply to the compose factory\n */\nfunction extend<T, O, U, P>(base: ComposeFactory<T, O>, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\nfunction extend<T, O, U, P>(base: ComposeFactory<T, O>, className: string, extension: ComposeFactory<U, P>): ComposeFactory<T & U, O & P>;\nfunction extend<O>(base: ComposeFactory<any, O>, className: any, extension?: any): ComposeFactory<any, O> {\n\tif (typeof className !== 'string') {\n\t\textension = className;\n\t\tclassName = undefined;\n\t}\n\n\treturn createFactory({\n\t\tclassName,\n\t\tproto: typeof extension === 'function' ? extension.prototype : extension,\n\t\tfactories: [ base ]\n\t});\n}\n\n/* Overlay API */\n\nexport interface OverlayFunction<T> {\n\t/**\n\t * A function that takes a factories prototype, allowing it to change the prototype without\n\t * mutating the type structure.\n\t *\n\t * @param proto The object literal that should be overlayed on the factories prototype.\n\t * @template T The type of the factories prototype\n\t */\n\t(proto: T): void;\n}\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Provide a function that mutates the factories prototype but does not change the factory's class\n\t * structure.\n\t *\n\t * @param overlayFunction The function which receives the factory's prototype\n\t * @template T The type of the factory's prototype\n\t */\n\toverlay(overlayFunction: OverlayFunction<T>): this;\n}\n\nexport interface Compose {\n\t/**\n\t * A static method that takes a compose factory and applies an overlay function to the factory,\n\t * returning a new compose factory with a mutated prototype.\n\t *\n\t * @param base The base ComposeFactory\n\t * @param overlayFunction The function which receives the base factory's prototype\n\t * @template T The type of the factory's prototype\n\t * @template O The options for the factory's creation\n\t */\n\toverlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O>;\n}\n\n/**\n * Internal implementation of the overlay functionality, to allow a function to modify a\n * compose factory prototype\n *\n * @param base The target compose factory\n * @param overlayFunction The callback function that will modify the prototype of the factory\n */\nfunction overlay<T, O>(base: ComposeFactory<T, O>, overlayFunction: OverlayFunction<T>): ComposeFactory<T, O> {\n\tconst factory = createFactory({\n\t\tfactories: [ base ]\n\t});\n\toverlayFunction(factory.prototype);\n\treturn factory;\n}\n\n/* AOP/Inheritance API */\n\n/**\n * A descriptor for applying advice to a set of methods\n */\nexport interface AspectAdvice {\n\t/**\n\t * Any methods where the supplied advice should be applied *before* the base method is invoked\n\t */\n\tbefore?: { [method: string]: BeforeAdvice };\n\n\t/**\n\t * Any methods where the supplied advice should be applied *after* the base method is invoked\n\t */\n\tafter?: { [method: string]: AfterAdvice<any> };\n\n\t/**\n\t * Any methods where the supplied advice should be applied *around* the base method\n\t */\n\taround?: { [method: string]: AroundAdvice<any> };\n}\n\n/* Mixin API */\n\n/**\n * Either a class, object literal, or a factory\n */\nexport type ComposeMixinItem<T, O> = GenericClass<T> | T | ComposeFactory<T, O>;\n\n/**\n * An object which provides information on how to mixin into a compose factory\n */\nexport interface ComposeMixinDescriptor<T, O, U, P> {\n\t/**\n\t * The class, object literal, or factory to be mixed in\n\t */\n\tmixin?: ComposeMixinItem<U, P>;\n\n\t/**\n\t * An initialize function to be executed upon construction\n\t */\n\tinitialize?: ComposeInitializationFunction<T & U, O & P>;\n\n\t/**\n\t * Aspect Oriented Advice to be mixed into the factory\n\t */\n\taspectAdvice?: AspectAdvice;\n\n\t/**\n\t * An optional class name which is used when labelling different parts of a factory for\n\t * debugging purposes\n\t */\n\tclassName?: string;\n}\n\n/**\n * Identifies a compose factory or other object that can be transformed into a\n * ComposeMixinDescriptor\n */\nexport interface ComposeMixinable<U, P> {\n\t/**\n\t * A method that offers up a ComposeMixinDescriptor to allow complex mixin in of factories\n\t */\n\tfactoryDescriptor<T, O>(): ComposeMixinDescriptor<T, O, U, P>;\n}\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Mixin additional mixins, initialization logic, and aspect advice into the factory\n\t *\n\t * @param mixin An object literal that describes what to mixin\n\t */\n\tmixin<U, P>(mixin: ComposeMixinable<U, P>): ComposeFactory<T & U, O & P>;\n\tmixin<U, P>(mixin: ComposeMixinDescriptor<T, O, U, P>): ComposeFactory<T & U, O & P>;\n}\n\nexport interface Compose {\n\t/**\n\t * Mixin additional mixins, initialization logic, and aspect advice into a factory\n\t *\n\t * @param base The base factory that is the target of the mixin\n\t * @param mixin An object literal that describes what to mixin\n\t */\n\tmixin<T, O, U, P>(\n\t\tbase: ComposeFactory<T, O>,\n\t\tmixin: ComposeMixinable<U, P>\n\t): ComposeFactory<T & U, O & P>;\n\tmixin<T, O, U, P>(\n\t\tbase: ComposeFactory<T, O>,\n\t\tmixin: ComposeMixinDescriptor<T, O, U, P>\n\t): ComposeFactory<T & U, O & P>;\n}\n\n/**\n * Internal function that converts `AspectAdvice` into `AdviceMap` which can then be used for\n * creating a factory\n *\n * @param aspectAdvice The aspect advice to convert into an advice map\n */\nfunction aspectAdviceToAdviceMap(aspectAdvice: AspectAdvice | undefined): AdviceMap | undefined {\n\tif (!aspectAdvice) {\n\t\treturn;\n\t}\n\n\tconst adviceMap: AdviceMap = {};\n\tconst beforeAdvice = aspectAdvice.before;\n\tconst afterAdvice = aspectAdvice.after;\n\tconst aroundAdvice = aspectAdvice.around;\n\n\tfunction mapAdvice(type: string, key: string, advice: { [ key: string ]: any }) {\n\t\tconst adviceTuple = [ type, advice[key] ] as AdviceTuple;\n\t\tif (adviceMap[key]) {\n\t\t\tadviceMap[key].push(adviceTuple);\n\t\t}\n\t\telse {\n\t\t\tadviceMap[key] = [ adviceTuple ];\n\t\t}\n\t}\n\n\tif (beforeAdvice) {\n\t\tobjectKeys(beforeAdvice).forEach((key) => {\n\t\t\t/* TODO: Remove ! in 2.1 */\n\t\t\tmapAdvice('before', key, beforeAdvice!);\n\t\t});\n\t}\n\tif (afterAdvice) {\n\t\tobjectKeys(afterAdvice).forEach((key) => {\n\t\t\t/* TODO: Remove ! in 2.1 */\n\t\t\tmapAdvice('after', key, afterAdvice!);\n\t\t});\n\t}\n\tif (aroundAdvice) {\n\t\tobjectKeys(aroundAdvice).forEach((key) => {\n\t\t\t/* TODO: Remove ! in 2.1 */\n\t\t\tmapAdvice('around', key, aroundAdvice!);\n\t\t});\n\t}\n\treturn adviceMap;\n}\n\n/**\n * A custom type guard that determines if a value is ComposeMixinable\n *\n * @param value The value to guard for\n */\nfunction isComposeMixinable(value: any): value is ComposeMixinable<any, any> {\n\treturn Boolean(value && 'factoryDescriptor' in value && typeof value.factoryDescriptor === 'function');\n}\n\n/**\n * The internal implementation of mixin in values into a compose factory\n *\n * @param base The base compose factory that is the target for being mixed in\n * @param toMixin The value to be mixed in\n */\nfunction mixin<T, O, U, P>(\n\tbase: ComposeFactory<T, O>,\n\ttoMixin: ComposeMixinable<U, P> | ComposeMixinDescriptor<T, O, U, P>\n): ComposeFactory<T & U, O & P> {\n\t/* ensure we are dealing with a mixinDescriptor */\n\tconst mixinDescriptor = isComposeMixinable(toMixin) ? toMixin.factoryDescriptor() : toMixin;\n\n\t/* destructure out most of the factory creation options */\n\tconst { mixin, initialize: initFunction, aspectAdvice, className } = mixinDescriptor;\n\n\t/* we will at least be using the base factory to create the new one */\n\tconst factories: ComposeFactory<any, any>[] = [ base ];\n\tlet proto: any;\n\n\t/* if mixin is a compose factory, we will pass it as a factory used to create the new factory */\n\tif (isComposeFactory(mixin)) {\n\t\tfactories.push(mixin);\n\t}\n\t/* otherwise we are dealing with a prototype based mixin */\n\telse {\n\t\t/* of which, we can have a constructor function/class, or an object literal (or undefined) */\n\t\tproto = isComposeFactory(mixin) ? undefined : typeof mixin === 'function' ? mixin.prototype : mixin;\n\t}\n\n\t/* convert the advice, if any, to the format used by createFactory */\n\tconst advice = aspectAdviceToAdviceMap(aspectAdvice);\n\n\t/* label the initFn */\n\tif (initFunction) {\n\t\tassignFunctionName(\n\t\t\tinitFunction,\n\t\t\t`mixin${className || (isComposeFactory(mixin) && mixin.name) || base.name}`\n\t\t);\n\t}\n\n\t/* return the newly created factory */\n\treturn createFactory({\n\t\tadvice,\n\t\tfactories,\n\t\tinitFunction,\n\t\tclassName,\n\t\tproto\n\t}) as ComposeFactory<T & U, O & P>;\n}\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Extract a method from another Class or Factory and add it to the returned factory\n\t *\n\t * @param base The base Class or Factory\n\t * @param method The name of the method to extract\n\t */\n\tfrom(base: GenericClass<any> | ComposeFactory<any, any>, method: string): this;\n\n\t/**\n\t * Apply advice *before* the named method (join-point)\n\t *\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\tbefore(method: string, advice: BeforeAdvice): this;\n\n\t/**\n\t * Apply advice *after* the named method (join-point)\n\t *\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\tafter<P>(method: string, advice: AfterAdvice<P>): this;\n\n\t/**\n\t * Apply advice *around* the named method (join-point)\n\t *\n\t * @param method The method to apply the advice to\n\t * @param advice The advice to be applied\n\t */\n\taround<P>(method: string, advice: AroundAdvice<P>): this;\n\n\t/**\n\t * Provide an object literal which can contain a map of advice to apply\n\t *\n\t * @param advice An object literal which contains the maps of advice to apply\n\t */\n\taspect(advice: AspectAdvice): this;\n}\n\nexport interface Compose {\n\t/**\n\t * Extract a method from another Class or Factory and return it\n\t *\n\t * @param base The Class or Factory to extract from\n\t * @param method The method name to be extracted\n\t */\n\tfrom<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol): T;\n\n\t/**\n\t * Apply advice *before* the named method (join-point)\n\t *\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\tbefore<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: BeforeAdvice): GenericFunction<T>;\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\n\n\t/**\n\t * Apply advice *after* the named method (join-point)\n\t *\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\tafter<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AfterAdvice<T>): GenericFunction<T>;\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\n\n\t/**\n\t * Apply advice *around* the named method (join-point)\n\t *\n\t * @param base The Class or Factory to extract the method from\n\t * @param method The method name to apply the advice to\n\t * @param advice The advice to apply\n\t */\n\taround<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AroundAdvice<T>): GenericFunction<T>;\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\n\n\t/**\n\t * Apply advice to methods that exist in the base factory using the supplied advice map\n\t *\n\t * @param base The Factory that contains the methods the advice will be applied to\n\t * @param advice The map of advice to be applied\n\t */\n\taspect<O, A>(base: ComposeFactory<O, A>, advice: AspectAdvice): ComposeFactory<O, A>;\n}\n\n/**\n * Internal implementation of extracting methods from another object\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction from<T extends Function>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol): T {\n\treturn base.prototype[method];\n}\n\n/**\n * Internal implementation to apply from when `this` represents the base\n *\n * @param base The target that the method should be extracted from\n * @param method The name of the method\n */\nfunction doFrom<T, O>(this: ComposeFactory<T, O>, base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tproto: {\n\t\t\t[method]: base.prototype[method]\n\t\t}\n\t}) as ComposeFactory<T, O>;\n}\n\n/**\n * The internal implementation to apply before advice to a factory\n *\n * @param base The target that the advice should be applied to\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction before<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: BeforeAdvice): GenericFunction<T>;\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\nfunction before(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: BeforeAdvice;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\n}\n\n/**\n * The internal implementation to apply before advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doBefore<T, O>(this: ComposeFactory<T, O>, method: string | symbol, advice: BeforeAdvice): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tadvice: {\n\t\t\t[method]: [ [ 'before', advice ] ]\n\t\t}\n\t});\n}\n\n/**\n * The internal implementation to apply after advice to a factory\n *\n * @param base The target that the advice should be applied to\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction after<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction after(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\n}\n\n/**\n * The internal implementation to apply after advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAfter<T, P, O>(this: ComposeFactory<T, O>, method: string | symbol, advice: AfterAdvice<P>): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tadvice: {\n\t\t\t[method]: [ [ 'after', advice ] ]\n\t\t}\n\t});\n}\n\n/**\n * The internal implementation to apply after around when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction around<T>(base: GenericClass<any> | ComposeFactory<any, any>, method: string | symbol, advice: AfterAdvice<T>): GenericFunction<T>;\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\nfunction around(...args: any[]): GenericFunction<any> {\n\tlet base: GenericFunction<any>;\n\tlet method: string | GenericFunction<any>;\n\tlet advice: AfterAdvice<any>;\n\tif (args.length >= 3) {\n\t\t[ base, method, advice ] = args;\n\t\tmethod = base.prototype[<string> method];\n\t}\n\telse {\n\t\t[ method, advice ] = args;\n\t}\n\treturn aspectAround(<GenericFunction<any>> method, advice);\n}\n\n/**\n * The internal implementation to apply around advice when `this` is scoped as the base factory\n *\n * @param method The name of the method that the advice should be applied to\n * @param advice The advice to apply\n */\nfunction doAround<T, P, O>(this: ComposeFactory<T, O>, method: string | symbol, advice: AroundAdvice<P>): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ this ],\n\t\tadvice: {\n\t\t\t[method]: [ [ 'around', advice ] ]\n\t\t}\n\t});\n}\n\n/**\n * The internal implementation of applying aspect advice to a factory\n *\n * @param base The base factory the advice should be applied to\n * @param advice The advice map to apply to the factory\n */\nfunction aspect<T, O>(base: ComposeFactory<T, O>, advice: AspectAdvice): ComposeFactory<T, O> {\n\treturn createFactory({\n\t\tfactories: [ base ],\n\t\tadvice: aspectAdviceToAdviceMap(advice)\n\t});\n}\n\n/* Creation API */\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Create a new instance\n\t *\n\t * @param options Options that are passed to the initialization functions of the factory\n\t */\n\t(options?: O): T;\n\n\t/**\n\t * The read only prototype of the factory\n\t */\n\treadonly prototype: T;\n}\n\nexport interface Compose {\n\t/**\n\t * Create a new factory based on a supplied Class, Factory or Object prototype with an optional\n\t * initalization function\n\t *\n\t * @param base The base Class, Factory or Object prototype to use\n\t * @param initFunction An optional function that will be passed the instance and any creation options\n\t * @param className An optional class name that is used to label the factory for debug purposes\n\t */\n\t<T, O>(base: GenericClass<T> | T): ComposeFactory<T, O>;\n\t<T, O>(className: string, base: GenericClass<T> | T): ComposeFactory<T, O>;\n\t<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\t<T, O>(className: string, base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\t<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\t<T, O, P>(className: string, base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\n\t/**\n\t * Create a new factory based on a supplied Class, Factory or Object prototype with an optional\n\t * initialization function\n\t *\n\t * @param base The base Class, Facotry or Object prototype to use\n\t * @param initFunction An optional function that will be passed the instance and nay creation options\n\t */\n\tcreate<T, O>(base: GenericClass<T> | T): ComposeFactory<T, O>;\n\tcreate<T, O>(className: string, base: GenericClass<T> | T): ComposeFactory<T, O>;\n\tcreate<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\tcreate<T, O>(className: string, base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\n\tcreate<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n\tcreate<T, O, P>(className: string, base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\n}\n\n/**\n * The internal implementation to create a compose factory\n *\n * @param base The base to use for creating the factory\n * @param initFunction Any function that should be run after the factory creates the instance\n */\nfunction create<T, O>(base: GenericClass<T> | T): ComposeFactory<T, O>;\nfunction create<T, O>(className: string, base: GenericClass<T> | T): ComposeFactory<T, O>;\nfunction create<T, O>(base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\nfunction create<T, O>(className: string, base: GenericClass<T> | T, initFunction?: ComposeInitializationFunction<T, O>): ComposeFactory<T, O>;\nfunction create<T, O, P>(base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\nfunction create<T, O, P>(className: string, base: ComposeFactory<T, O>, initFunction?: ComposeInitializationFunction<T, O & P>): ComposeFactory<T, O & P>;\nfunction create<O>(className: any, base?: any, initFunction?: ComposeInitializationFunction<any, O>): ComposeFactory<any, any> {\n\t/* disambugate arguments */\n\tif (typeof className !== 'string') {\n\t\tinitFunction = base;\n\t\tbase = className;\n\t\tclassName = undefined;\n\t}\n\n\t/* Label the initFunction */\n\tif (initFunction && className) {\n\t\tassignFunctionName(initFunction, `init${className}`);\n\t}\n\n\tlet factories: ComposeFactory<any, any>[] | undefined;\n\tlet proto: any;\n\n\t/* If base is a compose factory, set it as the factory array */\n\tif (base && isComposeFactory(base)) {\n\t\tfactories = [ base ];\n\t}\n\t/* Otherwise, we are dealing with a constructor function or a prototype */\n\telse {\n\t\tproto = typeof base === 'function' ? base.prototype : base;\n\t}\n\n\treturn createFactory({\n\t\tclassName,\n\t\tfactories,\n\t\tinitFunction,\n\t\tproto\n\t});\n}\n\n/* Extend factory with static properties */\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * Add static properties to a factory\n\t *\n\t * @param staticProperties An object literal that contains methods and properties that should be \"static\" (e.g. added to\n\t *                         the factory, instead of the factory's prototype)\n\t */\n\tstatic<S>(staticProperties: S): this & S;\n}\n\nexport interface Compose {\n\t/**\n\t * Add static properties to a factory\n\t *\n\t * @param staticProperties An object literal that contains methods and properties that should be \"static\" (e.g. added to\n\t *                         the factory, instead of the factory's prototype)\n\t */\n\tstatic<T, O, S>(factory: ComposeFactory<T, O>, staticProperties: S): ComposeFactory<T, O> & S;\n}\n\n/**\n * Internal implementation of applying static properties to a compose factory\n *\n * @param factory The factory that the static properties should be applied to\n * @param staticProperties The properties to be applied to the factory\n */\nfunction _static<T, O, S>(base: ComposeFactory<T, O>, staticProperties: S): ComposeFactory<T, O> & S {\n\treturn createFactory({\n\t\tfactories: [ base ],\n\t\tstaticProperties\n\t});\n}\n\nexport interface ComposeFactory<T, O> extends ComposeMixinable<T, O> {\n\t/**\n\t * The class name of the ComposeFactory\n\t */\n\treadonly name?: string;\n}\n\n/**\n * A factory construction utility\n *\n * @param base An ES6 Class, ComposeFactory or Object literal to use as the base for the new factory\n * @param initFunction An optional initialization function for the factory\n */\nconst compose = create as Compose;\n\n/* Add static methods to compose */\n\nassign(compose, {\n\tcreate,\n\tstatic: _static,\n\textend,\n\tmixin,\n\toverlay,\n\tfrom,\n\tbefore,\n\tafter,\n\taround,\n\taspect\n});\n\nexport default compose;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/compose.ts","import WeakMap from 'dojo-shim/WeakMap';\n\nexport interface AdvisingFunction extends Function {\n\t/**\n\t * The next advice in an advice chain\n\t */\n\treadonly next: AdvisingFunction;\n\n\t/**\n\t * The previous advice in an advice chain\n\t */\n\treadonly previous: AdvisingFunction;\n}\n\nexport interface DispatchAdvice<T> {\n\tbefore?: BeforeAdvice[];\n\tafter?: AfterAdvice<T>[];\n\treadonly joinPoint: Function;\n}\n\nexport interface BeforeAdvice {\n\t/**\n\t * Advice which is applied *before*, receiving the original arguments, if the advising\n\t * function returns a value, it is passed further along taking the place of the original\n\t * arguments.\n\t *\n\t * @param args The arguments the method was called with\n\t */\n\t(...args: any[]): any[] | void;\n}\n\nexport interface AfterAdvice<T> {\n\t/**\n\t * Advice which is applied *after*, receiving the result and arguments from the join point.\n\t *\n\t * @param result The result from the function being advised\n\t * @param args The arguments that were supplied to the advised function\n\t * @returns The value returned from the advice is then the result of calling the method\n\t */\n\t(result: T, ...args: any[]): T;\n}\n\nexport interface AroundAdvice<T> {\n\t/**\n\t * Advice which is applied *around*.  The advising function receives the original function and\n\t * needs to return a new function which will then invoke the original function.\n\t *\n\t * @param origFn The original function\n\t * @returns A new function which will inoke the original function.\n\t */\n\t(origFn: GenericFunction<T>): (...args: any[]) => T;\n}\n\n/**\n * Types of advice\n */\nexport enum AdviceType { Before, After, Around };\n\n/**\n * A weak map of dispatchers used to apply the advice\n */\nconst dispatchAdviceMap = new WeakMap<Function, DispatchAdvice<any>>();\n\nexport interface GenericFunction<T> {\n\t(...args: any[]): T;\n}\n\n/**\n * Returns the dispatcher function for a given joinPoint (method/function)\n *\n * @param joinPoint The function that is to be advised\n */\nfunction getDispatcher<F extends GenericFunction<T>, T>(joinPoint: F): F {\n\n\tfunction dispatcher(this: Function, ...args: any[]): T {\n\t\tconst { before, after, joinPoint } = dispatchAdviceMap.get(dispatcher);\n\t\tif (before) {\n\t\t\targs = before.reduce((previousArgs, advice) => {\n\t\t\t\tconst currentArgs = advice.apply(this, previousArgs);\n\t\t\t\treturn currentArgs || previousArgs;\n\t\t\t}, args);\n\t\t}\n\t\tlet result = joinPoint.apply(this, args);\n\t\tif (after) {\n\t\t\tresult = after.reduce((previousResult, advice) => {\n\t\t\t\treturn advice.apply(this, [ previousResult ].concat(args));\n\t\t\t}, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/* We want to \"clone\" the advice that has been applied already, if this\n\t * joinPoint is already advised */\n\tif (dispatchAdviceMap.has(joinPoint)) {\n\t\tconst adviceMap = dispatchAdviceMap.get(joinPoint);\n\t\tlet { before, after } = adviceMap;\n\t\tif (before) {\n\t\t\tbefore = before.slice(0);\n\t\t}\n\t\tif (after) {\n\t\t\tafter = after.slice(0);\n\t\t}\n\t\tdispatchAdviceMap.set(dispatcher, {\n\t\t\tjoinPoint: adviceMap.joinPoint,\n\t\t\tbefore,\n\t\t\tafter\n\t\t});\n\t}\n\t/* Otherwise, this is a new joinPoint, so we will create the advice map afresh */\n\telse {\n\t\tdispatchAdviceMap.set(dispatcher, { joinPoint });\n\t}\n\n\treturn dispatcher as F;\n}\n\n/**\n * Advise a join point (function) with supplied advice\n *\n * @param joinPoint The function to be advised\n * @param type The type of advice to be applied\n * @param advice The advice to apply\n */\nfunction advise<F extends GenericFunction<T>, T>(this: any, joinPoint: F, type: AdviceType, advice: BeforeAdvice | AfterAdvice<T> | AroundAdvice<T>): F {\n\tlet dispatcher: F;\n\tif (type === AdviceType.Around) {\n\t\tdispatcher = getDispatcher(advice.apply(this, [ joinPoint ]));\n\t}\n\telse {\n\t\tdispatcher = getDispatcher(joinPoint);\n\t\tconst adviceMap = dispatchAdviceMap.get(dispatcher);\n\t\tif (type === AdviceType.Before) {\n\t\t\t(adviceMap.before || (adviceMap.before = [])).unshift(<BeforeAdvice> advice);\n\t\t}\n\t\telse {\n\t\t\t(adviceMap.after || (adviceMap.after = [])).push(advice);\n\t\t}\n\t}\n\treturn dispatcher;\n}\n\n/**\n * Apply advice *before* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The before advice\n */\nexport function before<F extends GenericFunction<any>>(joinPoint: F, advice: BeforeAdvice): F {\n\treturn advise(joinPoint, AdviceType.Before, advice);\n}\n\n/**\n * Apply advice *after* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The after advice\n */\nexport function after<F extends GenericFunction<T>, T>(joinPoint: F, advice: AfterAdvice<T>): F {\n\treturn advise(joinPoint, AdviceType.After, advice);\n}\n\n/**\n * Apply advice *around* the supplied joinPoint (function)\n *\n * @param joinPoint A function that should have advice applied to\n * @param advice The around advice\n */\nexport function around<F extends GenericFunction<T>, T>(joinPoint: F, advice: AroundAdvice<T>): F {\n\treturn advise<F, T>(joinPoint, AdviceType.Around, advice);\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/aspect.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport { forOf, Iterable } from './iterator';\nimport './Symbol';\n\nmodule Shim {\n\tconst DELETED: any = {};\n\n\tinterface Entry<K, V> {\n\t\tkey: K;\n\t\tvalue: V;\n\t}\n\n\tfunction getUID(): number {\n\t\treturn Math.floor(Math.random() * 100000000);\n\t}\n\n\tlet generateName = (function () {\n\t\tlet startId = Math.floor(Date.now() % 100000000);\n\n\t\treturn function generateName(): string {\n\t\t\treturn '__wm' + getUID() + (startId++ + '__');\n\t\t};\n\t})();\n\n\texport class WeakMap<K, V> {\n\t\tprivate _name: string;\n\t\tprivate _frozenEntries: Entry<K, V>[];\n\n\t\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) {\n\t\t\tObject.defineProperty(this, '_name', {\n\t\t\t\tvalue: generateName()\n\t\t\t});\n\n\t\t\tthis._frozenEntries = [];\n\n\t\t\tif (iterable) {\n\t\t\t\tforOf(iterable, ([ key, value ]: [K, V]) => this.set(key, value));\n\t\t\t}\n\t\t}\n\n\t\tprivate _getFrozenEntryIndex(key: any): number {\n\t\t\tfor (let i = 0; i < this._frozenEntries.length; i++) {\n\t\t\t\tif (this._frozenEntries[i].key === key) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (key === undefined || key === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst entry: Entry<K, V> = key[this._name];\n\t\t\tif (entry && entry.key === key && entry.value !== DELETED) {\n\t\t\t\tentry.value = DELETED;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst frozenIndex = this._getFrozenEntryIndex(key);\n\t\t\tif (frozenIndex >= 0) {\n\t\t\t\tthis._frozenEntries.splice(frozenIndex, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tget(key: any): V | undefined {\n\t\t\tif (key === undefined || key === null) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tconst entry: Entry<K, V> = key[this._name];\n\t\t\tif (entry && entry.key === key && entry.value !== DELETED) {\n\t\t\t\treturn entry.value;\n\t\t\t}\n\n\t\t\tconst frozenIndex = this._getFrozenEntryIndex(key);\n\t\t\tif (frozenIndex >= 0) {\n\t\t\t\treturn this._frozenEntries[frozenIndex].value;\n\t\t\t}\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\tif (key === undefined || key === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst entry: Entry<K, V> = key[this._name];\n\t\t\tif (Boolean(entry && entry.key === key && entry.value !== DELETED)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst frozenIndex = this._getFrozenEntryIndex(key);\n\t\t\tif (frozenIndex >= 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tset(key: any, value?: any): Shim.WeakMap<K, V> {\n\t\t\tif (!key || (typeof key !== 'object' && typeof key !== 'function')) {\n\t\t\t\tthrow new TypeError('Invalid value used as weak map key');\n\t\t\t}\n\t\t\tlet entry: Entry<K, V> = key[this._name];\n\t\t\tif (!entry || entry.key !== key) {\n\t\t\t\tentry = Object.create(null, {\n\t\t\t\t\tkey: { value: key }\n\t\t\t\t});\n\n\t\t\t\tif (Object.isFrozen(key)) {\n\t\t\t\t\tthis._frozenEntries.push(entry);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tObject.defineProperty(key, this._name, {\n\t\t\t\t\t\tvalue: entry\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.value = value;\n\t\t\treturn this;\n\t\t}\n\n\t\t[Symbol.toStringTag]: string = 'WeakMap';\n\t}\n}\n\n@hasClass('es6-weakmap', global.WeakMap, Shim.WeakMap)\nexport default class WeakMap<K, V> {\n\t/* istanbul ignore next */\n\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) {}\n\n\t/* istanbul ignore next */\n\tdelete(key: K): boolean { throw new Error(); }\n\t/* istanbul ignore next */\n\tget(key: K): V { throw new Error(); }\n\t/* istanbul ignore next */\n\thas(key: K): boolean { throw new Error(); }\n\t/* istanbul ignore next */\n\tset(key: K, value?: V): WeakMap<K, V> { throw new Error(); }\n\t/* istanbul ignore next */\n\t[Symbol.toStringTag]: string = 'WeakMap';\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/WeakMap.ts","import { ArrayLike } from 'dojo-interfaces/shim';\nimport has from './support/has';\nimport { wrapNative } from './support/util';\nimport { forOf, isArrayLike, isIterable, Iterable } from './iterator';\nimport { MAX_SAFE_INTEGER as maxSafeInteger } from './number';\n\nexport interface MapCallback<T, U> {\n\t/**\n\t * A callback function when mapping\n\t *\n\t * @param element The element that is currently being mapped\n\t * @param index The current index of the element\n\t */\n\t(element: T, index: number): U;\n}\n\nexport interface FindCallback<T> {\n\t/**\n\t * A callback function when using find\n\t *\n\t * @param element The element that is currenty being analysed\n\t * @param index The current index of the element that is being analysed\n\t * @param array The source array\n\t */\n\t(element: T, index: number, array: ArrayLike<T>): boolean;\n}\n\n/**\n * Ensures a non-negative, non-infinite, safe integer.\n *\n * @param length The number to validate\n * @return A proper length\n */\nfunction toLength(length: number): number {\n\tlength = Number(length);\n\tif (isNaN(length)) {\n\t\treturn 0;\n\t}\n\tif (isFinite(length)) {\n\t\tlength = Math.floor(length);\n\t}\n\t// Ensure a non-negative, real, safe integer\n\treturn Math.min(Math.max(length, 0), maxSafeInteger);\n}\n\n/**\n * From ES6 7.1.4 ToInteger()\n *\n * @param value A value to convert\n * @return An integer\n */\nfunction toInteger(value: any): number {\n\tvalue = Number(value);\n\tif (isNaN(value)) {\n\t\treturn 0;\n\t}\n\tif (value === 0 || !isFinite(value)) {\n\t\treturn value;\n\t}\n\n\treturn (value > 0 ? 1 : -1) * Math.floor(Math.abs(value));\n}\n\n/**\n * Normalizes an offset against a given length, wrapping it if negative.\n *\n * @param value The original offset\n * @param length The total length to normalize against\n * @return If negative, provide a distance from the end (length); otherwise provide a distance from 0\n */\nfunction normalizeOffset(value: number, length: number): number {\n\treturn value < 0 ? Math.max(length + value, 0) : Math.min(value, length);\n}\n\n/**\n * A namespace that contains the polyfilled functionality that is then exported below, depending on if\n * the functionality is required or not.\n */\nexport namespace Shim {\n\texport function from(this: ArrayConstructor, arrayLike: Iterable<any> | ArrayLike<any>, mapFunction?: MapCallback<any, any>, thisArg?: any): Array<any> {\n\t\tif (arrayLike == null) {\n\t\t\tthrow new TypeError('from: requires an array-like object');\n\t\t}\n\n\t\tif (mapFunction && thisArg) {\n\t\t\tmapFunction = mapFunction.bind(thisArg);\n\t\t}\n\n\t\t/* tslint:disable-next-line:variable-name */\n\t\tconst Constructor = this;\n\t\tconst length: number = toLength((<any> arrayLike).length);\n\t\t// Support extension\n\t\tconst array: any[] = (typeof Constructor === 'function') ? <any[]> Object(new Constructor(length)) : new Array(length);\n\n\t\tif (!isArrayLike(arrayLike) && !isIterable(arrayLike)) {\n\t\t\treturn array;\n\t\t}\n\n\t\tlet i = 0;\n\t\tforOf(arrayLike, function (value): void {\n\t\t\tarray[i] = mapFunction ? mapFunction(value, i) : value;\n\t\t\ti++;\n\t\t});\n\n\t\tif ((<any> arrayLike).length !== undefined) {\n\t\t\tarray.length = length;\n\t\t}\n\n\t\treturn array;\n\t}\n\n\texport function of<T>(...items: T[]): Array<T> {\n\t\treturn Array.prototype.slice.call(items);\n\t}\n\n\texport function copyWithin<T>(target: ArrayLike<T>, offset: number, start: number, end?: number): ArrayLike<T> {\n\t\tif (target == null) {\n\t\t\tthrow new TypeError('copyWithin: target must be an array-like object');\n\t\t}\n\n\t\tconst length = toLength(target.length);\n\t\toffset = normalizeOffset(toInteger(offset), length);\n\t\tstart = normalizeOffset(toInteger(start), length);\n\t\tend = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\t\tlet count = Math.min(end - start, length - offset);\n\n\t\tlet direction = 1;\n\t\tif (offset > start && offset < (start + count)) {\n\t\t\tdirection = -1;\n\t\t\tstart += count - 1;\n\t\t\toffset += count - 1;\n\t\t}\n\n\t\twhile (count > 0) {\n\t\t\tif (start in target) {\n\t\t\t\ttarget[offset] = target[start];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete target[offset];\n\t\t\t}\n\n\t\t\toffset += direction;\n\t\t\tstart += direction;\n\t\t\tcount--;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\texport function fill<T>(target: ArrayLike<T>, value: any, start?: number, end?: number): ArrayLike<T> {\n\t\tconst length = toLength(target.length);\n\t\tlet i = normalizeOffset(toInteger(start), length);\n\t\tend = normalizeOffset(end === undefined ? length : toInteger(end), length);\n\n\t\twhile (i < end) {\n\t\t\ttarget[i++] = value;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\texport function find<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): T | undefined {\n\t\tconst index = findIndex<T>(target, callback, thisArg);\n\t\treturn index !== -1 ? target[index] : undefined;\n\t}\n\n\texport function findIndex<T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}): number {\n\t\tconst length = toLength(target.length);\n\n\t\tif (!callback) {\n\t\t\tthrow new TypeError('find: second argument must be a function');\n\t\t}\n\n\t\tif (thisArg) {\n\t\t\tcallback = callback.bind(thisArg);\n\t\t}\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tif (callback(target[i], i, target)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\texport function includes<T>(target: ArrayLike<T>, searchElement: T, fromIndex: number = 0): boolean {\n\t\tlet len = toLength(target.length);\n\n\t\tfor (let i = fromIndex; i < len; ++i) {\n\t\t\tconst currentElement = target[i];\n\t\t\tif (searchElement === currentElement ||\n\t\t\t\t(searchElement !== searchElement && currentElement !== currentElement)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\n/* ES6 Array static methods */\n\nexport interface From {\n\t/**\n\t * The Array.from() method creates a new Array instance from an array-like or iterable object.\n\t *\n\t * @param source An array-like or iterable object to convert to an array\n\t * @param mapFunction A map function to call on each element in the array\n\t * @param thisArg The execution context for the map function\n\t * @return The new Array\n\t */\n\t<T, U>(source: ArrayLike<T> | Iterable<T>, mapFunction: MapCallback<T, U>, thisArg?: any): Array<U>;\n\n\t/**\n\t * The Array.from() method creates a new Array instance from an array-like or iterable object.\n\t *\n\t * @param source An array-like or iterable object to convert to an array\n\t * @return The new Array\n\t */\n\t<T>(source: ArrayLike<T> | Iterable<T>): Array<T>;\n}\n\nexport const from: From = has('es6-array-from')\n\t? (<any> Array).from\n\t: Shim.from;\n\n/**\n * Creates a new array from the function parameters.\n *\n * @param arguments Any number of arguments for the array\n * @return An array from the given arguments\n */\nexport const of: <T>(...items: T[]) => Array<T> = has('es6-array-of')\n\t? (<any> Array).of\n\t: Shim.of;\n\n/* ES6 Array instance methods */\n\n/**\n * Copies data internally within an array or array-like object.\n *\n * @param target The target array-like object\n * @param offset The index to start copying values to; if negative, it counts backwards from length\n * @param start The first (inclusive) index to copy; if negative, it counts backwards from length\n * @param end The last (exclusive) index to copy; if negative, it counts backwards from length\n * @return The target\n */\nexport const copyWithin: <T>(target: ArrayLike<T>, offset: number, start: number, end?: number) => ArrayLike<T> = has('es6-array-copywithin')\n\t? wrapNative((<any> Array.prototype).copyWithin)\n\t: Shim.copyWithin;\n\n/**\n * Fills elements of an array-like object with the specified value.\n *\n * @param target The target to fill\n * @param value The value to fill each element of the target with\n * @param start The first index to fill\n * @param end The (exclusive) index at which to stop filling\n * @return The filled target\n */\nexport const fill: <T>(target: ArrayLike<T>, value: T, start?: number, end?: number) => ArrayLike<T> = has('es6-array-fill')\n\t? wrapNative((<any> Array.prototype).fill)\n\t: Shim.fill;\n\n/**\n * Finds and returns the first instance matching the callback or undefined if one is not found.\n *\n * @param target An array-like object\n * @param callback A function returning if the current value matches a criteria\n * @param [thisArg] The execution context for the find function\n * @return The first element matching the callback, or undefined if one does not exist\n */\nexport const find: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => T = has('es6-array-find')\n\t? wrapNative((<any> Array.prototype).find)\n\t: Shim.find;\n\n/**\n * Performs a linear search and returns the first index whose value satisfies the passed callback,\n * or -1 if no values satisfy it.\n *\n * @param target An array-like object\n * @param callback A function returning true if the current value satisfies its criteria\n * @param [thisArg] The execution context for the find function\n * @return The first index whose value satisfies the passed callback, or -1 if no values satisfy it\n */\nexport const findIndex: <T>(target: ArrayLike<T>, callback: FindCallback<T>, thisArg?: {}) => number = has('es6-array-findindex')\n\t? wrapNative((<any> Array.prototype).findIndex)\n\t: Shim.findIndex;\n\n/* ES7 Array instance methods */\n\n/**\n * Determines whether an array includes a given value\n *\n * @param target the target array-like object\n * @param searchElement the item to search for\n * @param fromIndex the starting index to search from\n * @return `true` if the array includes the element, otherwise `false`\n */\nexport const includes: <T>(target: ArrayLike<T>, searchElement: T, fromIndex?: number) => boolean = has('es7-array-includes')\n\t? wrapNative((<any> Array.prototype).includes)\n\t: Shim.includes;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/array.ts","import global from './support/global';\n\n/**\n * The smallest interval between two representable numbers.\n */\nexport const EPSILON = 1;\n\n/**\n * The maximum safe integer in JavaScript\n */\nexport const MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * The minimum safe integer in JavaScript\n */\nexport const MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;\n\n/**\n * Determines whether the passed value is NaN without coersion.\n *\n * @param value The value to test\n * @return true if the value is NaN, false if it is not\n */\nexport function isNaN(value: any): boolean {\n\treturn typeof value === 'number' && global.isNaN(value);\n}\n\n/**\n * Determines whether the passed value is a finite number without coersion.\n *\n * @param value The value to test\n * @return true if the value is finite, false if it is not\n */\nexport function isFinite(value: any): boolean {\n\treturn typeof value === 'number' && global.isFinite(value);\n}\n\n/**\n * Determines whether the passed value is an integer.\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nexport function isInteger(value: any): boolean {\n\treturn isFinite(value) && Math.floor(value) === value;\n}\n\n/**\n * Determines whether the passed value is an integer that is 'safe,' meaning:\n *   1. it can be expressed as an IEEE-754 double precision number\n *   2. it has a one-to-one mapping to a mathematical integer, meaning its\n *      IEEE-754 representation cannot be the result of rounding any other\n *      integer to fit the IEEE-754 representation\n *\n * @param value The value to test\n * @return true if the value is an integer, false if it is not\n */\nexport function isSafeInteger(value: any): boolean {\n\treturn isInteger(value) && Math.abs(value) <= MAX_SAFE_INTEGER;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/number.ts","import has from './has';\nimport { Handle } from 'dojo-interfaces/core';\n\nconst slice = Array.prototype.slice;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Type guard that ensures that the value can be coerced to Object\n * to weed out host objects that do not derive from Object.\n * This function is used to check if we want to deep copy an object or not.\n * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will\n * change the value returned by `toString`. This is a rare edge case that is difficult to handle,\n * so it is not handled here.\n * @param  value The value to check\n * @return       If the value is coercible into an Object\n */\nfunction shouldDeepCopyObject(value: any): value is Object {\n\treturn Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction copyArray<T>(array: T[], inherited: boolean): T[] {\n\treturn array.map(function (item: T): T {\n\t\tif (Array.isArray(item)) {\n\t\t\treturn  <any> copyArray(<any> item, inherited);\n\t\t}\n\n\t\treturn !shouldDeepCopyObject(item) ?\n\t\t\titem :\n\t\t\t_mixin({\n\t\t\t\tdeep: true,\n\t\t\t\tinherited: inherited,\n\t\t\t\tsources: <Array<T>> [ item ],\n\t\t\t\ttarget: <T> {}\n\t\t\t});\n\t});\n}\n\ninterface MixinArgs<T extends {}, U extends {}> {\n\tdeep: boolean;\n\tinherited: boolean;\n\tsources: (U | null | undefined)[];\n\ttarget: T;\n}\n\nfunction _mixin<T extends {}, U extends {}>(kwArgs: MixinArgs<T, U>): T&U {\n\tconst deep = kwArgs.deep;\n\tconst inherited = kwArgs.inherited;\n\tconst target = kwArgs.target;\n\n\tfor (let source of kwArgs.sources) {\n\t\tif (source === null || source === undefined) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (let key in source) {\n\t\t\tif (inherited || hasOwnProperty.call(source, key)) {\n\t\t\t\tlet value: any = (<any> source)[key];\n\n\t\t\t\tif (deep) {\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tvalue = copyArray(value, inherited);\n\t\t\t\t\t}\n\t\t\t\t\telse if (shouldDeepCopyObject(value)) {\n\t\t\t\t\t\tvalue = _mixin({\n\t\t\t\t\t\t\tdeep: true,\n\t\t\t\t\t\t\tinherited: inherited,\n\t\t\t\t\t\t\tsources: <U[]> [ value ],\n\t\t\t\t\t\t\ttarget: {}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t(<any> target)[key] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn <T&U> target;\n}\n\ninterface ObjectAssignConstructor extends ObjectConstructor {\n\tassign<T extends {}, U extends {}>(target: T, ...sources: (U | null | undefined)[]): T&U;\n}\n\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport const assign = has('object-assign') ?\n\t(<ObjectAssignConstructor> Object).assign :\n\tfunction<T extends {}, U extends {}> (target: T, ...sources: (U | null | undefined)[]): T&U {\n\t\treturn _mixin({\n\t\t\tdeep: false,\n\t\t\tinherited: false,\n\t\t\tsources: sources,\n\t\t\ttarget: target\n\t\t});\n\t};\n\n/**\n * Creates a new object from the given prototype, and copies all enumerable own properties of one or more\n * source objects to the newly created target object.\n *\n * @param prototype The prototype to create a new object from\n * @param mixins Any number of objects whose enumerable own properties will be copied to the created object\n * @return The new object\n */\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y, mixin6: Z): T & U & V & W & X & Y & Z;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X, mixin5: Y): T & U & V & W & X & Y;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W, mixin4: X): T & U & V & W & X;\nexport function create<T extends {}, U extends {}, V extends {}, W extends {}>(prototype: T, mixin1: U, mixin2: V, mixin3: W): T & U & V & W;\nexport function create<T extends {}, U extends {}, V extends {}>(prototype: T, mixin1: U, mixin2: V): T & U & V;\nexport function create<T extends {}, U extends {}>(prototype: T, mixin: U): T & U;\nexport function create<T extends {}>(prototype: T): T;\nexport function create(prototype: any, ...mixins: any[]): any {\n\tif (!mixins.length) {\n\t\tthrow new RangeError('lang.create requires at least one mixin object.');\n\t}\n\n\tconst args = mixins.slice();\n\targs.unshift(Object.create(prototype));\n\n\treturn assign.apply(null, args);\n}\n\n/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object,\n * recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable own properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport function deepAssign<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepAssign<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepAssign<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepAssign(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: false,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object, recursively copying all nested objects and arrays as well.\n *\n * @param target The target object to receive values from source objects\n * @param sources Any number of objects whose enumerable properties will be copied to the target object\n * @return The modified target object\n */\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport function deepMixin<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function deepMixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: true,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Creates a new object using the provided source's prototype as the prototype for the new object, and then\n * deep copies the provided source's values into the new target.\n *\n * @param source The object to duplicate\n * @return The new object\n */\nexport function duplicate<T extends {}>(source: T): T {\n\tconst target = Object.create(Object.getPrototypeOf(source));\n\n\treturn deepMixin(target, source);\n}\n\n/**\n * Determines whether two values are the same value.\n *\n * @param a First value to compare\n * @param b Second value to compare\n * @return true if the values are the same; false otherwise\n */\nexport function isIdentical(a: any, b: any): boolean {\n\treturn a === b ||\n\t\t/* both values are NaN */\n\t\t(a !== a && b !== b);\n}\n\n/**\n * Returns a function that binds a method to the specified object at runtime. This is similar to\n * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.\n * As a result, the function returned by `lateBind` will always call the function currently assigned to\n * the specified property on the object as of the moment the function it returns is called.\n *\n * @param instance The context object\n * @param method The name of the method on the context object to bind to itself\n * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list\n * @return The bound function\n */\nexport function lateBind(instance: {}, method: string, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn suppliedArgs.length ?\n\t\tfunction () {\n\t\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\t\t// TS7017\n\t\t\treturn (<any> instance)[method].apply(instance, args);\n\t\t} :\n\t\tfunction () {\n\t\t\t// TS7017\n\t\t\treturn (<any> instance)[method].apply(instance, arguments);\n\t\t};\n}\n\n/**\n * Copies the values of all enumerable (own or inherited) properties of one or more source objects to the\n * target object.\n *\n * @return The modified target object\n */\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}, Z extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y, source6: Z): T & U & V & W & X & Y & Z;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}, Y extends {}>(target: T, source1: U, source2: V, source3: W, source4: X, source5: Y): T & U & V & W & X & Y;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}, X extends {}>(target: T, source1: U, source2: V, source3: W, source4: X): T & U & V & W & X;\nexport function mixin<T extends {}, U extends {}, V extends {}, W extends {}>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function mixin<T extends {}, U extends {}, V extends {}>(target: T, source1: U, source2: V): T & U & V;\nexport function mixin<T extends {}, U extends {}>(target: T, source: U): T & U;\nexport function mixin(target: any, ...sources: any[]): any {\n\treturn _mixin({\n\t\tdeep: false,\n\t\tinherited: true,\n\t\tsources: sources,\n\t\ttarget: target\n\t});\n}\n\n/**\n * Returns a function which invokes the given function with the given arguments prepended to its argument list.\n * Like `Function.prototype.bind`, but does not alter execution context.\n *\n * @param targetFunction The function that needs to be bound\n * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list\n * @return The bound function\n */\nexport function partial(targetFunction: (...args: any[]) => any, ...suppliedArgs: any[]): (...args: any[]) => any {\n\treturn function (this: any) {\n\t\tconst args: any[] = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;\n\n\t\treturn targetFunction.apply(this, args);\n\t};\n}\n\n/**\n * Returns an object with a destroy method that, when called, calls the passed-in destructor.\n * This is intended to provide a unified interface for creating \"remove\" / \"destroy\" handlers for\n * event listeners, timers, etc.\n *\n * @param destructor A function that will be called when the handle's `destroy` method is invoked\n * @return The handle object\n */\nexport function createHandle(destructor: () => void): Handle {\n\treturn {\n\t\tdestroy: function (this: Handle) {\n\t\t\tthis.destroy = function () {};\n\t\t\tdestructor.call(this);\n\t\t}\n\t};\n}\n\n/**\n * Returns a single handle that can be used to destroy multiple handles simultaneously.\n *\n * @param handles An array of handles with `destroy` methods\n * @return The handle object\n */\nexport function createCompositeHandle(...handles: Handle[]): Handle {\n\treturn createHandle(function () {\n\t\tfor (let handle of handles) {\n\t\t\thandle.destroy();\n\t\t}\n\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/lang.ts","import global from './global';\nimport has, { add } from 'dojo-shim/support/has';\n\nexport * from 'dojo-shim/support/has';\nexport default has;\n\nadd('object-assign', typeof global.Object.assign === 'function');\n\nadd('raf', typeof requestAnimationFrame === 'function');\n\nadd('arraybuffer', typeof global.ArrayBuffer !== 'undefined');\nadd('formdata', typeof global.FormData !== 'undefined');\nadd('xhr', typeof global.XMLHttpRequest !== 'undefined');\nadd('xhr2', has('xhr') && 'responseType' in global.XMLHttpRequest.prototype);\nadd('xhr2-blob', function () {\n\tif (!has('xhr2')) {\n\t\treturn false;\n\t}\n\n\tconst request = new XMLHttpRequest();\n\trequest.open('GET', '/', true);\n\trequest.responseType = 'blob';\n\trequest.abort();\n\treturn request.responseType === 'blob';\n});\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/has.ts","const globalObject: any = (function (): any {\n\tif (typeof window !== 'undefined') {\n\t\t// Browsers\n\t\treturn window;\n\t}\n\telse if (typeof global !== 'undefined') {\n\t\t// Node\n\t\treturn global;\n\t}\n\telse if (typeof self !== 'undefined') {\n\t\t// Web workers\n\t\treturn self;\n\t}\n\treturn {};\n})();\n\nexport default globalObject;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/global.ts","import { Thenable } from 'dojo-interfaces/shim';\nimport global from './support/global';\nimport { queueMicroTask } from './support/queue';\nimport { forOf, Iterable } from './iterator';\nimport './Symbol';\nimport { hasClass } from './support/decorators';\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t/**\n\t * The executor for the promise\n\t *\n\t * @param resolve The resolver callback of the promise\n\t * @param reject The rejector callback of the promise\n\t */\n\t(resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;\n}\n\nmodule Shim {\n\n\t/**\n\t * The State enum represents the possible states of a promise.\n\t */\n\texport const enum State {\n\t\tFulfilled,\n\t\tPending,\n\t\tRejected\n\t}\n\n\t/**\n\t * Returns true if a given value has a `then` method.\n\t * @param {any} value The value to check if is Thenable\n\t * @returns {is Thenable<T>} A type guard if the value is thenable\n\t */\n\texport function isThenable<T>(value: any): value is Thenable<T> {\n\t\treturn value && typeof value.then === 'function';\n\t}\n\n\t/**\n\t * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t * not intended to be used directly.\n\t *\n\t * @borrows Promise.all as Promise.all\n\t * @borrows Promise.race as Promise.race\n\t * @borrows Promise.reject as Promise.reject\n\t * @borrows Promise.resolve as Promise.resolve\n\t * @borrows Promise#catch as Promise#catch\n\t * @borrows Promise#then as Promise#then\n\t */\n\texport class Promise<T> implements Thenable<T> {\n\t\tstatic all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\tconst values: T[] = [];\n\t\t\t\tlet complete = 0;\n\t\t\t\tlet total = 0;\n\t\t\t\tlet populating = true;\n\n\t\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\t\tvalues[ index ] = value;\n\t\t\t\t\t++complete;\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\n\t\t\t\tfunction finish(): void {\n\t\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(values);\n\t\t\t\t}\n\n\t\t\t\tfunction processItem(index: number, item: (T | Thenable<T>)): void {\n\t\t\t\t\t++total;\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If an item Promise rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPromise.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tforOf(iterable, function (value: T | Thenable<T>) {\n\t\t\t\t\tprocessItem(i, value);\n\t\t\t\t\ti++;\n\t\t\t\t});\n\t\t\t\tpopulating = false;\n\n\t\t\t\tfinish();\n\t\t\t});\n\t\t}\n\n\t\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\tforOf(iterable, function (item: T | Thenable<T>) {\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If a Promise item rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPromise.resolve(item).then(resolve);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tstatic reject<T>(reason?: Error): Promise<T> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t}\n\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T> {\n\t\t\treturn new this(function (resolve) {\n\t\t\t\tresolve(<T> value);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>) {\n\t\t\t/**\n\t\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t\t */\n\t\t\tlet isChained = false;\n\n\t\t\t/**\n\t\t\t * Whether or not this promise is in a resolved state.\n\t\t\t */\n\t\t\tconst isResolved = (): boolean => {\n\t\t\t\treturn this.state !== State.Pending || isChained;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t\t */\n\t\t\tlet callbacks: null | (Array<() => void>) = [];\n\n\t\t\t/**\n\t\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t\t */\n\t\t\tlet whenFinished = function (callback: () => void): void {\n\t\t\t\tif (callbacks) {\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Settles this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|Error} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t\t// A promise can only be settled once.\n\t\t\t\tif (this.state !== State.Pending) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.state = newState;\n\t\t\t\tthis.resolvedValue = value;\n\t\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t\t// wait an extra turn.\n\t\t\t\tif (callbacks && callbacks.length > 0) {\n\t\t\t\t\tqueueMicroTask(function (): void {\n\t\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\t\t\tcallbacks[ i ].call(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallbacks = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Resolves this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|Error} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\t\tif (isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(value)) {\n\t\t\t\t\tvalue.then(\n\t\t\t\t\t\tsettle.bind(null, State.Fulfilled),\n\t\t\t\t\t\tsettle.bind(null, State.Rejected)\n\t\t\t\t\t);\n\t\t\t\t\tisChained = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsettle(newState, value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.then = <U>(onFulfilled?: (value?: T) => (U | Promise<U>),\n\t\t\t\t\t\t\tonRejected?: (reason?: Error) => (U | Promise<U>)): Promise<U> => {\n\t\t\t\treturn new Promise<U>((resolve, reject) => {\n\t\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t\t// event loop.\n\t\t\t\t\twhenFinished(() => {\n\t\t\t\t\t\tconst callback: ((value?: any) => any) | undefined = this.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.state === State.Rejected) {\n\t\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\t(<Executor<T>> executor)(\n\t\t\t\t\tresolve.bind(null, State.Fulfilled),\n\t\t\t\t\tresolve.bind(null, State.Rejected)\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tsettle(State.Rejected, error);\n\t\t\t}\n\t\t}\n\n\t\tcatch<U>(onRejected: (reason: Error) => (U | Thenable<U>)): Promise<U> {\n\t\t\treturn this.then<U>(undefined, onRejected);\n\t\t}\n\n\t\t/**\n\t\t * The current state of this promise.\n\t\t */\n\t\tprivate state = State.Pending;\n\n\t\t/**\n\t\t * The resolved value for this promise.\n\t\t *\n\t\t * @type {T|Error}\n\t\t */\n\t\tprivate resolvedValue: any;\n\n\t\tthen: <U>(onFulfilled?: (value: T) => (U | Thenable<U>), onRejected?: (reason: Error) => (U | Thenable<U>)) => Promise<U>;\n\n\t\t[Symbol.toStringTag]: string = 'Promise';\n\t}\n}\n\n@hasClass('es6-promise', global.Promise, Shim.Promise)\nexport default class Promise<T> implements Thenable<T> {\n\t/**\n\t * Creates a new Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\t/* istanbul ignore next */\n\tconstructor(executor: Executor<T>) {\n\t}\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t *\n\t * @example\n\t * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t *     value[0] === 'foo'; // true\n\t *     value[1] === 'bar'; // true\n\t * });\n\t *\n\t * @example\n\t * Promise.all({\n\t *     foo: Promise.resolve('foo'),\n\t *     bar: 'bar'\n\t * }).then((value) => {\n\t *     value.foo === 'foo'; // true\n\t *     value.bar === 'bar'; // true\n\t * });\n\t */\n\t/* istanbul ignore next */\n\tstatic all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\tthrow new Error();\n\t};\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t *\n\t * @example\n\t * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t *\n\t * @example\n\t * Promise.race({\n\t *     foo: Promise.resolve('foo'),\n\t *     bar: Promise.resolve('bar')\n\t * }).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t */\n\t/* istanbul ignore next */\n\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> |  (T | Thenable<T>)[]): Promise<T> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Creates a new promise that is rejected with the given error.\n\t */\n\t/* istanbul ignore next */\n\tstatic reject<T>(reason?: Error): Promise<any> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Creates a new promise that is resolved with the given value.\n\t */\n\tstatic resolve(): Promise<void>;\n\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t/* istanbul ignore next */\n\tstatic resolve<T>(value?: any): Promise<T> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.\n\t */\n\tcatch<U>(onRejected: (reason: Error) => (U | Thenable<U>)): Promise<U>;\n\t/* istanbul ignore next */\n\tcatch<U>(onRejected: (reason: Error) => void): Promise<U> {\n\t\tthrow new Error();\n\t}\n\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | null | undefined)) | null | undefined, onRejected?: (reason: Error) => void): Promise<U>;\n\t/* istanbul ignore next */\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | null | undefined)) | null | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): Promise<U> {\n\t\tthrow new Error();\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Promise.ts","import { Handle } from 'dojo-interfaces/core';\nimport global from './global';\nimport has from './has';\n\nexport interface QueueItem {\n\tisActive: boolean;\n\tcallback: (...args: any[]) => any;\n}\n\ninterface PostMessageEvent extends Event {\n\tsource: any;\n\tdata: string;\n}\n\n/**\n * Executes a task\n * @param item The task to execute\n */\nfunction executeTask(item: QueueItem | undefined): void {\n\tif (item && item.isActive) {\n\t\titem.callback();\n\t}\n}\n\n/**\n * Get a handle to be able to remove an item from the queue\n */\nfunction getQueueHandle(item: QueueItem | undefined, destructor?: (...args: any[]) => any): Handle {\n\treturn {\n\t\tdestroy: function (this: any) {\n\t\t\tthis.destroy = function () {};\n\t\t\tif (item) {\n\t\t\t\titem.isActive = false;\n\t\t\t}\n\t\t\tif (destructor) {\n\t\t\t\tdestructor();\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst microTasks: QueueItem[] = [];\nlet microTaskQueued = false;\nlet checkMicroTaskQueue: () => void = function () {};\n\n/**\n * Schedules a callback to the macrotask queue.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport const queueTask = (function() {\n\tlet destructor: (...args: any[]) => any;\n\tlet enqueue: (item: QueueItem) => void;\n\n\t/* IE and Edge's setImmediate does not always resolve as a macro task, sometimes as a microtask */\n\tif (has('postmessage')) {\n\t\tconst queue: QueueItem[] = [];\n\n\t\taddEventListener('message', function (event: PostMessageEvent): void {\n\t\t\t// Confirm that the event was triggered by the current window and by this particular implementation.\n\t\t\tif (event.source === global && event.data === 'dojo-queue-message') {\n\t\t\t\tevent.stopPropagation();\n\n\t\t\t\tif (queue.length) {\n\t\t\t\t\texecuteTask(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tqueue.push(item);\n\t\t\tpostMessage('dojo-queue-message', '*');\n\t\t};\n\t}\n\telse if (has('setimmediate')) {\n\t\tdestructor = clearImmediate;\n\t\tenqueue = function (item: QueueItem): any {\n\t\t\treturn setImmediate(executeTask.bind(null, item));\n\t\t};\n\t}\n\telse {\n\t\tdestructor = clearTimeout;\n\t\tenqueue = function (item: QueueItem): any {\n\t\t\treturn setTimeout(executeTask.bind(null, item), 0);\n\t\t};\n\t}\n\n\tfunction queueTask(callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\t\tconst id: any = enqueue(item);\n\n\t\treturn getQueueHandle(item, destructor && function () {\n\t\t\tdestructor(id);\n\t\t});\n\t};\n\n\t// TODO: Use aspect.before when it is available.\n\treturn has('microtasks') ? queueTask : function (callback: (...args: any[]) => any): Handle {\n\t\tcheckMicroTaskQueue();\n\t\treturn queueTask(callback);\n\t};\n})();\n\ncheckMicroTaskQueue = !has('microtasks')\n\t? function () {\n\t\tif (!microTaskQueued) {\n\t\t\tmicroTaskQueued = true;\n\t\t\tqueueTask(function () {\n\t\t\t\tmicroTaskQueued = false;\n\n\t\t\t\tif (microTasks.length) {\n\t\t\t\t\tlet item: QueueItem | undefined;\n\t\t\t\t\twhile (item = microTasks.shift()) {\n\t\t\t\t\t\texecuteTask(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t} : checkMicroTaskQueue;\n\n/**\n * Schedules a callback to the microtask queue.\n *\n * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n * registered with `queueTask` or `queueAnimationTask`.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport const queueMicroTask = (function () {\n\tlet enqueue: (item: QueueItem) => void;\n\n\tif (has('host-node')) {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tprocess.nextTick(executeTask.bind(null, item));\n\t\t};\n\t}\n\t/* Edge's Promise does not consitently resolve as a microtask, therefore not using Promise */\n\telse if (has('es6-promise') && !has('setimmediate') && !has('host-node')) {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tglobal.Promise.resolve(item).then(executeTask);\n\t\t};\n\t}\n\telse if (has('dom-mutationobserver')) {\n\t\t/* tslint:disable-next-line:variable-name */\n\t\tconst HostMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\t\tconst node = document.createElement('div');\n\t\tconst queue: QueueItem[] = [];\n\t\tconst observer = new HostMutationObserver(function (): void {\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tconst item = queue.shift();\n\t\t\t\tif (item && item.isActive) {\n\t\t\t\t\titem.callback();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tobserver.observe(node, { attributes: true });\n\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tqueue.push(item);\n\t\t\tnode.setAttribute('queueStatus', '1');\n\t\t};\n\t}\n\telse {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tcheckMicroTaskQueue();\n\t\t\tmicroTasks.push(item);\n\t\t};\n\t}\n\n\treturn function (callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\n\t\tenqueue(item);\n\n\t\treturn getQueueHandle(item);\n\t};\n})();\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/support/queue.ts","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 30\n// module chunks = 0","import { ArrayLike } from 'dojo-interfaces/shim';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport { forOf, Iterable, IterableIterator, ShimIterator } from './iterator';\nimport { is as objectIs } from './object';\nimport './Symbol';\n\nexport namespace Shim {\n\t/**\n\t * An implementation analogous to the Map specification in ES2015.\n\t */\n\texport class Map<K, V> {\n\t\tprotected _keys: K[] = [];\n\t\tprotected _values: V[] = [];\n\n\t\t/**\n\t\t * An alternative to Array.prototype.indexOf using Object.is\n\t\t * to check for equality. See http://mzl.la/1zuKO2V\n\t\t */\n\t\tprotected _indexOfKey(keys: K[], key: K): number {\n\t\t\tfor (let i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tif (objectIs(keys[i], key)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\t/**\n\t\t * Creates a new Map\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param iterator\n\t\t * Array or iterator containing two-item tuples used to initially populate the map.\n\t\t * The first item in each tuple corresponds to the key of the map entry.\n\t\t * The second item corresponds to the value of the map entry.\n\t\t */\n\t\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) {\n\t\t\tif (iterable) {\n\t\t\t\tforOf(iterable, (value: [K, V]) => {\n\t\t\t\t\tthis.set(value[0], value[1]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the number of key / value pairs in the Map.\n\t\t *\n\t\t * @return the number of key / value pairs in the Map\n\t\t */\n\t\tget size(): number {\n\t\t\treturn this._keys.length;\n\t\t}\n\n\t\t/**\n\t\t * Deletes all keys and their associated values.\n\t\t */\n\t\tclear(): void {\n\t\t\tthis._keys.length = this._values.length = 0;\n\t\t}\n\n\t\t/**\n\t\t * Deletes a given key and its associated value.\n\t\t *\n\t\t * @param key The key to delete\n\t\t * @return true if the key exists, false if it does not\n\t\t */\n\t\tdelete(key: K): boolean {\n\t\t\tconst index = this._indexOfKey(this._keys, key);\n\t\t\tif (index < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._keys.splice(index, 1);\n\t\t\tthis._values.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n\t\t * Returns an iterator that yields each key/value pair as an array.\n\t\t *\n\t\t * @return An iterator for each key/value pair in the instance.\n\t\t */\n\t\tentries(): IterableIterator<[K, V]> {\n\t\t\tconst values = this._keys.map((key: K, i: number): [K, V] => {\n\t\t\t\treturn [ key, this._values[i] ];\n\t\t\t});\n\n\t\t\treturn new ShimIterator<[K, V]>(values);\n\t\t}\n\n\t\t/**\n\t\t * Executes a given function for each map entry. The function\n\t\t * is invoked with three arguments: the element value, the\n\t\t * element key, and the associated Map instance.\n\t\t *\n\t\t * @param callback The function to execute for each map entry,\n\t\t * @param context The value to use for `this` for each execution of the calback\n\t\t */\n\t\tforEach(callback: (value: V, key: K, mapInstance: Map<K, V>) => any, context?: {}) {\n\t\t\tconst keys = this._keys;\n\t\t\tconst values = this._values;\n\t\t\tfor (let i = 0, length = keys.length; i < length; i++) {\n\t\t\t\tcallback.call(context, values[i], keys[i], this);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Returns the value associated with a given key.\n\t\t *\n\t\t * @param key The key to look up\n\t\t * @return The value if one exists or undefined\n\t\t */\n\t\tget(key: K): V | undefined {\n\t\t\tconst index = this._indexOfKey(this._keys, key);\n\t\t\treturn index < 0 ? undefined : this._values[index];\n\t\t}\n\n\t\t/**\n\t\t * Checks for the presence of a given key.\n\t\t *\n\t\t * @param key The key to check for\n\t\t * @return true if the key exists, false if it does not\n\t\t */\n\t\thas(key: K): boolean {\n\t\t\treturn this._indexOfKey(this._keys, key) > -1;\n\t\t}\n\n\t\t/**\n\t\t * Returns an iterator that yields each key in the map.\n\t\t *\n\t\t * @return An iterator containing the instance's keys.\n\t\t */\n\t\tkeys(): IterableIterator<K> {\n\t\t\treturn new ShimIterator<K>(this._keys);\n\t\t}\n\n\t\t/**\n\t\t * Sets the value associated with a given key.\n\t\t *\n\t\t * @param key The key to define a value to\n\t\t * @param value The value to assign\n\t\t * @return The Map instance\n\t\t */\n\t\tset(key: K, value: V): Map<K, V> {\n\t\t\tlet index = this._indexOfKey(this._keys, key);\n\t\t\tindex = index < 0 ? this._keys.length : index;\n\t\t\tthis._keys[index] = key;\n\t\t\tthis._values[index] = value;\n\t\t\treturn this;\n\t\t}\n\n\t\t/**\n\t\t * Returns an iterator that yields each value in the map.\n\t\t *\n\t\t * @return An iterator containing the instance's values.\n\t\t */\n\t\tvalues(): IterableIterator<V> {\n\t\t\treturn new ShimIterator<V>(this._values);\n\t\t}\n\n\t\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\t\treturn this.entries();\n\t\t}\n\n\t\t[Symbol.toStringTag]: string = 'Map';\n\t}\n}\n\n@hasClass('es6-map', global.Map, Shim.Map)\nexport default class Map<K, V> {\n\t/* istanbul ignore next */\n\tconstructor(iterable?: ArrayLike<[K, V]> | Iterable<[K, V]>) { };\n\n\t/* istanbul ignore next */\n\tget size(): number { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tclear(): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tdelete(key: K): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tentries(): IterableIterator<[K, V]> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tforEach(callback: (value: V, key: K, mapInstance: Map<K, V>) => any, context?: {}): void { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tget(key: K): V | undefined { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\thas(key: K): boolean { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tkeys(): IterableIterator<K> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tset(key: K, value: V): Map<K, V> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\tvalues(): IterableIterator<V> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.iterator](): IterableIterator<[K, V]> { throw new Error('Abstract method'); };\n\t/* istanbul ignore next */\n\t[Symbol.toStringTag]: string = 'Map';\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/Map.ts","import './Symbol';\n\nnamespace Shim {\n\texport function is(value1: any, value2: any): boolean {\n\t\tif (value1 === value2) {\n\t\t\treturn value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t\t}\n\t\treturn value1 !== value1 && value2 !== value2; // NaN\n\t}\n\n\texport function getOwnPropertySymbols(o: any): symbol[] {\n\t\treturn Object.getOwnPropertyNames(o).filter((key) => Boolean(key.match(/^@@.+/)))\n\t\t\t.map((key) => Symbol.for(key.substring(2)));\n\t}\n\n\texport function getOwnPropertyNames(o: any): string[] {\n\t\treturn Object.getOwnPropertyNames(o).filter((key) => !Boolean(key.match(/^@@.+/)));\n\t}\n}\n\n/**\n * Determines whether two values are the same value.\n *\n * @param value1 The first value to compare\n * @param value2 The second value to compare\n * @return true if the values are the same; false otherwise\n */\nexport const is: (value1: any, value2: any) => boolean = 'is' in Object\n\t? (<any> Object).is\n\t: Shim.is;\n\n/**\n * Returns an array of own properties who key is a symbol\n *\n * @param o The object to return the properties for\n */\nexport const getOwnPropertySymbols: (o: any) => symbol[] = 'getOwnPropertySymbols' in Object\n\t? (<any> Object).getOwnPropertySymbols\n\t: Shim.getOwnPropertySymbols;\n\n/**\n * Returns an array of own properties who key is a string\n *\n * @param o The object to return the properties for\n */\n/* intentionally detecting `getOwnPropertySymbols` because we should should provide the shim\n * when there is no support for symbols */\nexport const getOwnPropertyNames: (o: any) => string[] = 'getOwnPropertySymbols' in Object\n\t? Object.getOwnPropertyNames\n\t: Shim.getOwnPropertyNames;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-shim/object.ts","import { Handle } from 'dojo-interfaces/core';\nimport { createHandle } from './lang';\n\n/**\n * An object that provides the necessary APIs to be MapLike\n */\nexport interface MapLike<K, V> {\n\tget(key: K): V;\n\tset(key: K, value?: V): this;\n}\n\n/**\n * An internal type guard that determines if an value is MapLike or not\n *\n * @param value The value to guard against\n */\nfunction isMapLike(value: any): value is MapLike<any, any> {\n\treturn value && typeof value.get === 'function' && typeof value.set === 'function';\n}\n\nexport interface Indexable {\n\t[method: string]: any;\n}\n\n/**\n * The types of objects or maps where advice can be applied\n */\nexport type Targetable = MapLike<string, any> | Indexable;\n\ntype AdviceType = 'before' | 'after';\n\n/**\n * A meta data structure when applying advice\n */\ninterface Advised {\n\tid?: number;\n\tadvice?: Function;\n\tprevious?: Advised;\n\tnext?: Advised;\n\treceiveArguments?: boolean;\n}\n\n/**\n * A function that dispatches advice which is decorated with additional\n * meta data about the advice to apply\n */\ninterface Dispatcher {\n\t[ type: string ]: Advised | undefined;\n\t(): any;\n\ttarget: any;\n\tbefore?: Advised;\n\taround?: Advised;\n\tafter?: Advised;\n}\n\n/**\n * A UID for tracking advice ordering\n */\nlet nextId = 0;\n\n/**\n * Internal function that advises a join point\n *\n * @param dispatcher The current advice dispatcher\n * @param type The type of before or after advice to apply\n * @param advice The advice to apply\n * @param receiveArguments If true, the advice will receive the arguments passed to the join point\n * @return The handle that will remove the advice\n */\nfunction advise(\n\tdispatcher: Dispatcher | undefined,\n\ttype: AdviceType,\n\tadvice: Function | undefined,\n\treceiveArguments?: boolean\n): Handle {\n\tlet previous = dispatcher && dispatcher[type];\n\tlet advised: Advised | undefined = {\n\t\tid: nextId++,\n\t\tadvice: advice,\n\t\treceiveArguments: receiveArguments\n\t};\n\n\tif (previous) {\n\t\tif (type === 'after') {\n\t\t\t// add the listener to the end of the list\n\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\twhile (previous.next && (previous = previous.next)) {}\n\t\t\tprevious.next = advised;\n\t\t\tadvised.previous = previous;\n\t\t}\n\t\telse {\n\t\t\t// add to the beginning\n\t\t\tif (dispatcher) {\n\t\t\t\tdispatcher.before = advised;\n\t\t\t}\n\t\t\tadvised.next = previous;\n\t\t\tprevious.previous = advised;\n\t\t}\n\t}\n\telse {\n\t\tdispatcher && (dispatcher[type] = advised);\n\t}\n\n\tadvice = previous = undefined;\n\n\treturn createHandle(function () {\n\t\tlet { previous = undefined, next = undefined } = (advised || {});\n\n\t\tif (dispatcher && !previous && !next) {\n\t\t\tdispatcher[type] = undefined;\n\t\t}\n\t\telse {\n\t\t\tif (previous) {\n\t\t\t\tprevious.next = next;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdispatcher && (dispatcher[type] = next);\n\t\t\t}\n\n\t\t\tif (next) {\n\t\t\t\tnext.previous = previous;\n\t\t\t}\n\t\t}\n\t\tif (advised) {\n\t\t\tdelete advised.advice;\n\t\t}\n\t\tdispatcher = advised = undefined;\n\t});\n}\n\n/**\n * An internal function that resolves or creates the dispatcher for a given join point\n *\n * @param target The target object or map\n * @param methodName The name of the method that the dispatcher should be resolved for\n * @return The dispatcher\n */\nfunction getDispatcher(target: Targetable, methodName: string): Dispatcher {\n\tconst existing = isMapLike(target) ? target.get(methodName) : target && target[methodName];\n\tlet dispatcher: Dispatcher;\n\n\tif (!existing || existing.target !== target) {\n\t\t/* There is no existing dispatcher, therefore we will create one */\n\t\tdispatcher = <Dispatcher> function (this: Dispatcher): any {\n\t\t\tlet executionId = nextId;\n\t\t\tlet args = arguments;\n\t\t\tlet results: any;\n\t\t\tlet before = dispatcher.before;\n\n\t\t\twhile (before) {\n\t\t\t\tif (before.advice) {\n\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t}\n\t\t\t\tbefore = before.next;\n\t\t\t}\n\n\t\t\tif (dispatcher.around && dispatcher.around.advice) {\n\t\t\t\tresults = dispatcher.around.advice(this, args);\n\t\t\t}\n\n\t\t\tlet after = dispatcher.after;\n\t\t\twhile (after && after.id < executionId) {\n\t\t\t\tif (after.advice) {\n\t\t\t\t\tif (after.receiveArguments) {\n\t\t\t\t\t\tlet newResults = after.advice.apply(this, args);\n\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tafter = after.next;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t};\n\n\t\tif (isMapLike(target)) {\n\t\t\ttarget.set(methodName, dispatcher);\n\t\t}\n\t\telse {\n\t\t\ttarget && (target[methodName] = dispatcher);\n\t\t}\n\n\t\tif (existing) {\n\t\t\tdispatcher.around = {\n\t\t\t\tadvice: function (target: any, args: any[]): any {\n\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tdispatcher.target = target;\n\t}\n\telse {\n\t\tdispatcher = existing;\n\t}\n\n\treturn dispatcher;\n}\n\n/**\n * Attaches \"after\" advice to be executed after the original method.\n * The advising function will receive the original method's return value and arguments object.\n * The value it returns will be returned from the method when it is called (even if the return value is undefined).\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original method's return value and arguments object\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function after(target: Targetable, methodName: string, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice);\n}\n\n/**\n * Attaches \"around\" advice around the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the original function\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function around(target: Targetable, methodName: string, advice: ((previous: Function) => Function)): Handle {\n\tlet dispatcher: Dispatcher | undefined = getDispatcher(target, methodName);\n\tlet previous = dispatcher.around;\n\tlet advised: Function | undefined;\n\tif (advice) {\n\t\tadvised = advice(function (this: Dispatcher): any {\n\t\t\tif (previous && previous.advice) {\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispatcher.around = {\n\t\tadvice: function (target: any, args: any[]): any {\n\t\t\treturn advised ? advised.apply(target, args) : previous && previous.advice && previous.advice(target, args);\n\t\t}\n\t};\n\n\treturn createHandle(function () {\n\t\tadvised = dispatcher = undefined;\n\t});\n}\n\n/**\n * Attaches \"before\" advice to be executed before the original method.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original, and may return new arguments\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function before(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any[] | void): Handle {\n\treturn advise(getDispatcher(target, methodName), 'before', advice);\n}\n\n/**\n * Attaches advice to be executed after the original method.\n * The advising function will receive the same arguments as the original method.\n * The value it returns will be returned from the method when it is called *unless* its return value is undefined.\n *\n * @param target Object whose method will be aspected\n * @param methodName Name of method to aspect\n * @param advice Advising function which will receive the same arguments as the original method\n * @return A handle which will remove the aspect when destroy is called\n */\nexport function on(target: Targetable, methodName: string, advice: (...originalArgs: any[]) => any): Handle {\n\treturn advise(getDispatcher(target, methodName), 'after', advice, true);\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/aspect.ts","import { VNodeProperties } from 'maquette';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport { EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport createStateful, { Stateful, State, StatefulOptions } from 'dojo-compose/mixins/createStateful';\nimport createCancelableEvent, { CancelableEvent } from 'dojo-compose/util/createCancelableEvent';\nimport { Handle } from 'dojo-core/interfaces';\nimport { assign } from 'dojo-core/lang';\nimport { NodeAttributeFunction } from './createRenderMixin';\nimport { stringToValue, valueToString } from '../util/lang';\n\nexport interface FormFieldMixinOptions<V, S extends FormFieldMixinState<V>> extends StatefulOptions<S> {\n\t/**\n\t * The type of the form field (equates to the `type` attribute in the DOM)\n\t */\n\ttype?: string;\n\n\t/**\n\t * The value of the form field\n\t */\n\tvalue?: V;\n}\n\nexport interface FormFieldMixinState<V> extends State {\n\t/**\n\t * Whether the field is currently disabled or not\n\t */\n\tdisabled?: boolean;\n\n\t/**\n\t * The form widget's name\n\t */\n\tname?: string;\n\n\t/**\n\t * The current value\n\t */\n\tvalue?: V;\n}\n\nexport interface ValueChangeEvent<V> extends CancelableEvent<'valuechange', FormFieldMixin<V, FormFieldMixinState<V>>> {\n\t/**\n\t * The event type (in this case, `valuechange`)\n\t */\n\ttype: 'valuechange';\n\n\t/**\n\t * The previous value before this event\n\t */\n\toldValue: string;\n\n\t/**\n\t * The current value when this event fires\n\t */\n\tvalue: string;\n}\n\nexport interface FormField<V> {\n\t/**\n\t * An array of functions that generate the node attributes on a render\n\t */\n\tnodeAttributes: NodeAttributeFunction[];\n\n\t/**\n\t * The HTML type for this widget\n\t */\n\ttype?: string;\n\n\t/**\n\t * The string value of this form widget, which is read from the widget state\n\t */\n\tvalue?: string;\n}\n\nexport interface FormFieldOverride<V> {\n\t/**\n\t * Add listener for a `valuechange` event, emitted when the value on the widget changes\n\t */\n\ton(type: 'valuechange', listener: EventedListener<ValueChangeEvent<V>>): Handle;\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type FormFieldMixin<V, S extends FormFieldMixinState<V>> = FormField<V> & Stateful<S> & FormFieldOverride<V>;\n\nexport interface FormMixinFactory extends ComposeFactory<FormFieldMixin<any, FormFieldMixinState<any>>, FormFieldMixinOptions<any, FormFieldMixinState<any>>> {\n\t<V>(options?: FormFieldMixinOptions<V, FormFieldMixinState<V>>): FormFieldMixin<V, FormFieldMixinState<V>>;\n}\n\nconst createFormMixin: FormMixinFactory = createStateful\n\t.mixin({\n\t\tmixin: <FormField<any>> {\n\t\t\tget value(this: FormFieldMixin<any, FormFieldMixinState<any>>): string {\n\t\t\t\treturn valueToString(this.state.value);\n\t\t\t},\n\n\t\t\tset value(this: FormFieldMixin<any, FormFieldMixinState<any>>, value: string) {\n\t\t\t\tif (value !== this.state.value) {\n\t\t\t\t\tconst event = assign(createCancelableEvent({\n\t\t\t\t\t\ttype: 'valuechange',\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t}), {\n\t\t\t\t\t\toldValue: valueToString(this.state.value),\n\t\t\t\t\t\tvalue\n\t\t\t\t\t});\n\t\t\t\t\tthis.emit(event);\n\t\t\t\t\tif (!event.defaultPrevented) {\n\t\t\t\t\t\tthis.setState({ value: stringToValue(event.value) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: FormFieldMixin<any, FormFieldMixinState<any>>): VNodeProperties {\n\t\t\t\t\tconst { type, value, state } = this;\n\t\t\t\t\tconst { disabled, name } = state;\n\n\t\t\t\t\treturn { type, value, name, disabled: Boolean(disabled) };\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\tinitialize(\n\t\t\tinstance: FormFieldMixin<any, FormFieldMixinState<any>>,\n\t\t\t{ value, type }: FormFieldMixinOptions<any, FormFieldMixinState<any>> = {}\n\t\t) {\n\t\t\tif (value) {\n\t\t\t\tinstance.setState({ value });\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tinstance.type = type;\n\t\t\t}\n\t\t}\n\t});\n\nexport default createFormMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createFormFieldMixin.ts","import { List } from 'immutable';\nimport { Handle } from 'dojo-core/interfaces';\nimport { Parent, Child, ChildrenMap } from '../mixins/interfaces';\n\nexport type Position = number | 'first' | 'last' | 'before' | 'after';\n\nfunction getIndex<T>(list: List<T> | T[], item: T, position: Position, reference?: T): number {\n\tlet idx: number;\n\tif (typeof position === 'number') {\n\t\tidx = position;\n\t\tconst size = Array.isArray(list) ? list.length : list.size;\n\t\tif (idx < 0 || idx > size) {\n\t\t\tthrow new Error('position is out of range');\n\t\t}\n\t}\n\telse {\n\t\tswitch (position) {\n\t\tcase 'first':\n\t\t\tidx = 0;\n\t\t\tbreak;\n\t\tcase 'last':\n\t\t\tidx = Array.isArray(list) ? list.length : list.size;\n\t\t\tbreak;\n\t\tcase 'before':\n\t\t\tidx = reference === undefined ? -1 : list.indexOf(reference);\n\t\t\tif (idx === -1) {\n\t\t\t\tthrow new Error('reference not contained in this list');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'after':\n\t\t\tidx = reference === undefined ? 0 : list.indexOf(reference) + 1;\n\t\t\tif (idx === 0) {\n\t\t\t\tthrow new Error('reference not contained in this list');\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow Error(`Invalid position \"${position}\"`);\n\t\t}\n\t}\n\treturn idx;\n}\n\nexport function insertInList<T>(list: List<T>, item: T, position: Position, reference?: T): List<T> {\n\treturn list.insert(getIndex(list, item, position, reference), item);\n}\n\nexport function insertInArray<T>(array: T[], item: T, position: Position, reference?: T): T[] {\n\tarray.splice(getIndex(array, item, position, reference), 0, item);\n\treturn array;\n}\n\nfunction valueReplacer(key: string, value: any): any {\n\tif (value instanceof RegExp) {\n\t\treturn (`__RegExp(${value.toString()})`);\n\t}\n\treturn value;\n}\n\nfunction valueReviver(key: string, value: any): any {\n\tif (value.toString().indexOf('__RegExp(') === 0) {\n\t\tconst [ , regExpStr ] = value.match(/__RegExp\\(([^\\)]*)\\)/);\n\t\tconst [ , regExp, flags ] = regExpStr.match(/^\\/(.*?)\\/([gimy]*)$/);\n\t\treturn new RegExp(regExp, flags);\n\t}\n\treturn value;\n}\n\n/**\n * Internal function to convert a state value to a string\n * @param value The value to be converted\n */\nexport function valueToString(value: any): string {\n\treturn value\n\t\t? Array.isArray(value) || typeof value === 'object'\n\t\t\t? JSON.stringify(value, valueReplacer) : String(value)\n\t\t: value === 0\n\t\t\t? '0' : value === false\n\t\t\t\t? 'false' : '';\n}\n\n/**\n * Internal function to convert a string to the likely more complex value stored in\n * state\n * @param str The string to convert to a state value\n */\nexport function stringToValue(str: string): any {\n\ttry {\n\t\tconst value = JSON.parse(str, valueReviver);\n\t\treturn value;\n\t}\n\tcatch (e) {\n\t\tif (/^(\\-|\\+)?([0-9]+(\\.[0-9]+)?|Infinity)$/.test(str)) {\n\t\t\treturn Number(str);\n\t\t}\n\t\tif (str) {\n\t\t\treturn str;\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\n/**\n * A type guard that deterimines if a value is an immutable List or not\n */\nexport function isList<T>(value: any): value is List<T> {\n\treturn value instanceof List;\n}\n\n/**\n * A type guard that checks to see if the value is a Child\n * @param value the value to guard for\n */\nexport function isChild<C extends Child>(value: any): value is C {\n\treturn value && typeof value === 'object' && typeof value.render === 'function';\n}\n\n/**\n * A utility function that generates a handle that destroys any children\n * @param parent The parent that the handle relates to\n * @param child The child (or array of children) that the handle relates to\n */\nexport function getRemoveHandle<C extends Child>(parent: Parent, child: C | C[] | ChildrenMap<C>): Handle {\n\tfunction getDestroyHandle(c: C): Handle {\n\t\tlet destroyed = false;\n\t\treturn c.own({\n\t\t\tdestroy() {\n\t\t\t\tif (destroyed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst { children } = parent;\n\t\t\t\tif (children.includes(c)) {\n\t\t\t\t\tparent.children = isList(children) ? children.delete(children.lastIndexOf(c)) : children.delete(children.keyOf(c));\n\t\t\t\t}\n\t\t\t\tdestroyed = true;\n\t\t\t\tif (c.parent === parent) {\n\t\t\t\t\tc.parent = null;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tlet destroyed = false;\n\n\tif (Array.isArray(child)) {\n\t\tconst handles = child.map((c) => getDestroyHandle(c));\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tif (destroyed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thandles.forEach(({ destroy }) => destroy());\n\t\t\t\tdestroyed = true;\n\t\t\t}\n\t\t};\n\t}\n\telse if (isChild(child)) {\n\t\tconst handle = getDestroyHandle(child);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t}\n\telse {\n\t\tconst handles: Handle[] = [];\n\t\tfor (let key in child) {\n\t\t\thandles.push(getDestroyHandle(child[key]));\n\t\t}\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tif (destroyed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\thandles.forEach(({ destroy }) => destroy());\n\t\t\t\tdestroyed = true;\n\t\t\t}\n\t\t};\n\t}\n\n}\n\n\n\n// WEBPACK FOOTER //\n// src/util/lang.ts","/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Immutable = factory());\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^321.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level : 0 || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immutable/dist/immutable.js\n// module id = 36\n// module chunks = 0","export interface CancelableEvent<T extends string, U> {\n\t/**\n\t * The type of the event\n\t */\n\treadonly type: T;\n\n\t/**\n\t * The target for the event\n\t */\n\treadonly target: U;\n\n\t/**\n\t * Can the event be canceled?\n\t */\n\treadonly cancelable: boolean;\n\n\t/**\n\t * Was the event canceled?\n\t */\n\treadonly defaultPrevented: boolean;\n\n\t/**\n\t * Cancel the event\n\t */\n\tpreventDefault(): void;\n}\n\n/**\n * A simple factory that creates an event object which can be cancelled\n *\n * @param options The options for the event\n */\nfunction createCancelableEvent<T extends string, U>(options: { type: T, target: U }): CancelableEvent<T, U> {\n\tconst { type, target } = options;\n\tconst event: CancelableEvent<T, U> = Object.defineProperties({}, {\n\t\ttype: { value: type, enumerable: true },\n\t\ttarget: { value: target, enumerable: true },\n\t\tcancelable: { value: true, enumerable: true },\n\t\tdefaultPrevented: { value: false, enumerable: true, configurable: true },\n\t\tpreventDefault: { value() {\n\t\t\tObject.defineProperty(event, 'defaultPrevented', { value: true, enumerable: true });\n\t\t}, enumerable: true }\n\t});\n\n\treturn event;\n}\n\nexport default createCancelableEvent;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/util/createCancelableEvent.ts","import { Handle } from 'dojo-core/interfaces';\nimport { deepAssign } from 'dojo-core/lang';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Observable, Subscription } from './interfaces';\nimport createEvented, { Evented, EventedOptions, EventedListener, TargettedEventObject } from './createEvented';\nimport { ComposeFactory } from '../compose';\nimport createCancelableEvent, { CancelableEvent } from './../util/createCancelableEvent';\n\n/**\n * Base State interface\n */\nexport interface State {\n\t[prop: string]: any;\n}\n\nexport interface ObservableState<S extends State> {\n\t/**\n\t * A method that allows the return of an `Observable` interface for a particular `id`\n\t * @param id The ID to observe\n\t */\n\tobserve(id: string): Observable<S>;\n\n\t/**\n\t * A method that allows the `Stateful` to provide a change to its state, instead of\n\t * changing its state directly.\n\t * @param partial The partial state to be *patched*\n\t * @param options A map of options, which includes the `id` being observed\n\t */\n\tpatch(partial: any, options?: { id?: string }): Promise<S>;\n}\n\nexport interface StatefulOptions<S extends State> extends EventedOptions {\n\t/**\n\t * State that should be set during creation\n\t */\n\tstate?: S;\n\n\t/**\n\t * An ID to be used in conjunction with the `stateFrom` option to observe the state\n\t */\n\tid?: string;\n\n\t/**\n\t * An object that the Stateful should observe its state from, which supplies an `observe` and\n\t * `patch` methods to be able to manage its state\n\t */\n\tstateFrom?: ObservableState<S>;\n}\n\nexport interface StateChangeEvent<S extends State> extends TargettedEventObject {\n\t/**\n\t * The event type\n\t */\n\ttype: string;\n\n\t/**\n\t * The state of the target\n\t */\n\tstate: S;\n\n\t/**\n\t * A Stateful instance\n\t */\n\ttarget: Stateful<S>;\n}\n\nexport interface StatefulMixin<S extends State>{\n\t/**\n\t * A read only view of the state\n\t */\n\treadonly state: S;\n\n\t/**\n\t * Set the state on the instance.\n\t *\n\t * Set state can take a partial value, therefore if a key is ommitted from the value, it will not be changed.\n\t * To *clear* a value, set a key to `undefined`\n\t *\n\t * @param value The state (potentially partial) to be set\n\t */\n\tsetState(value: S): void;\n\n\t/**\n\t * Observe (and update) the state from an Observable\n\t * @param id The ID to be observed on the Observable\n\t * @param observable An object which provides a `observe` and `patch` methods which allow `Stateful` to be able to\n\t *                   manage its state.\n\t */\n\tobserveState(id: string, observable: ObservableState<S>): Handle;\n}\n\nexport type Stateful<S extends State> = StatefulMixin<S> & Evented & {\n\t/**\n\t * Add a listener for a `statecomplete` event, which occures when state is observed\n\t * and is completed.  If the event is not cancelled, the instance will continue and\n\t * call `target.destroy()`.\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener that will be called when the event occurs\n\t */\n\ton(type: 'statecomplete', listener: EventedListener<CancelableEvent<'statecomplete', Stateful<S>>>): Handle;\n\n\t/**\n\t * Add a listener for a `statechange` event, which occures whenever the state changes on the instance.\n\t *\n\t * @param type The event type to listen for\n\t * @param listener The listener that will be called when the event occurs\n\t */\n\ton(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport interface StatefulFactory extends ComposeFactory<Stateful<State>, StatefulOptions<State>> {\n\t<S extends State>(options?: StatefulOptions<S>): Stateful<S>;\n}\n\n/**\n * Internal interface which contains references to an observed state\n */\ninterface ObservedState {\n\tid: string;\n\tobservable: ObservableState<State>;\n\tsubscription: Subscription;\n\thandle: Handle;\n}\n\n/**\n * A weak map of stateful instances to their obseved state references\n */\nconst observedStateMap = new WeakMap<Stateful<State>, ObservedState>();\n\n/**\n * Internal function to unobserve the state of a `Stateful`.  It emits a `statecomplete` event which can be\n * cancelled.\n *\n * @param stateful The `Stateful` object to unobserve\n */\nfunction unobserve(stateful: Stateful<State>): void {\n\tconst observedState = observedStateMap.get(stateful);\n\tif (observedState) {\n\t\tobservedState.handle.destroy();\n\t\tconst statecomplete = createCancelableEvent({\n\t\t\ttype: 'statecomplete',\n\t\t\ttarget: stateful\n\t\t});\n\t\tstateful.emit(statecomplete);\n\t\tif (!statecomplete.defaultPrevented) {\n\t\t\tstateful.destroy();\n\t\t}\n\t}\n}\n\n/**\n * Internal function that actually applies the state to the Stateful's state and\n * emits the `statechange` event.\n *\n * @param stateful The Stateful instance\n * @param state The State to be set\n */\nfunction setStatefulState(stateful: Stateful<State>, state: State): void {\n\tstate = deepAssign(stateWeakMap.get(stateful), state);\n\tstateful.emit({\n\t\ttype: 'statechange',\n\t\tstate,\n\t\ttarget: stateful\n\t});\n}\n\n/**\n * A weak map that contains the stateful's state\n */\nconst stateWeakMap = new WeakMap<Stateful<State>, State>();\n\n/**\n * Create an instance of a stateful object\n */\nconst createStateful: StatefulFactory = createEvented\n\t.mixin({\n\t\tclassName: 'Stateful',\n\t\tmixin: {\n\t\t\tget state(this: Stateful<State>): State {\n\t\t\t\treturn stateWeakMap.get(this);\n\t\t\t},\n\n\t\t\tsetState(this: Stateful<State>, value: State): void {\n\t\t\t\tconst observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\tobservedState.observable.patch(value, { id: observedState.id });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsetStatefulState(this, value);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tobserveState(this: Stateful<State>, id: string, observable: ObservableState<State>): Handle {\n\t\t\t\tlet observedState = observedStateMap.get(this);\n\t\t\t\tif (observedState) {\n\t\t\t\t\tif (observedState.id === id && observedState.observable === observable) {\n\t\t\t\t\t\treturn observedState.handle;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`Already observing state with ID '${observedState.id}'`);\n\t\t\t\t}\n\t\t\t\tconst stateful = this;\n\t\t\t\tobservedState = {\n\t\t\t\t\tid,\n\t\t\t\t\tobservable,\n\t\t\t\t\tsubscription: observable\n\t\t\t\t\t\t.observe(id)\n\t\t\t\t\t\t.subscribe(\n\t\t\t\t\t\t\t(item) => setStatefulState(stateful, item), /* next handler */\n\t\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\t\t/* TODO: Should we emit an error, instead of throwing? */\n\t\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t\t}, /* error handler */\n\t\t\t\t\t\t\t() => unobserve(stateful)), /* completed handler */\n\t\t\t\t\thandle: {\n\t\t\t\t\t\tdestroy() {\n\t\t\t\t\t\t\tconst observedState = observedStateMap.get(stateful);\n\t\t\t\t\t\t\tif (observedState) {\n\t\t\t\t\t\t\t\tobservedState.subscription.unsubscribe();\n\t\t\t\t\t\t\t\tobservedStateMap.delete(stateful);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tobservedStateMap.set(stateful, observedState);\n\t\t\t\treturn observedState.handle;\n\t\t\t}\n\t\t},\n\t\tinitialize(instance: StatefulMixin<State> & Evented, options: StatefulOptions<State>) {\n\t\t\t/* Using Object.create(null) will improve performance when looking up properties in state */\n\t\t\tstateWeakMap.set(instance, Object.create(null));\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tstateWeakMap.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\tconst { id, stateFrom, state } = options;\n\t\t\t\tif (typeof id !== 'undefined' && stateFrom) {\n\t\t\t\t\tinstance.own(instance.observeState(id, stateFrom));\n\t\t\t\t}\n\t\t\t\telse if (stateFrom) {\n\t\t\t\t\tthrow new TypeError('When \"stateFrom\" option is supplied, factory also requires \"id\" option.');\n\t\t\t\t}\n\t\t\t\tif (state) {\n\t\t\t\t\tinstance.setState(state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createStateful;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-compose/mixins/createStateful.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport createStateful, { State, Stateful, StatefulOptions } from 'dojo-compose/mixins/createStateful';\nimport { assign } from 'dojo-core/lang';\nimport Map from 'dojo-shim/Map';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { h, VNode, VNodeProperties } from 'maquette';\nimport { Parent, RenderFunction, StylesHash } from './interfaces';\n\nexport interface RenderMixinState extends State {\n\t/**\n\t * Any classes to set at construction to the VNode\n\t */\n\tclasses?: string[];\n\n\t/**\n\t * The ID of this widget\n\t */\n\tid?: string;\n\n\t/**\n\t * Any label text for this widget\n\t */\n\tlabel?: string;\n\n\t/**\n\t * Any styles to set at startup to the VNode\n\t */\n\tstyles?: StylesHash;\n}\n\n/**\n * A function that is called when collecting the node attributes on render, accepting the current set of\n * attributes and returning a set of VNode properties that should mixed into the current attributes.\n */\nexport interface NodeAttributeFunction {\n\t(attributes: VNodeProperties): VNodeProperties;\n}\n\nexport interface Render {\n\t/**\n\t * An array of strings that represent widget classes to be applied to all widget instances. Typically classes that\n\t * represent the internal widget structure. Widget classes for all mixed in factories will be merged into a final\n\t * array that is used by `getSelectorAndWidgetClasses` to return the readonly classes during the render.\n\t */\n\treadonly classes: string[];\n\n\t/**\n\t * Returns the node attribute properties to be used by a render function\n\t *\n\t * @param overrides Any optional overrides of properties\n\t */\n\tgetNodeAttributes(overrides?: VNodeProperties): VNodeProperties;\n\n\t/**\n\t * Returns the widgets' selector and all `widgetClasses` defined, these are configured by adding classes to the\n\t * `widgetClasses` array when extending widgets.\n\t */\n\tgetSelectorAndWidgetClasses(): string;\n\n\t/**\n\t * Returns any children VNodes that are part of the widget\n\t */\n\tgetChildrenNodes(): (VNode | string)[];\n\n\t/**\n\t * The ID of the current widget\n\t */\n\treadonly id: string;\n\n\t/**\n\t * Invalidate the widget so that it will recalculate on its next render\n\t */\n\tinvalidate(): void;\n\n\t/**\n\t * An array of node attribute functions which return additional attributes that should be mixed into\n\t * the final VNode during a render call\n\t */\n\tnodeAttributes: NodeAttributeFunction[];\n\n\t/**\n\t * A reference to the widget's parent\n\t */\n\tparent: Parent | null;\n\n\t/**\n\t * Takes no arguments and returns a VNode\n\t */\n\trender(): VNode;\n\n\t/**\n\t * The tag name to be used\n\t */\n\ttagName: string;\n}\n\nexport type RenderMixin<S extends RenderMixinState> = Stateful<S> & Render;\n\nexport interface RenderMixinOptions<S extends RenderMixinState> extends StatefulOptions<S> {\n\t/**\n\t * A render function to be used.\n\t */\n\trender?: RenderFunction;\n\n\t/**\n\t * Override the widget's tagName during construction\n\t */\n\ttagName?: string;\n\n\t/**\n\t * Set the widget's parent during construction\n\t */\n\tparent?: Parent;\n}\n\nexport interface RenderMixinFactory extends ComposeFactory<RenderMixin<RenderMixinState>, RenderMixinOptions<RenderMixinState>> {\n\tidBase: string;\n}\n\n/**\n * A map of dirty flags used when determining if the render function\n * should be called\n */\nconst dirtyMap = new Map<RenderMixin<RenderMixinState>, boolean>();\n\n/**\n * A weak map of the rendered VNode to return when the widget is\n * not dirty.\n */\nconst renderCache = new WeakMap<RenderMixin<RenderMixinState>, VNode>();\n\n/**\n * The counter for generating a unique ID\n */\nlet cachedRenderCount = 0;\n\n/**\n * A function that generates an ID\n */\nfunction generateID(cachedRender: RenderMixin<RenderMixinState>): string {\n\tconst id = `${createRenderMixin.idBase}${++cachedRenderCount}`;\n\tcachedRender.setState({ id });\n\treturn id;\n}\n\n/**\n * A weak map of the historic classes associated to a specific widget\n */\nconst widgetClassesMap = new WeakMap<RenderMixin<RenderMixinState>, string[]>();\n\nconst createRenderMixin = createStateful\n\t.mixin<Render, RenderMixinOptions<RenderMixinState>>({\n\t\tmixin: {\n\t\t\tgetNodeAttributes(this: RenderMixin<RenderMixinState>, overrides?: VNodeProperties): VNodeProperties {\n\t\t\t\tconst props: VNodeProperties = {};\n\n\t\t\t\tthis.nodeAttributes.forEach((fn) => {\n\t\t\t\t\tconst newProps: VNodeProperties = fn.call(this, assign({}, props));\n\t\t\t\t\tif (newProps) {\n\t\t\t\t\t\tassign(props, newProps);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (overrides) {\n\t\t\t\t\tassign(props, overrides);\n\t\t\t\t}\n\t\t\t\treturn props;\n\t\t\t},\n\n\t\t\tgetSelectorAndWidgetClasses(this: RenderMixin<RenderMixinState>): string {\n\t\t\t\tconst selectorAndClasses = [this.tagName, ...this.classes];\n\t\t\t\treturn selectorAndClasses.join('.');\n\t\t\t},\n\n\t\t\tgetChildrenNodes(this: RenderMixin<RenderMixinState>): (VNode | string)[] {\n\t\t\t\treturn this.state.label ? [ this.state.label ] : [];\n\t\t\t},\n\n\t\t\tget id(this: RenderMixin<RenderMixinState>): string {\n\t\t\t\treturn (this.state && this.state.id) || generateID(this);\n\t\t\t},\n\n\t\t\tinvalidate(this: RenderMixin<RenderMixinState>): void {\n\t\t\t\tif (dirtyMap.get(this)) { /* short circuit if already dirty */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst parent = this.parent;\n\t\t\t\tdirtyMap.set(this, true);\n\t\t\t\trenderCache.delete(this); /* Allow GC to occur on renderCache */\n\t\t\t\tif (parent && parent.invalidate) {\n\t\t\t\t\tparent.invalidate();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tnodeAttributes: [\n\t\t\t\tfunction (this: RenderMixin<RenderMixinState>): VNodeProperties {\n\t\t\t\t\tconst baseIdProp = this.state && this.state.id ? { 'data-widget-id': this.state.id } : {};\n\t\t\t\t\tconst { styles = {} } = this.state;\n\t\t\t\t\tconst classes: { [index: string]: boolean; } = {};\n\t\t\t\t\tconst widgetClasses = widgetClassesMap.get(this);\n\n\t\t\t\t\twidgetClasses.forEach((c) => classes[c] = false);\n\n\t\t\t\t\tif (this.state && this.state.classes) {\n\t\t\t\t\t\tthis.state.classes.forEach((c) => classes[c] = true);\n\t\t\t\t\t\twidgetClassesMap.set(this, this.state.classes);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn assign(baseIdProp, { key: this, classes, styles });\n\t\t\t\t}\n\t\t\t],\n\n\t\t\tparent: null,\n\n\t\t\trender(this: RenderMixin<RenderMixinState>): VNode {\n\t\t\t\tconst cachedRender: RenderMixin<RenderMixinState> = this;\n\t\t\t\tlet cached = renderCache.get(cachedRender);\n\t\t\t\tif (!dirtyMap.get(cachedRender) && cached) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcached = h(cachedRender.getSelectorAndWidgetClasses() , cachedRender.getNodeAttributes(), cachedRender.getChildrenNodes());\n\t\t\t\t\trenderCache.set(cachedRender, cached);\n\t\t\t\t\tdirtyMap.set(cachedRender, false);\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tclasses: [],\n\n\t\t\ttagName: 'div'\n\t\t},\n\t\tinitialize(instance: RenderMixin<RenderMixinState>, options: RenderMixinOptions<RenderMixinState> = {}) {\n\t\t\tconst { tagName, render, parent } = options;\n\t\t\tinstance.tagName = tagName || instance.tagName;\n\t\t\tinstance.render = render || instance.render;\n\n\t\t\tif (parent) {\n\t\t\t\tparent.append(instance);\n\t\t\t}\n\n\t\t\tdirtyMap.set(instance, true);\n\n\t\t\tinstance.own(instance.on('statechange', () => instance.invalidate()));\n\n\t\t\twidgetClassesMap.set(instance, []);\n\t\t}\n\t})\n\t.static({\n\t\tidBase: 'widget'\n\t}) as RenderMixinFactory;\n\nexport default createRenderMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createRenderMixin.ts","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['exports'], factory);\n    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {\n        // CommonJS\n        factory(exports);\n    } else {\n        // Browser globals\n        factory(root.maquette = {});\n    }\n}(this, function (exports) {\n    'use strict';\n    ;\n    ;\n    ;\n    ;\n    var NAMESPACE_W3 = 'http://www.w3.org/';\n    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';\n    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';\n    // Utilities\n    var emptyArray = [];\n    var extend = function (base, overrides) {\n        var result = {};\n        Object.keys(base).forEach(function (key) {\n            result[key] = base[key];\n        });\n        if (overrides) {\n            Object.keys(overrides).forEach(function (key) {\n                result[key] = overrides[key];\n            });\n        }\n        return result;\n    };\n    // Hyperscript helper functions\n    var same = function (vnode1, vnode2) {\n        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {\n            return false;\n        }\n        if (vnode1.properties && vnode2.properties) {\n            if (vnode1.properties.key !== vnode2.properties.key) {\n                return false;\n            }\n            return vnode1.properties.bind === vnode2.properties.bind;\n        }\n        return !vnode1.properties && !vnode2.properties;\n    };\n    var toTextVNode = function (data) {\n        return {\n            vnodeSelector: '',\n            properties: undefined,\n            children: undefined,\n            text: data.toString(),\n            domNode: null\n        };\n    };\n    var appendChildren = function (parentSelector, insertions, main) {\n        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {\n            var item = insertions[i];\n            if (Array.isArray(item)) {\n                appendChildren(parentSelector, item, main);\n            } else {\n                if (item !== null && item !== undefined) {\n                    if (!item.hasOwnProperty('vnodeSelector')) {\n                        item = toTextVNode(item);\n                    }\n                    main.push(item);\n                }\n            }\n        }\n    };\n    // Render helper functions\n    var missingTransition = function () {\n        throw new Error('Provide a transitions object to the projectionOptions to do animations');\n    };\n    var DEFAULT_PROJECTION_OPTIONS = {\n        namespace: undefined,\n        eventHandlerInterceptor: undefined,\n        styleApplyer: function (domNode, styleName, value) {\n            // Provides a hook to add vendor prefixes for browsers that still need it.\n            domNode.style[styleName] = value;\n        },\n        transitions: {\n            enter: missingTransition,\n            exit: missingTransition\n        }\n    };\n    var applyDefaultProjectionOptions = function (projectorOptions) {\n        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);\n    };\n    var checkStyleValue = function (styleValue) {\n        if (typeof styleValue !== 'string') {\n            throw new Error('Style values must be strings');\n        }\n    };\n    var setProperties = function (domNode, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            /* tslint:disable:no-var-keyword: edge case */\n            var propValue = properties[propName];\n            /* tslint:enable:no-var-keyword */\n            if (propName === 'className') {\n                throw new Error('Property \"className\" is not supported, use \"class\".');\n            } else if (propName === 'class') {\n                propValue.split(/\\s+/).forEach(function (token) {\n                    return domNode.classList.add(token);\n                });\n            } else if (propName === 'classes') {\n                // object with string keys and boolean values\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    if (propValue[className]) {\n                        domNode.classList.add(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                // object with string keys and string (!) values\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var styleValue = propValue[styleName];\n                    if (styleValue) {\n                        checkStyleValue(styleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, styleValue);\n                    }\n                }\n            } else if (propName === 'key') {\n                continue;\n            } else if (propValue === null || propValue === undefined) {\n                continue;\n            } else {\n                var type = typeof propValue;\n                if (type === 'function') {\n                    if (propName.lastIndexOf('on', 0) === 0) {\n                        if (eventHandlerInterceptor) {\n                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers\n                        }\n                        if (propName === 'oninput') {\n                            (function () {\n                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput\n                                var oldPropValue = propValue;\n                                propValue = function (evt) {\n                                    evt.target['oninput-value'] = evt.target.value;\n                                    // may be HTMLTextAreaElement as well\n                                    oldPropValue.apply(this, [evt]);\n                                };\n                            }());\n                        }\n                        domNode[propName] = propValue;\n                    }\n                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {\n                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                    } else {\n                        domNode.setAttribute(propName, propValue);\n                    }\n                } else {\n                    domNode[propName] = propValue;\n                }\n            }\n        }\n    };\n    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {\n        if (!properties) {\n            return;\n        }\n        var propertiesUpdated = false;\n        var propNames = Object.keys(properties);\n        var propCount = propNames.length;\n        for (var i = 0; i < propCount; i++) {\n            var propName = propNames[i];\n            // assuming that properties will be nullified instead of missing is by design\n            var propValue = properties[propName];\n            var previousValue = previousProperties[propName];\n            if (propName === 'class') {\n                if (previousValue !== propValue) {\n                    throw new Error('\"class\" property may not be updated. Use the \"classes\" property for conditional css classes.');\n                }\n            } else if (propName === 'classes') {\n                var classList = domNode.classList;\n                var classNames = Object.keys(propValue);\n                var classNameCount = classNames.length;\n                for (var j = 0; j < classNameCount; j++) {\n                    var className = classNames[j];\n                    var on = !!propValue[className];\n                    var previousOn = !!previousValue[className];\n                    if (on === previousOn) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (on) {\n                        classList.add(className);\n                    } else {\n                        classList.remove(className);\n                    }\n                }\n            } else if (propName === 'styles') {\n                var styleNames = Object.keys(propValue);\n                var styleCount = styleNames.length;\n                for (var j = 0; j < styleCount; j++) {\n                    var styleName = styleNames[j];\n                    var newStyleValue = propValue[styleName];\n                    var oldStyleValue = previousValue[styleName];\n                    if (newStyleValue === oldStyleValue) {\n                        continue;\n                    }\n                    propertiesUpdated = true;\n                    if (newStyleValue) {\n                        checkStyleValue(newStyleValue);\n                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);\n                    } else {\n                        projectionOptions.styleApplyer(domNode, styleName, '');\n                    }\n                }\n            } else {\n                if (!propValue && typeof previousValue === 'string') {\n                    propValue = '';\n                }\n                if (propName === 'value') {\n                    if (domNode[propName] !== propValue && domNode['oninput-value'] !== propValue) {\n                        domNode[propName] = propValue;\n                        // Reset the value, even if the virtual DOM did not change\n                        domNode['oninput-value'] = undefined;\n                    }\n                    // else do not update the domNode, otherwise the cursor position would be changed\n                    if (propValue !== previousValue) {\n                        propertiesUpdated = true;\n                    }\n                } else if (propValue !== previousValue) {\n                    var type = typeof propValue;\n                    if (type === 'function') {\n                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');\n                    }\n                    if (type === 'string' && propName !== 'innerHTML') {\n                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {\n                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);\n                        } else {\n                            domNode.setAttribute(propName, propValue);\n                        }\n                    } else {\n                        if (domNode[propName] !== propValue) {\n                            domNode[propName] = propValue;\n                        }\n                    }\n                    propertiesUpdated = true;\n                }\n            }\n        }\n        return propertiesUpdated;\n    };\n    var findIndexOfChild = function (children, sameAs, start) {\n        if (sameAs.vnodeSelector !== '') {\n            // Never scan for text-nodes\n            for (var i = start; i < children.length; i++) {\n                if (same(children[i], sameAs)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    var nodeAdded = function (vNode, transitions) {\n        if (vNode.properties) {\n            var enterAnimation = vNode.properties.enterAnimation;\n            if (enterAnimation) {\n                if (typeof enterAnimation === 'function') {\n                    enterAnimation(vNode.domNode, vNode.properties);\n                } else {\n                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);\n                }\n            }\n        }\n    };\n    var nodeToRemove = function (vNode, transitions) {\n        var domNode = vNode.domNode;\n        if (vNode.properties) {\n            var exitAnimation = vNode.properties.exitAnimation;\n            if (exitAnimation) {\n                domNode.style.pointerEvents = 'none';\n                var removeDomNode = function () {\n                    if (domNode.parentNode) {\n                        domNode.parentNode.removeChild(domNode);\n                    }\n                };\n                if (typeof exitAnimation === 'function') {\n                    exitAnimation(domNode, removeDomNode, vNode.properties);\n                    return;\n                } else {\n                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);\n                    return;\n                }\n            }\n        }\n        if (domNode.parentNode) {\n            domNode.parentNode.removeChild(domNode);\n        }\n    };\n    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {\n        var childNode = childNodes[indexToCheck];\n        if (childNode.vnodeSelector === '') {\n            return;    // Text nodes need not be distinguishable\n        }\n        var properties = childNode.properties;\n        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;\n        if (!key) {\n            for (var i = 0; i < childNodes.length; i++) {\n                if (i !== indexToCheck) {\n                    var node = childNodes[i];\n                    if (same(node, childNode)) {\n                        if (operation === 'added') {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');\n                        } else {\n                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');\n                        }\n                    }\n                }\n            }\n        }\n    };\n    var createDom;\n    var updateDom;\n    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {\n        if (oldChildren === newChildren) {\n            return false;\n        }\n        oldChildren = oldChildren || emptyArray;\n        newChildren = newChildren || emptyArray;\n        var oldChildrenLength = oldChildren.length;\n        var newChildrenLength = newChildren.length;\n        var transitions = projectionOptions.transitions;\n        var oldIndex = 0;\n        var newIndex = 0;\n        var i;\n        var textUpdated = false;\n        while (newIndex < newChildrenLength) {\n            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;\n            var newChild = newChildren[newIndex];\n            if (oldChild !== undefined && same(oldChild, newChild)) {\n                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;\n                oldIndex++;\n            } else {\n                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);\n                if (findOldIndex >= 0) {\n                    // Remove preceding missing children\n                    for (i = oldIndex; i < findOldIndex; i++) {\n                        nodeToRemove(oldChildren[i], transitions);\n                        checkDistinguishable(oldChildren, i, vnode, 'removed');\n                    }\n                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;\n                    oldIndex = findOldIndex + 1;\n                } else {\n                    // New child\n                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);\n                    nodeAdded(newChild, transitions);\n                    checkDistinguishable(newChildren, newIndex, vnode, 'added');\n                }\n            }\n            newIndex++;\n        }\n        if (oldChildrenLength > oldIndex) {\n            // Remove child fragments\n            for (i = oldIndex; i < oldChildrenLength; i++) {\n                nodeToRemove(oldChildren[i], transitions);\n                checkDistinguishable(oldChildren, i, vnode, 'removed');\n            }\n        }\n        return textUpdated;\n    };\n    var addChildren = function (domNode, children, projectionOptions) {\n        if (!children) {\n            return;\n        }\n        for (var i = 0; i < children.length; i++) {\n            createDom(children[i], domNode, undefined, projectionOptions);\n        }\n    };\n    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {\n        addChildren(domNode, vnode.children, projectionOptions);\n        // children before properties, needed for value property of <select>.\n        if (vnode.text) {\n            domNode.textContent = vnode.text;\n        }\n        setProperties(domNode, vnode.properties, projectionOptions);\n        if (vnode.properties && vnode.properties.afterCreate) {\n            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [\n                domNode,\n                projectionOptions,\n                vnode.vnodeSelector,\n                vnode.properties,\n                vnode.children\n            ]);\n        }\n    };\n    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {\n        var domNode, i, c, start = 0, type, found;\n        var vnodeSelector = vnode.vnodeSelector;\n        if (vnodeSelector === '') {\n            domNode = vnode.domNode = document.createTextNode(vnode.text);\n            if (insertBefore !== undefined) {\n                parentNode.insertBefore(domNode, insertBefore);\n            } else {\n                parentNode.appendChild(domNode);\n            }\n        } else {\n            for (i = 0; i <= vnodeSelector.length; ++i) {\n                c = vnodeSelector.charAt(i);\n                if (i === vnodeSelector.length || c === '.' || c === '#') {\n                    type = vnodeSelector.charAt(start - 1);\n                    found = vnodeSelector.slice(start, i);\n                    if (type === '.') {\n                        domNode.classList.add(found);\n                    } else if (type === '#') {\n                        domNode.id = found;\n                    } else {\n                        if (found === 'svg') {\n                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n                        }\n                        if (projectionOptions.namespace !== undefined) {\n                            domNode = vnode.domNode = document.createElementNS(projectionOptions.namespace, found);\n                        } else {\n                            domNode = vnode.domNode = document.createElement(found);\n                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {\n                                // IE8 and older don't support setting input type after the DOM Node has been added to the document\n                                domNode.setAttribute('type', vnode.properties.type);\n                            }\n                        }\n                        if (insertBefore !== undefined) {\n                            parentNode.insertBefore(domNode, insertBefore);\n                        } else {\n                            parentNode.appendChild(domNode);\n                        }\n                    }\n                    start = i + 1;\n                }\n            }\n            initPropertiesAndChildren(domNode, vnode, projectionOptions);\n        }\n    };\n    updateDom = function (previous, vnode, projectionOptions) {\n        var domNode = previous.domNode;\n        var textUpdated = false;\n        if (previous === vnode) {\n            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette\n        }\n        var updated = false;\n        if (vnode.vnodeSelector === '') {\n            if (vnode.text !== previous.text) {\n                var newVNode = document.createTextNode(vnode.text);\n                domNode.parentNode.replaceChild(newVNode, domNode);\n                vnode.domNode = newVNode;\n                textUpdated = true;\n                return textUpdated;\n            }\n        } else {\n            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {\n                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });\n            }\n            if (previous.text !== vnode.text) {\n                updated = true;\n                if (vnode.text === undefined) {\n                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably\n                } else {\n                    domNode.textContent = vnode.text;\n                }\n            }\n            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;\n            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;\n            if (vnode.properties && vnode.properties.afterUpdate) {\n                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [\n                    domNode,\n                    projectionOptions,\n                    vnode.vnodeSelector,\n                    vnode.properties,\n                    vnode.children\n                ]);\n            }\n        }\n        if (updated && vnode.properties && vnode.properties.updateAnimation) {\n            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);\n        }\n        vnode.domNode = previous.domNode;\n        return textUpdated;\n    };\n    var createProjection = function (vnode, projectionOptions) {\n        return {\n            update: function (updatedVnode) {\n                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {\n                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');\n                }\n                updateDom(vnode, updatedVnode, projectionOptions);\n                vnode = updatedVnode;\n            },\n            domNode: vnode.domNode\n        };\n    };\n    ;\n    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.\n    exports.h = function (selector) {\n        var properties = arguments[1];\n        if (typeof selector !== 'string') {\n            throw new Error();\n        }\n        var childIndex = 1;\n        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {\n            childIndex = 2;\n        } else {\n            // Optional properties argument was omitted\n            properties = undefined;\n        }\n        var text = undefined;\n        var children = undefined;\n        var argsLength = arguments.length;\n        // Recognize a common special case where there is only a single text node\n        if (argsLength === childIndex + 1) {\n            var onlyChild = arguments[childIndex];\n            if (typeof onlyChild === 'string') {\n                text = onlyChild;\n            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {\n                text = onlyChild[0];\n            }\n        }\n        if (text === undefined) {\n            children = [];\n            for (; childIndex < argsLength; childIndex++) {\n                var child = arguments[childIndex];\n                if (child === null || child === undefined) {\n                    continue;\n                } else if (Array.isArray(child)) {\n                    appendChildren(selector, child, children);\n                } else if (child.hasOwnProperty('vnodeSelector')) {\n                    children.push(child);\n                } else {\n                    children.push(toTextVNode(child));\n                }\n            }\n        }\n        return {\n            vnodeSelector: selector,\n            properties: properties,\n            children: children,\n            text: text === '' ? undefined : text,\n            domNode: null\n        };\n    };\n    /**\n * Contains simple low-level utility functions to manipulate the real DOM.\n */\n    exports.dom = {\n        /**\n     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in\n     * its [[Projection.domNode|domNode]] property.\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection.\n     * @returns The [[Projection]] which also contains the DOM Node that was created.\n     */\n        create: function (vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, document.createElement('div'), undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Appends a new childnode to the DOM which is generated from a [[VNode]].\n     * This is a low-level method. Users will typically use a [[Projector]] instead.\n     * @param parentNode - The parent node for the new childNode.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]\n     * objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the [[Projection]].\n     * @returns The [[Projection]] that was created.\n     */\n        append: function (parentNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, parentNode, undefined, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Inserts a new DOM node which is generated from a [[VNode]].\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param beforeNode - The node that the DOM Node is inserted before.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.\n     * NOTE: [[VNode]] objects may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        insertBefore: function (beforeNode, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        },\n        /**\n     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.\n     * This means that the virtual DOM and the real DOM will have one overlapping element.\n     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.\n     * This is a low-level method. Users wil typically use a [[Projector]] instead.\n     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and childnodes are preserved.\n     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects\n     * may only be rendered once.\n     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].\n     * @returns The [[Projection]] that was created.\n     */\n        merge: function (element, vnode, projectionOptions) {\n            projectionOptions = applyDefaultProjectionOptions(projectionOptions);\n            vnode.domNode = element;\n            initPropertiesAndChildren(element, vnode, projectionOptions);\n            return createProjection(vnode, projectionOptions);\n        }\n    };\n    /**\n * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.\n * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.\n * For more information, see [[CalculationCache]].\n *\n * @param <Result> The type of the value that is cached.\n */\n    exports.createCache = function () {\n        var cachedInputs = undefined;\n        var cachedOutcome = undefined;\n        var result = {\n            invalidate: function () {\n                cachedOutcome = undefined;\n                cachedInputs = undefined;\n            },\n            result: function (inputs, calculation) {\n                if (cachedInputs) {\n                    for (var i = 0; i < inputs.length; i++) {\n                        if (cachedInputs[i] !== inputs[i]) {\n                            cachedOutcome = undefined;\n                        }\n                    }\n                }\n                if (!cachedOutcome) {\n                    cachedOutcome = calculation();\n                    cachedInputs = inputs;\n                }\n                return cachedOutcome;\n            }\n        };\n        return result;\n    };\n    /**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[Component]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\n    exports.createMapping = function (getSourceKey, createResult, updateResult) {\n        var keys = [];\n        var results = [];\n        return {\n            results: results,\n            map: function (newSources) {\n                var newKeys = newSources.map(getSourceKey);\n                var oldTargets = results.slice();\n                var oldIndex = 0;\n                for (var i = 0; i < newSources.length; i++) {\n                    var source = newSources[i];\n                    var sourceKey = newKeys[i];\n                    if (sourceKey === keys[oldIndex]) {\n                        results[i] = oldTargets[oldIndex];\n                        updateResult(source, oldTargets[oldIndex], i);\n                        oldIndex++;\n                    } else {\n                        var found = false;\n                        for (var j = 1; j < keys.length + 1; j++) {\n                            var searchIndex = (oldIndex + j) % keys.length;\n                            if (keys[searchIndex] === sourceKey) {\n                                results[i] = oldTargets[searchIndex];\n                                updateResult(newSources[i], oldTargets[searchIndex], i);\n                                oldIndex = searchIndex + 1;\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (!found) {\n                            results[i] = createResult(source, i);\n                        }\n                    }\n                }\n                results.length = newSources.length;\n                keys = newKeys;\n            }\n        };\n    };\n    /**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectionOptions   Options that influence how the DOM is rendered and updated.\n */\n    exports.createProjector = function (projectorOptions) {\n        var projector;\n        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {\n            return function () {\n                // intercept function calls (event handlers) to do a render afterwards.\n                projector.scheduleRender();\n                return eventHandler.apply(properties.bind || this, arguments);\n            };\n        };\n        var renderCompleted = true;\n        var scheduled;\n        var stopped = false;\n        var projections = [];\n        var renderFunctions = [];\n        // matches the projections array\n        var doRender = function () {\n            scheduled = undefined;\n            if (!renderCompleted) {\n                return;    // The last render threw an error, it should be logged in the browser console.\n            }\n            renderCompleted = false;\n            for (var i = 0; i < projections.length; i++) {\n                var updatedVnode = renderFunctions[i]();\n                projections[i].update(updatedVnode);\n            }\n            renderCompleted = true;\n        };\n        projector = {\n            renderNow: doRender,\n            scheduleRender: function () {\n                if (!scheduled && !stopped) {\n                    scheduled = requestAnimationFrame(doRender);\n                }\n            },\n            stop: function () {\n                if (scheduled) {\n                    cancelAnimationFrame(scheduled);\n                    scheduled = undefined;\n                }\n                stopped = true;\n            },\n            resume: function () {\n                stopped = false;\n                renderCompleted = true;\n                projector.scheduleRender();\n            },\n            append: function (parentNode, renderMaquetteFunction) {\n                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            insertBefore: function (beforeNode, renderMaquetteFunction) {\n                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            merge: function (domNode, renderMaquetteFunction) {\n                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            replace: function (domNode, renderMaquetteFunction) {\n                var vnode = renderMaquetteFunction();\n                createDom(vnode, domNode.parentNode, domNode, projectionOptions);\n                domNode.parentNode.removeChild(domNode);\n                projections.push(createProjection(vnode, projectionOptions));\n                renderFunctions.push(renderMaquetteFunction);\n            },\n            detach: function (renderMaquetteFunction) {\n                for (var i = 0; i < renderFunctions.length; i++) {\n                    if (renderFunctions[i] === renderMaquetteFunction) {\n                        renderFunctions.splice(i, 1);\n                        return projections.splice(i, 1)[0];\n                    }\n                }\n                throw new Error('renderMaquetteFunction was not found');\n            }\n        };\n        return projector;\n    };\n}));\n//# sourceMappingURL=maquette.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/maquette/dist/maquette.js\n// module id = 40\n// module chunks = 0","import createAction from 'dojo-actions/createAction';\nimport { assign } from 'dojo-core/lang';\n\nimport { Item } from '../stores/todoStore';\nimport widgetStore from '../stores/widgetStore';\nimport {\n\taddTodo,\n\tdeleteCompleted,\n\tdeleteTodo,\n\ttoggleAll,\n\tupdateTodo\n} from './todoStoreActions';\n\ninterface FormEvent extends Event {\n\ttarget: HTMLInputElement;\n}\n\ninterface FormInputEvent extends KeyboardEvent {\n\ttarget: HTMLInputElement;\n}\n\nexport const todoInput = createAction({\n\tdo({\n\t\tevent: {\n\t\t\tkeyCode,\n\t\t\ttarget: { value: label }\n\t\t}\n\t}: { event: FormInputEvent }) {\n\t\tif (keyCode === 13 && label) {\n\t\t\taddTodo.do({ label, completed: false });\n\t\t\treturn widgetStore.patch({ id: 'new-todo', value: '' });\n\t\t}\n\t}\n});\n\nexport const todoEdit = createAction({\n\tdo(options: any) {\n\t\treturn widgetStore.patch(assign(options, { editing: true }));\n\t}\n});\n\nexport const todoEditInput = createAction({\n\tdo(options: { event: FormInputEvent, state: any }) {\n\t\tconst { event: { keyCode } } = options;\n\t\tif (keyCode === 13) {\n\t\t\treturn todoSave.do(options);\n\t\t}\n\t\telse if (keyCode === 27) {\n\t\t\treturn widgetStore.patch(assign(options.state, { editing: false }));\n\t\t}\n\t}\n});\n\nexport const todoSave = createAction({\n\tdo({\n\t\tevent: {\n\t\t\ttarget: { value: label }\n\t\t},\n\t\tstate\n\t}: { event: FormInputEvent, state: any }) {\n\t\tif (!label) {\n\t\t\treturn deleteTodo.do(state);\n\t\t}\n\t\telse {\n\t\t\treturn updateTodo.do(assign(state, { label, editing: false }));\n\t\t}\n\t}\n});\n\nexport const todoRemove = createAction({\n\tdo(item: Item) {\n\t\treturn deleteTodo.do(item);\n\t}\n});\n\nexport const todoToggleComplete = createAction({\n\tdo(item: Item) {\n\t\titem = assign({}, <any> item, { completed: !item.completed });\n\t\treturn updateTodo.do(item);\n\t}\n});\n\nexport const filter = createAction({\n\tdo({ filter: activeFilter }: {filter: string}) {\n\t\treturn Promise.all([\n\t\t\twidgetStore.patch({ id: 'todo-footer', activeFilter }),\n\t\t\twidgetStore.patch({ id: 'todo-list', activeFilter })\n\t\t]);\n\t}\n});\n\nexport const todoToggleAll = createAction({\n\tdo({\n\t\tevent: {\n\t\t\ttarget: { checked }\n\t\t}\n\t}: { event: FormEvent }) {\n\t\ttoggleAll.do({ checked });\n\t}\n});\n\nexport const clearCompleted = createAction({\n\tdo() {\n\t\treturn deleteCompleted.do();\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/userActions.ts","import createAction from 'dojo-actions/createAction';\nimport Promise from 'dojo-shim/Promise';\n\nimport todoStore, { Item } from '../stores/todoStore';\n\nexport const addTodo = createAction({\n\tdo({ label }: { label: string }) {\n\t\treturn todoStore.add({ id: `${Date.now()}`, label });\n\t}\n});\n\nexport const deleteTodo = createAction({\n\tdo({ id }: { id: string }) {\n\t\treturn todoStore.delete(id);\n\t}\n});\n\nexport const deleteCompleted = createAction({\n\tdo() {\n\t\treturn todoStore.get()\n\t\t\t// <any> hammer since the store isn't typed to return an iterator (which it does).\n\t\t\t.then((items: any) => {\n\t\t\t\tconst promises = Array.from<Item>(items)\n\t\t\t\t\t.filter(({ completed }) => completed)\n\t\t\t\t\t.map(({ id }) => todoStore.delete(id));\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t}\n});\n\nexport const toggleAll = createAction({\n\tdo({ checked: completed }: { checked: boolean }) {\n\t\treturn todoStore.get()\n\t\t\t// <any> hammer since the store isn't typed to return an iterator (which it does).\n\t\t\t.then((items: any) => {\n\t\t\t\tconst promises = Array.from<Item>(items)\n\t\t\t\t\t.map(({ id }) => todoStore.patch({ completed }, { id }));\n\t\t\t\treturn Promise.all(promises);\n\t\t\t});\n\t}\n});\n\nexport const updateTodo = createAction({\n\tdo(item: Item) {\n\t\treturn todoStore.patch(item);\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/todoStoreActions.ts","import createMemoryStore, { MemoryStore } from 'dojo-stores/createMemoryStore';\n\nimport { updateHeaderAndFooter, deleteTodo, putTodo } from '../actions/widgetStoreActions';\n\nexport interface Item {\n\tid: string;\n\tlabel: string;\n\tcompleted?: boolean;\n}\n\nexport type Store = MemoryStore<Item>;\n\n// FIXME: The ChangeRecord from createMemoryStore should define these properties.\nexport interface ChangeRecord {\n\tbeforeAll: Item[];\n\tafterAll: Item[];\n\tdeletes: string[];\n\tputs: Item[];\n}\n\nconst todoStore: Store = createMemoryStore<Item>({\n\tdata: []\n});\n\nexport default todoStore;\n\n// FIXME: Would be great if the app could trigger a callback like this.\nexport function bindActions() {\n\treturn todoStore\n\t\t.observe()\n\t\t.subscribe((options: any) => {\n\t\t\tconst changeRecord = <ChangeRecord> options;\n\t\t\tupdateHeaderAndFooter.do(changeRecord);\n\n\t\t\tconst { puts, deletes } = changeRecord;\n\t\t\tif (deletes.length) {\n\t\t\t\tdeleteTodo.do(changeRecord);\n\t\t\t}\n\t\t\tif (puts.length) {\n\t\t\t\tputTodo.do(changeRecord);\n\t\t\t}\n\t\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/todoStore.ts","import { OrderedMap, Map } from 'immutable';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\nimport { assign } from 'dojo-core/lang';\nimport { Thenable } from 'dojo-interfaces/shim';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createDestroyable, { Destroyable } from 'dojo-compose/mixins/createDestroyable';\n\nexport type StoreIndex = number | string;\n\nexport interface MemoryStorePragma {\n\t/**\n\t * The identity of the object\n\t */\n\tid?: StoreIndex;\n\n\t/**\n\t * Should the item be replaced if already exists.\n\t */\n\treplace?: boolean;\n}\n\nexport interface MemoryStorePromise<T> extends Promise<T> {\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\n\tget(): MemoryStorePromise<Iterator<T>>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\nexport interface MemoryStoreOptions<T extends Object> {\n\t/**\n\t * Any initial data that should populate the store\n\t */\n\tdata?: T[];\n\n\t/**\n\t * The property of each object to use as the identity for the object\n\t */\n\tidProperty?: StoreIndex;\n}\n\nexport const enum ChangeTypes {\n\tAdd = 1,\n\tPut,\n\tPatch,\n\tDelete\n}\n\nexport interface ChangeRecord<T extends Object> {\n\ttype: ChangeTypes;\n\tid: StoreIndex;\n\ttarget?: T;\n}\n\nexport interface MemoryStoreMixin<T extends Object> {\n\t/**\n\t * The property that determines the ID of the object (defaults to `id`)\n\t */\n\tidProperty: StoreIndex;\n\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\tget(): MemoryStorePromise<T>;\n\n\t/**\n\t * Observe an object, any subsequent changes to the object can also be observed via the observable\n\t * interface that is returned.  If the object is not present in the store, the observation will be\n\t * immediatly completed.  If the object is deleted from the store, the observation will be completed\n\t * @param id The ID of the object to observe\n\t */\n\tobserve(id: StoreIndex): Observable<T>;\n\tobserve(): Observable<ChangeRecord<T>>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\nexport type MemoryStore<T extends Object> = MemoryStoreMixin<T> & Destroyable;\n\n/**\n * The weak map that contains the data for the stores\n */\nconst dataWeakMap = new WeakMap<MemoryStore<Object>, OrderedMap<StoreIndex, Object>>();\n\n/**\n * The weak map that contains any observers for the stores\n */\nconst itemObserverWeakMap = new WeakMap<MemoryStore<Object>, Map<StoreIndex, Observer<Object>[]>>();\n\n/**\n *\n */\nconst storeObserverWeakMap = new WeakMap<MemoryStore<Object>, Observer<Object>[]>();\n\n// const storeObserverWeakMap = new WeakMap<MemoryStore<Object>, Observer<ChangeRecord<Object>>[]>();\n\nexport interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {\n\t<T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;\n\n\t/**\n\t * Creates a memory store from an array of objects\n\t * @params data The array of data to create the memory store from\n\t */\n\tfromArray<T extends Object>(data: T[]): MemoryStore<T>;\n}\n\n/**\n * The methods to decorate the MemoryStorePromise with\n */\nconst storeMethods = [ 'get', 'put', 'add', 'patch', 'delete', 'fromArray' ];\n\n/**\n\t* Returns true if a given value has a `then` method.\n\t* @param {any} value The value to check if is Thenable\n\t* @returns {is Thenable<T>} A type guard if the value is thenable\n\t*/\nfunction isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\n/**\n * Utility function that takes a result and generates a MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created\n */\nfunction wrapResult<R>(store: MemoryStore<Object>, result: R): MemoryStorePromise<R> {\n\t/* TODO: this all seems pretty expensive, there has to be a better way */\n\tconst p = (isThenable(result) ? result : Promise.resolve(result)) as MemoryStorePromise<R>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Utility function that takes an error and generates a rejected MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap\n */\nfunction wrapError(store: MemoryStore<Object>, result: Error): MemoryStorePromise<Object> {\n\tconst p = (isThenable(result) ? result : Promise.reject(result)) as MemoryStorePromise<Object>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Create a new instance of a MemoryStore\n */\nconst createMemoryStore = compose<MemoryStoreMixin<Object>, MemoryStoreOptions<Object>>({\n\t\tidProperty: 'id',\n\n\t\tget(this: MemoryStore<Object>, id?: StoreIndex): MemoryStorePromise<Object | Iterator<Object>> {\n\t\t\tconst data = dataWeakMap.get(this);\n\t\t\tif (id) {\n\t\t\t\treturn wrapResult(this, data && data.get(String(id)));\n\t\t\t} else {\n\t\t\t\treturn wrapResult(this, data.values());\n\t\t\t}\n\t\t},\n\n\t\tobserve<T>(this: MemoryStore<Object>, id?: StoreIndex): Observable<T> {\n\t\t\tconst store = this;\n\t\t\tif (id) {\n\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\tstore.get(String(id)).then((item: T) => {\n\t\t\t\t\t\tif (item) {\n\t\t\t\t\t\t\tobserver.next(item);\n\t\t\t\t\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\t\t\t\t\tconst observerArray: Observer<Object>[] = observers && observers.has(String(id)) ? observers.get(String(id)) : [];\n\t\t\t\t\t\t\tobserverArray.push(observer);\n\t\t\t\t\t\t\titemObserverWeakMap.set(store, (observers ? observers : Map<StoreIndex, Observer<Object>[]>()).set(String(id), observerArray));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tobserver.error(new Error(`ID \"${id}\" not found in store`));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new Observable<T>(function subscribe(observer: Observer<T>) {\n\t\t\t\t\tconst data = dataWeakMap.get(store);\n\t\t\t\t\tconst observers = storeObserverWeakMap.get(store) || [];\n\t\t\t\t\tconst values: any = data.values();\n\t\t\t\t\tconst items = Array.from(values);\n\t\t\t\t\tconst payload: any = {\n\t\t\t\t\t\tputs: items,\n\t\t\t\t\t\tdeletes: [],\n\t\t\t\t\t\tbeforeAll: [],\n\t\t\t\t\t\tafterAll: items\n\t\t\t\t\t};\n\t\t\t\t\tobserver.next(payload);\n\t\t\t\t\tobservers.push(observer);\n\t\t\t\t\tstoreObserverWeakMap.set(store, observers);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tput(this: MemoryStore<Object>, item: { [property: string]: number | string | undefined; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\tconst store = this;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\tconst beforeAll: any = data ? data.values() : [];\n\t\t\tconst idProperty: any = store.idProperty;\n\t\t\tconst id =  options && 'id' in options ? options.id :\n\t\t\t\tidProperty in item ? item[idProperty] :\n\t\t\t\tdata ? data.size : 0;\n\t\t\tif (options && options.replace === false && data && data.has(String(id))) {\n\t\t\t\treturn wrapError(store, Error(`Duplicate ID \"${id}\" when pragma \"replace\" is false`));\n\t\t\t}\n\t\t\titem[idProperty] = id;\n\t\t\tdataWeakMap.set(store, (data ? data : OrderedMap<StoreIndex, Object>()).set(String(id), item));\n\n\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.next(item));\n\t\t\t}\n\t\t\tconst storeObservers = storeObserverWeakMap.get(store);\n\t\t\tif (storeObservers) {\n\t\t\t\tconst afterData = dataWeakMap.get(store);\n\t\t\t\tconst afterAll: any = afterData.values();\n\t\t\t\tconst payload: any = {\n\t\t\t\t\tputs: [item],\n\t\t\t\t\tdeletes: [],\n\t\t\t\t\tbeforeAll: Array.from(beforeAll),\n\t\t\t\t\tafterAll: Array.from(afterAll)\n\t\t\t\t};\n\t\t\t\tstoreObservers.forEach((observer) => {\n\t\t\t\t\tobserver.next(payload);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn wrapResult(store, item);\n\t\t},\n\n\t\tadd(this: MemoryStore<Object>, item: Object, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\treturn this.put(item, assign(options ? options : {}, { replace: false }));\n\t\t},\n\n\t\tpatch(this: MemoryStore<Object>, partial: { [property: string]: number | string; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\t\tconst idProperty = this.idProperty;\n\t\t\tconst id = options && 'id' in options ? options.id : partial[idProperty];\n\t\t\tif (!id) {\n\t\t\t\treturn wrapError(this, new Error(`Object ID must either be passed in \"partial.${idProperty}\" or \"options.id\"`));\n\t\t\t}\n\t\t\treturn wrapResult(this, this.get(id).then((item: Object = {}) => {\n\t\t\t\toptions = options || {};\n\t\t\t\toptions.id = id;\n\t\t\t\treturn this.put(assign(item, partial), options);\n\t\t\t}));\n\t\t},\n\n\t\tdelete(this: MemoryStore<Object>, item: StoreIndex | { [property: string]: number | string; }): MemoryStorePromise<boolean> {\n\t\t\tconst store = this;\n\t\t\tconst idProperty = store.idProperty;\n\t\t\tconst data = dataWeakMap.get(store);\n\t\t\tconst beforeAll: any = data ? data.values() : [];\n\n\t\t\t/**\n\t\t\t * Complete any observers associated with this items id\n\t\t\t */\n\t\t\tfunction completeObservable(id: StoreIndex) {\n\t\t\t\tconst observers = itemObserverWeakMap.get(store);\n\t\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.complete());\n\t\t\t\t\titemObserverWeakMap.set(store, observers.delete(id));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction completeStoreObservers() {\n\t\t\t\tconst storeObservers = storeObserverWeakMap.get(store);\n\t\t\t\tif (storeObservers) {\n\t\t\t\t\tconst afterData = dataWeakMap.get(store);\n\t\t\t\t\tconst afterAll: any = afterData.values();\n\t\t\t\t\tconst payload: any = {\n\t\t\t\t\t\tputs: [],\n\t\t\t\t\t\tdeletes: [item],\n\t\t\t\t\t\tbeforeAll: Array.from(beforeAll),\n\t\t\t\t\t\tafterAll: Array.from(afterAll)\n\t\t\t\t\t};\n\t\t\t\t\tstoreObservers.forEach((observer) => {\n\t\t\t\t\t\tobserver.next(payload);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (typeof item === 'object') {\n\t\t\t\tif (idProperty in item && data && data.has(String(item[idProperty]))) {\n\t\t\t\t\tdataWeakMap.set(store, data.delete(String(item[idProperty])));\n\t\t\t\t\tcompleteObservable(item[idProperty]);\n\t\t\t\t\tcompleteStoreObservers();\n\t\t\t\t\treturn wrapResult(store, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (data && data.has(String(item))) {\n\t\t\t\t\tdataWeakMap.set(store, data.delete(String(item)));\n\t\t\t\t\tcompleteObservable(item);\n\t\t\t\t\tcompleteStoreObservers();\n\t\t\t\t\treturn wrapResult(store, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn wrapResult(store, false);\n\t\t},\n\t\tfromArray(this: MemoryStore<Object>, items: Object[]): MemoryStorePromise<void> {\n\t\t\tconst store: MemoryStore<Object> = this;\n\t\t\tconst map: Object = {};\n\t\t\tconst idProperty = store.idProperty;\n\t\t\titems.forEach((item: { [prop: string]: StoreIndex }, idx: number) => {\n\t\t\t\tconst id = idProperty in item ? item[idProperty] : idx;\n\t\t\t\titem[idProperty] = id;\n\t\t\t\t(<any> map)[id] = item;\n\t\t\t});\n\t\t\tdataWeakMap.set(store, OrderedMap<StoreIndex, Object>(map));\n\t\t\treturn wrapResult(store, undefined);\n\t\t}\n\t}, (instance, options) => {\n\t\tif (options) {\n\t\t\tif (options.idProperty) {\n\t\t\t\tinstance.idProperty = options.idProperty;\n\t\t\t}\n\t\t\tif (options.data) {\n\t\t\t\tinstance.fromArray(options.data);\n\t\t\t}\n\t\t}\n\t})\n\t.mixin(createDestroyable)\n\t.static({\n\t\tfromArray(data: any[]): MemoryStore<any> {\n\t\t\treturn createMemoryStore({ data });\n\t\t}\n\t}) as MemoryStoreFactory;\n\nexport default createMemoryStore;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-stores/createMemoryStore.ts","define([\"require\", \"exports\", './util/root', './symbol/observable', './util/toSubscriber'], function (require, exports, root_1, observable_1, toSubscriber_1) {\n    \"use strict\";\n    /**\n     * A representation of any set of values over any amount of time. This the most basic building block\n     * of RxJS.\n     *\n     * @class Observable<T>\n     */\n    var Observable = (function () {\n        /**\n         * @constructor\n         * @param {Function} subscribe the function that is  called when the Observable is\n         * initially subscribed to. This function is given a Subscriber, to which new values\n         * can be `next`ed, or an `error` method can be called to raise an error, or\n         * `complete` can be called to notify of a successful completion.\n         */\n        function Observable(subscribe) {\n            this._isScalar = false;\n            if (subscribe) {\n                this._subscribe = subscribe;\n            }\n        }\n        /**\n         * Creates a new Observable, with this Observable as the source, and the passed\n         * operator defined as the new observable's operator.\n         * @method lift\n         * @param {Operator} operator the operator defining the operation to take on the observable\n         * @return {Observable} a new observable with the Operator applied\n         */\n        Observable.prototype.lift = function (operator) {\n            var observable = new Observable();\n            observable.source = this;\n            observable.operator = operator;\n            return observable;\n        };\n        /**\n         * Registers handlers for handling emitted values, error and completions from the observable, and\n         *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n         * @method subscribe\n         * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n         *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n         * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n         *  the error will be thrown as unhandled\n         * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n         * @return {ISubscription} a subscription reference to the registered handlers\n         */\n        Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n            var operator = this.operator;\n            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n            sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n            return sink;\n        };\n        /**\n         * @method forEach\n         * @param {Function} next a handler for each value emitted by the observable\n         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n         * @return {Promise} a promise that either resolves on observable completion or\n         *  rejects with the handled error\n         */\n        Observable.prototype.forEach = function (next, PromiseCtor) {\n            var _this = this;\n            if (!PromiseCtor) {\n                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                    PromiseCtor = root_1.root.Rx.config.Promise;\n                }\n                else if (root_1.root.Promise) {\n                    PromiseCtor = root_1.root.Promise;\n                }\n            }\n            if (!PromiseCtor) {\n                throw new Error('no Promise impl found');\n            }\n            return new PromiseCtor(function (resolve, reject) {\n                var subscription = _this.subscribe(function (value) {\n                    if (subscription) {\n                        // if there is a subscription, then we can surmise\n                        // the next handling is asynchronous. Any errors thrown\n                        // need to be rejected explicitly and unsubscribe must be\n                        // called manually\n                        try {\n                            next(value);\n                        }\n                        catch (err) {\n                            reject(err);\n                            subscription.unsubscribe();\n                        }\n                    }\n                    else {\n                        // if there is NO subscription, then we're getting a nexted\n                        // value synchronously during subscription. We can just call it.\n                        // If it errors, Observable's `subscribe` imple will ensure the\n                        // unsubscription logic is called, then synchronously rethrow the error.\n                        // After that, Promise will trap the error and send it\n                        // down the rejection path.\n                        next(value);\n                    }\n                }, reject, resolve);\n            });\n        };\n        Observable.prototype._subscribe = function (subscriber) {\n            return this.source.subscribe(subscriber);\n        };\n        /**\n         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n         * @method Symbol.observable\n         * @return {Observable} this instance of the observable\n         */\n        Observable.prototype[observable_1.$$observable] = function () {\n            return this;\n        };\n        // HACK: Since TypeScript inherits static properties too, we have to\n        // fight against TypeScript here so Subject can have a different static create signature\n        /**\n         * Creates a new cold Observable by calling the Observable constructor\n         * @static true\n         * @owner Observable\n         * @method create\n         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n         * @return {Observable} a new cold observable\n         */\n        Observable.create = function (subscribe) {\n            return new Observable(subscribe);\n        };\n        return Observable;\n    }());\n    exports.Observable = Observable;\n});\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Observable.js\n// module id = 45\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    var objectTypes = {\n        'boolean': false,\n        'function': true,\n        'object': true,\n        'number': false,\n        'string': false,\n        'undefined': false\n    };\n    exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n    /* tslint:disable:no-unused-variable */\n    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n    var freeGlobal = objectTypes[typeof global] && global;\n    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n        exports.root = freeGlobal;\n    }\n});\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/root.js\n// module id = 46\n// module chunks = 0","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 47\n// module chunks = 0","define([\"require\", \"exports\", '../util/root'], function (require, exports, root_1) {\n    \"use strict\";\n    var Symbol = root_1.root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            exports.$$observable = Symbol.observable;\n        }\n        else {\n            if (typeof Symbol.for === 'function') {\n                exports.$$observable = Symbol.for('observable');\n            }\n            else {\n                exports.$$observable = Symbol('observable');\n            }\n            Symbol.observable = exports.$$observable;\n        }\n    }\n    else {\n        exports.$$observable = '@@observable';\n    }\n});\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/symbol/observable.js\n// module id = 48\n// module chunks = 0","define([\"require\", \"exports\", '../Subscriber', '../symbol/rxSubscriber'], function (require, exports, Subscriber_1, rxSubscriber_1) {\n    \"use strict\";\n    function toSubscriber(nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver === 'object') {\n            if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n                return nextOrObserver;\n            }\n            else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {\n                return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n            }\n        }\n        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n    }\n    exports.toSubscriber = toSubscriber;\n});\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/toSubscriber.js\n// module id = 49\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\", './util/isFunction', './Subscription', './symbol/rxSubscriber', './Observer'], function (require, exports, isFunction_1, Subscription_1, rxSubscriber_1, Observer_1) {\n    \"use strict\";\n    /**\n     * Implements the {@link Observer} interface and extends the\n     * {@link Subscription} class. While the {@link Observer} is the public API for\n     * consuming the values of an {@link Observable}, all Observers get converted to\n     * a Subscriber, in order to provide Subscription-like capabilities such as\n     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n     * implementing operators, but it is rarely used as a public API.\n     *\n     * @class Subscriber<T>\n     */\n    var Subscriber = (function (_super) {\n        __extends(Subscriber, _super);\n        /**\n         * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n         * defined Observer or a `next` callback function.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         */\n        function Subscriber(destinationOrNext, error, complete) {\n            _super.call(this);\n            this.syncErrorValue = null;\n            this.syncErrorThrown = false;\n            this.syncErrorThrowable = false;\n            this.isStopped = false;\n            switch (arguments.length) {\n                case 0:\n                    this.destination = Observer_1.empty;\n                    break;\n                case 1:\n                    if (!destinationOrNext) {\n                        this.destination = Observer_1.empty;\n                        break;\n                    }\n                    if (typeof destinationOrNext === 'object') {\n                        if (destinationOrNext instanceof Subscriber) {\n                            this.destination = destinationOrNext;\n                            this.destination.add(this);\n                        }\n                        else {\n                            this.syncErrorThrowable = true;\n                            this.destination = new SafeSubscriber(this, destinationOrNext);\n                        }\n                        break;\n                    }\n                default:\n                    this.syncErrorThrowable = true;\n                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                    break;\n            }\n        }\n        /**\n         * A static factory for a Subscriber, given a (potentially partial) definition\n         * of an Observer.\n         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n         * Observer represented by the given arguments.\n         */\n        Subscriber.create = function (next, error, complete) {\n            var subscriber = new Subscriber(next, error, complete);\n            subscriber.syncErrorThrowable = false;\n            return subscriber;\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `next` from\n         * the Observable, with a value. The Observable may call this method 0 or more\n         * times.\n         * @param {T} [value] The `next` value.\n         * @return {void}\n         */\n        Subscriber.prototype.next = function (value) {\n            if (!this.isStopped) {\n                this._next(value);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `error` from\n         * the Observable, with an attached {@link Error}. Notifies the Observer that\n         * the Observable has experienced an error condition.\n         * @param {any} [err] The `error` exception.\n         * @return {void}\n         */\n        Subscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._error(err);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive a valueless notification of type\n         * `complete` from the Observable. Notifies the Observer that the Observable\n         * has finished sending push-based notifications.\n         * @return {void}\n         */\n        Subscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._complete();\n            }\n        };\n        Subscriber.prototype.unsubscribe = function () {\n            if (this.isUnsubscribed) {\n                return;\n            }\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n        };\n        Subscriber.prototype._next = function (value) {\n            this.destination.next(value);\n        };\n        Subscriber.prototype._error = function (err) {\n            this.destination.error(err);\n            this.unsubscribe();\n        };\n        Subscriber.prototype._complete = function () {\n            this.destination.complete();\n            this.unsubscribe();\n        };\n        Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n            return this;\n        };\n        return Subscriber;\n    }(Subscription_1.Subscription));\n    exports.Subscriber = Subscriber;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SafeSubscriber = (function (_super) {\n        __extends(SafeSubscriber, _super);\n        function SafeSubscriber(_parent, observerOrNext, error, complete) {\n            _super.call(this);\n            this._parent = _parent;\n            var next;\n            var context = this;\n            if (isFunction_1.isFunction(observerOrNext)) {\n                next = observerOrNext;\n            }\n            else if (observerOrNext) {\n                context = observerOrNext;\n                next = observerOrNext.next;\n                error = observerOrNext.error;\n                complete = observerOrNext.complete;\n                if (isFunction_1.isFunction(context.unsubscribe)) {\n                    this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = this.unsubscribe.bind(this);\n            }\n            this._context = context;\n            this._next = next;\n            this._error = error;\n            this._complete = complete;\n        }\n        SafeSubscriber.prototype.next = function (value) {\n            if (!this.isStopped && this._next) {\n                var _parent = this._parent;\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._next, value);\n                }\n                else if (this.__tryOrSetError(_parent, this._next, value)) {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var _parent = this._parent;\n                if (this._error) {\n                    if (!_parent.syncErrorThrowable) {\n                        this.__tryOrUnsub(this._error, err);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parent, this._error, err);\n                        this.unsubscribe();\n                    }\n                }\n                else if (!_parent.syncErrorThrowable) {\n                    this.unsubscribe();\n                    throw err;\n                }\n                else {\n                    _parent.syncErrorValue = err;\n                    _parent.syncErrorThrown = true;\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                var _parent = this._parent;\n                if (this._complete) {\n                    if (!_parent.syncErrorThrowable) {\n                        this.__tryOrUnsub(this._complete);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parent, this._complete);\n                        this.unsubscribe();\n                    }\n                }\n                else {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                this.unsubscribe();\n                throw err;\n            }\n        };\n        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            return false;\n        };\n        SafeSubscriber.prototype._unsubscribe = function () {\n            var _parent = this._parent;\n            this._context = null;\n            this._parent = null;\n            _parent.unsubscribe();\n        };\n        return SafeSubscriber;\n    }(Subscriber));\n});\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Subscriber.js\n// module id = 50\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    function isFunction(x) {\n        return typeof x === 'function';\n    }\n    exports.isFunction = isFunction;\n});\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/isFunction.js\n// module id = 51\n// module chunks = 0","define([\"require\", \"exports\", './util/isArray', './util/isObject', './util/isFunction', './util/tryCatch', './util/errorObject', './util/UnsubscriptionError'], function (require, exports, isArray_1, isObject_1, isFunction_1, tryCatch_1, errorObject_1, UnsubscriptionError_1) {\n    \"use strict\";\n    /**\n     * Represents a disposable resource, such as the execution of an Observable. A\n     * Subscription has one important method, `unsubscribe`, that takes no argument\n     * and just disposes the resource held by the subscription.\n     *\n     * Additionally, subscriptions may be grouped together through the `add()`\n     * method, which will attach a child Subscription to the current Subscription.\n     * When a Subscription is unsubscribed, all its children (and its grandchildren)\n     * will be unsubscribed as well.\n     *\n     * @class Subscription\n     */\n    var Subscription = (function () {\n        /**\n         * @param {function(): void} [unsubscribe] A function describing how to\n         * perform the disposal of resources when the `unsubscribe` method is called.\n         */\n        function Subscription(unsubscribe) {\n            /**\n             * A flag to indicate whether this Subscription has already been unsubscribed.\n             * @type {boolean}\n             */\n            this.isUnsubscribed = false;\n            if (unsubscribe) {\n                this._unsubscribe = unsubscribe;\n            }\n        }\n        /**\n         * Disposes the resources held by the subscription. May, for instance, cancel\n         * an ongoing Observable execution or cancel any other type of work that\n         * started when the Subscription was created.\n         * @return {void}\n         */\n        Subscription.prototype.unsubscribe = function () {\n            var hasErrors = false;\n            var errors;\n            if (this.isUnsubscribed) {\n                return;\n            }\n            this.isUnsubscribed = true;\n            var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n            this._subscriptions = null;\n            if (isFunction_1.isFunction(_unsubscribe)) {\n                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n                if (trial === errorObject_1.errorObject) {\n                    hasErrors = true;\n                    (errors = errors || []).push(errorObject_1.errorObject.e);\n                }\n            }\n            if (isArray_1.isArray(_subscriptions)) {\n                var index = -1;\n                var len = _subscriptions.length;\n                while (++index < len) {\n                    var sub = _subscriptions[index];\n                    if (isObject_1.isObject(sub)) {\n                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                        if (trial === errorObject_1.errorObject) {\n                            hasErrors = true;\n                            errors = errors || [];\n                            var err = errorObject_1.errorObject.e;\n                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                                errors = errors.concat(err.errors);\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n            }\n            if (hasErrors) {\n                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n            }\n        };\n        /**\n         * Adds a tear down to be called during the unsubscribe() of this\n         * Subscription.\n         *\n         * If the tear down being added is a subscription that is already\n         * unsubscribed, is the same reference `add` is being called on, or is\n         * `Subscription.EMPTY`, it will not be added.\n         *\n         * If this subscription is already in an `isUnsubscribed` state, the passed\n         * tear down logic will be executed immediately.\n         *\n         * @param {TeardownLogic} teardown The additional logic to execute on\n         * teardown.\n         * @return {Subscription} Returns the Subscription used or created to be\n         * added to the inner subscriptions list. This Subscription can be used with\n         * `remove()` to remove the passed teardown logic from the inner subscriptions\n         * list.\n         */\n        Subscription.prototype.add = function (teardown) {\n            if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n                return;\n            }\n            var sub = teardown;\n            switch (typeof teardown) {\n                case 'function':\n                    sub = new Subscription(teardown);\n                case 'object':\n                    if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                        break;\n                    }\n                    else if (this.isUnsubscribed) {\n                        sub.unsubscribe();\n                    }\n                    else {\n                        (this._subscriptions || (this._subscriptions = [])).push(sub);\n                    }\n                    break;\n                default:\n                    throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n            return sub;\n        };\n        /**\n         * Removes a Subscription from the internal list of subscriptions that will\n         * unsubscribe during the unsubscribe process of this Subscription.\n         * @param {Subscription} subscription The subscription to remove.\n         * @return {void}\n         */\n        Subscription.prototype.remove = function (subscription) {\n            // HACK: This might be redundant because of the logic in `add()`\n            if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n                return;\n            }\n            var subscriptions = this._subscriptions;\n            if (subscriptions) {\n                var subscriptionIndex = subscriptions.indexOf(subscription);\n                if (subscriptionIndex !== -1) {\n                    subscriptions.splice(subscriptionIndex, 1);\n                }\n            }\n        };\n        Subscription.EMPTY = (function (empty) {\n            empty.isUnsubscribed = true;\n            return empty;\n        }(new Subscription()));\n        return Subscription;\n    }());\n    exports.Subscription = Subscription;\n});\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Subscription.js\n// module id = 52\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n});\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/isArray.js\n// module id = 53\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    function isObject(x) {\n        return x != null && typeof x === 'object';\n    }\n    exports.isObject = isObject;\n});\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/isObject.js\n// module id = 54\n// module chunks = 0","define([\"require\", \"exports\", './errorObject'], function (require, exports, errorObject_1) {\n    \"use strict\";\n    var tryCatchTarget;\n    function tryCatcher() {\n        try {\n            return tryCatchTarget.apply(this, arguments);\n        }\n        catch (e) {\n            errorObject_1.errorObject.e = e;\n            return errorObject_1.errorObject;\n        }\n    }\n    function tryCatch(fn) {\n        tryCatchTarget = fn;\n        return tryCatcher;\n    }\n    exports.tryCatch = tryCatch;\n    ;\n});\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/tryCatch.js\n// module id = 55\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    // typeof any so that it we don't have to cast when comparing a result to the error object\n    exports.errorObject = { e: {} };\n});\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/errorObject.js\n// module id = 56\n// module chunks = 0","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    /**\n     * An error thrown when one or more errors have occurred during the\n     * `unsubscribe` of a {@link Subscription}.\n     */\n    var UnsubscriptionError = (function (_super) {\n        __extends(UnsubscriptionError, _super);\n        function UnsubscriptionError(errors) {\n            _super.call(this);\n            this.errors = errors;\n            this.name = 'UnsubscriptionError';\n            this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n        }\n        return UnsubscriptionError;\n    }(Error));\n    exports.UnsubscriptionError = UnsubscriptionError;\n});\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/util/UnsubscriptionError.js\n// module id = 57\n// module chunks = 0","define([\"require\", \"exports\", '../util/root'], function (require, exports, root_1) {\n    \"use strict\";\n    var Symbol = root_1.root.Symbol;\n    exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n});\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/symbol/rxSubscriber.js\n// module id = 58\n// module chunks = 0","define([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    exports.empty = {\n        isUnsubscribed: true,\n        next: function (value) { },\n        error: function (err) { throw err; },\n        complete: function () { }\n    };\n});\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@reactivex/rxjs/dist/amd/Observer.js\n// module id = 59\n// module chunks = 0","import createAction from 'dojo-actions/createAction';\nimport { assign } from 'dojo-core/lang';\nimport { includes } from 'dojo-shim/array';\n\nimport { ChangeRecord } from '../stores/todoStore';\nimport widgetStore from '../stores/widgetStore';\n\nexport const updateHeaderAndFooter = createAction({\n\tdo({ afterAll }: ChangeRecord) {\n\t\tconst completedCount = afterAll.filter(({ completed }) => completed).length;\n\t\tconst activeCount = afterAll.length - completedCount;\n\t\tconst hidden = afterAll.length ? [] : ['hidden'];\n\t\tconst allCompleted = afterAll.length === completedCount;\n\n\t\treturn Promise.all([\n\t\t\twidgetStore.patch({\n\t\t\t\tid: 'todo-footer',\n\t\t\t\tcompletedCount,\n\t\t\t\tactiveCount,\n\t\t\t\tclasses: ['footer', ...hidden]\n\t\t\t}),\n\n\t\t\twidgetStore.patch({\n\t\t\t\tid: 'todo-toggle',\n\t\t\t\tchecked: allCompleted,\n\t\t\t\tclasses: ['toggle-all', ...hidden]\n\t\t\t})\n\t\t]);\n\t}\n});\n\nexport const deleteTodo = createAction({\n\tdo({ afterAll, deletes }: ChangeRecord) {\n\t\tif (deletes.length) {\n\t\t\tconst [ deletedId ] = deletes;\n\t\t\tconst children = afterAll\n\t\t\t\t.filter(({ id }) => id !== deletedId)\n\t\t\t\t.map(({ id }) => id);\n\n\t\t\treturn widgetStore\n\t\t\t\t.delete(deletedId)\n\t\t\t\t.patch({ id: 'todo-list', children });\n\t\t}\n\t}\n});\n\nexport const putTodo = createAction({\n\tdo({ beforeAll, puts }: ChangeRecord) {\n\t\tif (puts.length) {\n\t\t\tconst [ item ] = puts;\n\t\t\tconst children = beforeAll.map(({ id }) => id);\n\n\t\t\tif (includes(children, item.id)) {\n\t\t\t\treturn widgetStore\n\t\t\t\t\t.patch(item)\n\t\t\t\t\t.patch({ id: 'todo-list', children });\n\t\t\t}\n\n\t\t\treturn widgetStore\n\t\t\t\t.put(assign({}, <any> item, { type: 'todo-item' }))\n\t\t\t\t.patch({id: 'todo-list', children: [...children, item.id]});\n\t\t}\n\t}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions/widgetStoreActions.ts","import createMemoryStore from 'dojo-stores/createMemoryStore';\n\nexport default createMemoryStore({\n\tdata: [\n\t\t{\n\t\t\tid: 'title',\n\t\t\tlabel: 'todos'\n\t\t},\n\t\t{\n\t\t\tid: 'new-todo',\n\t\t\tclasses: ['new-todo'],\n\t\t\tfocused: true,\n\t\t\tplaceholder: 'What needs to be done?'\n\t\t},\n\t\t{\n\t\t\tid: 'main-section',\n\t\t\tclasses: ['main']\n\t\t},\n\t\t{\n\t\t\tid: 'todo-list',\n\t\t\tclasses: ['todo-list'],\n\t\t\tchildren: []\n\t\t},\n\t\t{\n\t\t\tid: 'todo-toggle',\n\t\t\tclasses: ['toggle-all'],\n\t\t\tchecked: false\n\t\t},\n\t\t{\n\t\t\tid: 'todo-footer',\n\t\t\tclasses: ['footer'],\n\t\t\tcompletedCount: 0,\n\t\t\tactiveCount: 0,\n\t\t\tactiveFilter: 'all'\n\t\t}\n\t]\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/stores/widgetStore.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createStateful, { Stateful, StatefulOptions, State } from 'dojo-compose/mixins/createStateful';\nimport { EventObject } from 'dojo-core/interfaces';\nimport Task, { isTask } from 'dojo-core/async/Task';\nimport { Thenable } from 'dojo-shim/interfaces';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\n\n/**\n * A type alias to a \"generic\" action\n */\nexport type AnyAction = Action<any, DoOptions<any, TargettedEventObject<any>>, ActionState>;\n\nexport interface TargettedEventObject<T> extends EventObject {\n\t/**\n\t * The target of the event\n\t */\n\ttarget: T;\n}\n\nexport interface DoOptions<T, E extends TargettedEventObject<T>> {\n\t[option: string]: any;\n\n\t/**\n\t * The target event (subject) of the action\n\t */\n\tevent?: E;\n}\n\nexport interface ActionState extends State {\n\t/**\n\t * Determines if the action is enabled or not\n\t */\n\tenabled?: boolean;\n}\n\nexport interface ActionMixin<T, O extends DoOptions<T, TargettedEventObject<T>>> {\n\t/**\n\t * The main method that performs the action and returns a task which resolves when the action completes\n\t * @param options The options to be passed to the `do` method\n\t */\n\tdo(options?: O): Task<T>;\n\n\t/**\n\t * Enabled the task is disabled\n\t */\n\tenable(): void;\n\n\t/**\n\t * Disable the task if enabled\n\t */\n\tdisable(): void;\n\n\t/**\n\t * A method which may be called to configure the action after it's been created.\n\t *\n\t * It's up to the implementation to decide what happens if this method is called multiple times. Implementations\n\t * may throw or return a rejected promise.\n\t *\n\t * @param configuration The configuration. Implementations will need to cast to their expected configuration object\n\t * @return May return a promise in case configuration is asynchronous\n\t */\n\tconfigure(options: { [option: string]: any }): Promise<void> | void;\n}\n\nexport type Action<T, O extends DoOptions<T, TargettedEventObject<T>>, S extends ActionState> = Stateful<S> & ActionMixin<T, O>;\n\nexport type DoFunction<T> = (options?: DoOptions<T, TargettedEventObject<T>>) => T | Thenable<T>;\n\nexport interface ActionOptions<T, S extends ActionState> extends StatefulOptions<S> {\n\t/**\n\t * The method that is invoked when `do()` is called and the action is enabled\n\t */\n\tdo: DoFunction<T>;\n\n\t/**\n\t * Set the enabled state during construction\n\t */\n\tenabled?: boolean;\n\n\t/**\n\t * The method that is invoked when `configure()` is called\n\t */\n\tconfigure?(options: { [option: string]: any }): Promise<void> | void;\n}\n\nexport interface ActionFactory extends ComposeFactory<Action<any, DoOptions<any, any>, ActionState>, ActionOptions<any, ActionState>> {\n\t/**\n\t * Create a new instance of an Action, using the supplied options\n\t * @param options The options used to construct the Action\n\t */\n\t<T, O extends DoOptions<T, TargettedEventObject<T>>, S extends ActionState>(options: ActionOptions<T, S>): Action<T, O, S>;\n}\n\n/**\n * A type guard that validates the object passed is an Action\n */\nexport function isAction<T, O extends DoOptions<T, TargettedEventObject<T>>, S extends ActionState>(value: any): value is Action<T, O, S> {\n\treturn typeof value === 'object' && typeof value.do === 'function';\n}\n\n/**\n * A weak map of `do` methods\n */\nconst doFunctions = new WeakMap<AnyAction, DoFunction<any>>();\n\n/**\n * A weak map of `configure` methods\n */\nconst configureFunctions = new WeakMap<AnyAction, (configuration: Object) => Promise<void> | void>();\n\n/**\n * A factory which creates instances of Action\n */\nconst createAction: ActionFactory = compose<ActionMixin<any, DoOptions<any, TargettedEventObject<any>>>, ActionOptions<any, ActionState>>({\n\t\tdo(this: AnyAction, options?: DoOptions<any, TargettedEventObject<any>>): Task<any> {\n\t\t\tconst doFn = doFunctions.get(this);\n\t\t\tif (doFn && this.state.enabled) {\n\t\t\t\tconst result = doFn.call(this, options);\n\t\t\t\treturn isTask(result) ? result : Task.resolve(result);\n\t\t\t}\n\t\t\treturn Task.resolve();\n\t\t},\n\t\tenable(this: AnyAction): void {\n\t\t\tif (!this.state.enabled) {\n\t\t\t\tthis.setState({ enabled: true });\n\t\t\t}\n\t\t},\n\t\tdisable(this: AnyAction): void {\n\t\t\tif (this.state.enabled) {\n\t\t\t\tthis.setState({ enabled: false });\n\t\t\t}\n\t\t},\n\t\tconfigure(this: AnyAction, configuration: Object): Promise<void> | void {\n\t\t\tconst configureFn = configureFunctions.get(this);\n\t\t\tif (configureFn) {\n\t\t\t\treturn configureFn.call(this, configuration);\n\t\t\t}\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createStateful,\n\t\tinitialize(instance: AnyAction, { do: doFn, enabled = true, configure }: ActionOptions<any, ActionState>) {\n\t\t\tif (!doFn) {\n\t\t\t\tthrow new TypeError(`'options.do' required during creation.`);\n\t\t\t}\n\t\t\tdoFunctions.set(instance, doFn);\n\t\t\tinstance.setState({ enabled });\n\t\t\tif (configure) {\n\t\t\t\tconfigureFunctions.set(instance, configure);\n\t\t\t}\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tdoFunctions.delete(instance);\n\t\t\t\t\tconfigureFunctions.delete(instance);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\nexport default createAction;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-actions/createAction.ts","import { Thenable } from 'dojo-shim/interfaces';\nimport { Executor } from 'dojo-shim/Promise';\nimport ExtensiblePromise from './ExtensiblePromise';\n\n/**\n * Describe the internal state of a task.\n */\nexport declare const enum State {\n\tFulfilled = 0,\n\tPending = 1,\n\tRejected = 2,\n\tCanceled = 3\n}\n\n/**\n * A type guard that determines if `value` is a `Task`\n * @param value The value to guard\n */\nexport function isTask<T>(value: any): value is Task<T> {\n\treturn Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n}\n\n/**\n * Returns true if a given value has a `then` method.\n * @param {any} value The value to check if is Thenable\n * @returns {is Thenable<T>} A type guard if the value is thenable\n */\nexport function isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\n/**\n * Task is an extension of Promise that supports cancellation and the Task#finally method.\n */\nexport default class Task<T> extends ExtensiblePromise<T> {\n\t/**\n\t * Return a resolved task.\n\t *\n\t * @param value The value to resolve with\n\t *\n\t * @return {Task}\n\t */\n\tpublic static resolve(): Task<void>;\n\tpublic static resolve<T>(value: (T | Thenable<T>)): Task<T>;\n\tpublic static resolve<T>(value?: any): Task<T> {\n\t\treturn new this<T>((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * A cancelation handler that will be called if this task is canceled.\n\t */\n\tprivate canceler: () => void;\n\n\t/**\n\t * Children of this Task (i.e., Tasks that were created from this Task with `then` or `catch`).\n\t */\n\tprivate children: Task<any>[];\n\n\t/**\n\t * The finally callback for this Task (if it was created by a call to `finally`).\n\t */\n\tprivate _finally: () => void | Thenable<any>;\n\n\t/**\n\t * The state of the task\n\t */\n\tprotected _state: State;\n\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * @constructor\n\t *\n\t * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t *\n\t * @param executor Method that initiates some task\n\t * @param canceler Method to call when the task is canceled\n\t *\n\t */\n\tconstructor(executor: Executor<T>, canceler?: () => void) {\n\t\tsuper((resolve, reject) => {\n\t\t\t// Don't let the Task resolve if it's been canceled\n\t\t\texecutor(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (this._state === State.Canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._state = State.Fulfilled;\n\t\t\t\t\tresolve(value);\n\t\t\t\t},\n\t\t\t\t(reason) => {\n\t\t\t\t\tif (this._state === State.Canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._state = State.Rejected;\n\t\t\t\t\treject(reason);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\n\t\tthis._state = State.Pending;\n\n\t\tthis.children = [];\n\t\tthis.canceler = () => {\n\t\t\tif (canceler) {\n\t\t\t\tcanceler();\n\t\t\t}\n\t\t\tthis._cancel();\n\t\t};\n\t}\n\n\t/**\n\t * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t */\n\tprivate _cancel(finallyTask?: void | Thenable<any>): void {\n\t\tthis._state = State.Canceled;\n\n\t\tconst runFinally = () => {\n\t\t\ttry {\n\t\t\t\treturn this._finally();\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\t// Any errors in a `finally` callback are completely ignored during cancelation\n\t\t\t}\n\t\t};\n\n\t\tif (this._finally) {\n\t\t\tif (isThenable(finallyTask)) {\n\t\t\t\tfinallyTask = (<Thenable<any>> finallyTask).then(runFinally, runFinally);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinallyTask = runFinally();\n\t\t\t}\n\t\t}\n\n\t\tthis.children.forEach(function (child) {\n\t\t\tchild._cancel(finallyTask);\n\t\t});\n\t}\n\n\t/**\n\t * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t */\n\tcancel(): void {\n\t\tif (this._state === State.Pending) {\n\t\t\tthis.canceler();\n\t\t}\n\t}\n\n\t/**\n\t * Allows for cleanup actions to be performed after resolution of a Promise.\n\t */\n\tfinally(callback: () => void | Thenable<any>): Task<T> {\n\t\tconst task = this.then<any>(\n\t\t\tvalue => Task.resolve(callback()).then(() => value),\n\t\t\treason => Task.resolve(callback()).then(() => {\n\t\t\t\tthrow reason;\n\t\t\t})\n\t\t);\n\n\t\t// Keep a reference to the callback; it will be called if the Task is canceled\n\t\ttask._finally = callback;\n\t\treturn task;\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the Task resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<U>(onFulfilled?: (value?: T) => U | Thenable<U>, onRejected?: (error: Error) => U | Thenable<U>): this {\n\t\t// FIXME\n\t\t// tslint:disable-next-line:no-var-keyword\n\t\tvar task = super.then<U>(\n\t\t\t// Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t\t\tfunction (value) {\n\t\t\t\tif (task._state === State.Canceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (onFulfilled) {\n\t\t\t\t\treturn onFulfilled(value);\n\t\t\t\t}\n\t\t\t\treturn <any> value;\n\t\t\t},\n\t\t\tfunction (error) {\n\t\t\t\tif (task._state === State.Canceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (onRejected) {\n\t\t\t\t\treturn onRejected(error);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\ttask.canceler = () => {\n\t\t\t// If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t\t\t// unresolved parent\n\t\t\tif (this._state === State.Pending) {\n\t\t\t\tthis.cancel();\n\t\t\t}\n\t\t\t// If task's parent has been resolved, propagate cancelation to the task's descendants\n\t\t\telse {\n\t\t\t\ttask._cancel();\n\t\t\t}\n\t\t};\n\n\t\t// Keep track of child Tasks for propogating cancelation back down the chain\n\t\tthis.children.push(task);\n\n\t\treturn task;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/async/Task.ts","import { Iterable, forOf } from 'dojo-shim/iterator';\nimport Promise, { Executor } from 'dojo-shim/Promise';\nimport { Thenable } from 'dojo-shim/interfaces';\n\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nfunction unwrapPromises(iterable: Iterable<any> | any[]): any[] {\n\tconst unwrapped: any[] = [];\n\tforOf(iterable, function (item: any): void {\n\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t});\n\treturn unwrapped;\n}\n\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nexport default class ExtensiblePromise<T> {\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param {Error?} reason    The reason for the rejection\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic reject<T>(reason?: Error): any {\n\t\treturn new this<T>((resolve, reject) => reject(reason));\n\t}\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic resolve(): any;\n\tstatic resolve<T>(value: (T | Thenable<T>)): any;\n\tstatic resolve<T>(value?: any): any {\n\t\treturn new this<T>((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic all<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): F {\n\t\treturn <F> new this((resolve, reject) => {\n\t\t\tPromise.all(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic race<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): F {\n\t\treturn <F> new this((resolve, reject) => {\n\t\t\tPromise.race(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Promise}\n\t * The wrapped promise\n\t */\n\t_promise: Promise<T>;\n\n\t/**\n\t * Creates a new extended Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\tthis._promise = new Promise<T>(executor);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise is rejected.\n\t *\n\t * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tcatch<U>(onRejected: (reason: Error) => (U | Thenable<U>)): this;\n\tcatch<U>(onRejected: (reason: Error) => void): this {\n\t\treturn this.then<U>(undefined, onRejected);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): this;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): this {\n\t\tlet e: Executor<U> = (resolve, reject) => {\n\t\t\tfunction handler(rejected: boolean, valueOrError: T | U | Error) {\n\t\t\t\tconst callback: ((value: T | U | Error) => (U | Thenable<U> | void)) | undefined = rejected ? onRejected : onFulfilled;\n\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(<U> callback(<T> valueOrError));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (rejected) {\n\t\t\t\t\treject(valueOrError);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve(<U> valueOrError);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t\t};\n\n\t\treturn new (<{ new(executor: Executor<U>): any }> this.constructor)(e);\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/async/ExtensiblePromise.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport createStateful, { Stateful, StatefulOptions, StateChangeEvent, State } from 'dojo-compose/mixins/createStateful';\nimport Map from 'dojo-shim/Map';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { List, Map as ImmutableMap } from 'immutable';\nimport { Child, ChildListEvent, CreatableRegistry, RegistryProvider } from './interfaces';\nimport { isList } from '../util/lang';\n\nexport interface StatefulChildrenState {\n\t/**\n\t * Any children that the widget should \"own\"\n\t */\n\tchildren?: string[];\n}\n\nexport interface StatefulChildrenOptions<C extends Child, S extends StatefulChildrenState> extends StatefulOptions<S> {\n\t/**\n\t * The registry provider that should be used to resolve a widget registry and subsequently, widgets\n\t */\n\tregistryProvider?: RegistryProvider<C>;\n}\n\nexport interface CreateChildrenMap<C extends Child, O extends StatefulOptions<State>> {\n\t[label: string]: {\n\t\tfactory: ComposeFactory<C, O>;\n\t\toptions?: O;\n\t};\n}\n\n/**\n * Interface that represents and item from a returned `.createChildren()` map\n */\nexport interface CreateChildrenResultsItem<C extends Child> {\n\tid: string;\n\twidget: C;\n}\n\n/**\n * Interface that describes the children results returned from `.createChildren()`\n */\nexport interface CreateChildrenResults<C extends Child> {\n\t[label: string]: CreateChildrenResultsItem<C>;\n}\n\nexport type StatefulChildren<C extends Child> = {\n\t/**\n\t * The children that are associated with this widget\n\t */\n\tchildren: List<C> | ImmutableMap<string, C>;\n\n\t/**\n\t * Creates an instance based on the supplied factory and adds the child to this parent\n\t * returning a promise which resolves with the ID and the instace.\n\t *\n\t * @param factory The factory to use to create the child\n\t * @param options Any options that should be used when creating the child\n\t */\n\tcreateChild<D extends C, O extends StatefulOptions<S>, S extends State>(\n\t\tfactory: ComposeFactory<D, O>, options?: O): Promise<[string, D]>;\n\n\t/**\n\t * Creates a set or map of instances based upon the supplied data\n\t *\n\t * @param children the set or map of children factories and options\n\t */\n\tcreateChildren(children: [ComposeFactory<C, any>, any][]): Promise<[string, any][]>;\n\tcreateChildren(children: CreateChildrenMap<C, any>): Promise<CreateChildrenResults<C>>;\n\n\t/**\n\t * The ID for this widget\n\t */\n\treadonly id: string | null;\n}\n\nexport type StatefulChildrenMixin<C extends Child, S extends StatefulChildrenState> = Stateful<S> & StatefulChildren<C>;\n\nexport interface StatefulChildrenMixinFactory extends ComposeFactory<StatefulChildrenMixin<Child, StatefulChildrenState>, StatefulChildrenOptions<Child, StatefulChildrenState>> {\n\t<C extends Child>(options?: StatefulChildrenOptions<C, StatefulChildrenState>): StatefulChildrenMixin<C, StatefulChildrenState>;\n}\n\ninterface ManagementState {\n\t/**\n\t * A map of children to widget instances, so they don't have to be requested subsequently from the registry\n\t */\n\tcache?: Map<string | symbol, Child>;\n\n\t/**\n\t * The current set of children widgets\n\t */\n\tcurrent?: List<string>;\n\n\t/**\n\t * A generation number to avoid race conditions when managing children\n\t */\n\tgeneration: number;\n\n\t/**\n\t * A instance UID to be used when generating child widget IDs\n\t */\n\tchildrenUID: number;\n\n\t/**\n\t * This widget's ID which was potentially passed in creation options\n\t */\n\tid: string | undefined;\n\n\t/**\n\t * A reference to the widget registry that is used for resolving and creating children\n\t */\n\tregistry: CreatableRegistry<Child>;\n}\n\n/**\n * Map that holds state for manageChildren and manageChildrenState by widget instance.\n */\nconst managementMap = new WeakMap<StatefulChildrenMixin<Child, StatefulChildrenState>, ManagementState>();\n\n/**\n * Internal statechange listener which deals with managing the children when a state\n * change occurs on the parent\n *\n * @param evt The state change event of the parent\n */\nfunction manageChildren(evt: StateChangeEvent<StatefulChildrenState>): void {\n\tconst parent: StatefulChildrenMixin<Child, StatefulChildrenState> = <any> evt.target;\n\n\t/* Assume this function cannot be called without the widget being in the management map */\n\tconst internalState = managementMap.get(parent);\n\n\t/* Initialize cache */\n\tconst { cache = new Map<string | symbol, Child>() } = internalState;\n\n\tif (!internalState.cache) {\n\t\tinternalState.cache = cache;\n\t}\n\t/* Initialize current children IDs */\n\tif (!internalState.current) {\n\t\tinternalState.current = List<string>();\n\t}\n\n\tconst currentChildrenIDs = evt.state.children ? List(evt.state.children) : List<string>();\n\tif (currentChildrenIDs.equals(internalState.current)) {\n\t\t/* There are no changes to the children */\n\t\treturn;\n\t}\n\n\t// Increment the generation vector. Used when children are replaced asynchronously to ensure\n\t// no newer state is overriden.\n\tconst generation = ++internalState.generation;\n\n\tinternalState.current = currentChildrenIDs;\n\tconst resolvingWidgets: [ Promise<Child>, string, number ][] = [];\n\n\t/* Sometimes we are dealing with children that are a list, somtimes, a Map */\n\tconst childrenList: Child[] = [];\n\tconst childrenMap: { [ id: string ]: Child } = {};\n\tconst childrenIsList = isList(parent.children);\n\n\t/* Iterate through children ids, retrieving reference to widget or otherwise\n\t * requesting the widget from the registry */\n\tcurrentChildrenIDs.forEach((id, key) => {\n\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t// istanbul ignore else\n\t\tif (id !== undefined && key !== undefined) {\n\t\t\tif (cache.has(id)) {\n\t\t\t\tif (childrenIsList) {\n\t\t\t\t\tchildrenList[key] = <Child> cache.get(id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildrenMap[id] = <Child> cache.get(id);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst widgetPromise = internalState.registry.has(id).then((exists) => {\n\t\t\t\t\tif (exists) {\n\t\t\t\t\t\treturn internalState.registry.get(id);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t/* Tuple of Promise, child ID, position in child list */\n\t\t\t\tresolvingWidgets.push([ widgetPromise, id, key ]);\n\t\t\t}\n\t\t}\n\t});\n\n\t/* If we have requests for widgets outstanding, we need to wait for them to be\n\t * resolved and then populate them in the children */\n\tif (resolvingWidgets.length) {\n\t\tPromise.all(resolvingWidgets.map(([ promise ]) => promise))\n\t\t\t.then((widgets) => {\n\t\t\t\t/* Only replace children if there is no newer state that either already has, or soon will,\n\t\t\t\t * replace the original listeners. */\n\t\t\t\tif (internalState.generation !== generation) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\twidgets.forEach((widget, idx) => {\n\t\t\t\t\tconst [ , id, key ] = resolvingWidgets[idx];\n\t\t\t\t\tif (widget) {\n\t\t\t\t\t\tif (childrenIsList) {\n\t\t\t\t\t\t\tchildrenList[key] = widget;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchildrenMap[id] = widget;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcache.set(id, widget);\n\t\t\t\t\t\twidget.own({\n\t\t\t\t\t\t\tdestroy() {\n\t\t\t\t\t\t\t\tcache.delete(id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (childrenIsList) {\n\t\t\t\t\t\t\tchildrenList.splice(key, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t/* Some parents have a List, some have a Map, so setting them varies */\n\t\t\t\tparent.children = isList(parent.children) ? List(childrenList) : ImmutableMap<string, Child>(childrenMap);\n\t\t\t}, (error) => {\n\t\t\t\t/* A promise got rejected for some reason */\n\t\t\t\tparent.emit({\n\t\t\t\t\ttype: 'error',\n\t\t\t\t\ttarget: parent,\n\t\t\t\t\terror: error\n\t\t\t\t});\n\t\t\t});\n\t}\n\telse {\n\t\t/* Otherwise we can just set the children */\n\t\tparent.children = isList(parent.children) ? List(childrenList) : ImmutableMap<string, Child>(childrenMap);\n\t}\n}\n\n/**\n * Internal function to manage the state of the children when a child list event occurs\n *\n * @param evt The child list event from the parent\n */\nfunction manageChildrenState(evt: ChildListEvent<any, Child>) {\n\tconst parent: StatefulChildrenMixin<Child, StatefulChildrenState> = evt.target;\n\n\t/* Assume this function cannot be called without the widget being in the management map */\n\tconst { registry } = managementMap.get(parent);\n\n\tconst evtChildren = evt.children;\n\n\tlet currentChildrenIDs: List<string>;\n\tif (isList(evtChildren)) {\n\t\tcurrentChildrenIDs = <List<string>> evtChildren.map((widget) => {\n\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t// istanbul ignore else\n\t\t\tif (widget) {\n\t\t\t\treturn registry.identify(widget);\n\t\t\t}\n\t\t});\n\t}\n\telse {\n\t\tcurrentChildrenIDs = List(evtChildren.keys());\n\t}\n\n\tconst storedChildren = parent.state.children ? List(parent.state.children) : List<string>();\n\tif (!currentChildrenIDs.equals(storedChildren)) {\n\t\tconst children = currentChildrenIDs.toArray();\n\t\tparent.setState({ children });\n\t}\n}\n\nfunction isCreateChildrenMap<C extends Child, O extends StatefulOptions<S>, S extends State>(value: any): value is CreateChildrenMap<C, O> {\n\treturn typeof value === 'object' && !Array.isArray(value);\n}\n\nconst createStatefulChildrenMixin: StatefulChildrenMixinFactory = createStateful\n\t.mixin({\n\t\tmixin: <StatefulChildren<any>> {\n\t\t\tcreateChildren(\n\t\t\t\tthis: StatefulChildrenMixin<Child, StatefulChildrenState>,\n\t\t\t\tchildren: CreateChildrenMap<Child, StatefulOptions<State>> | [ComposeFactory<Child, StatefulOptions<State>>, any][]\n\t\t\t): Promise<[string, any][]> | Promise<CreateChildrenResults<any>> {\n\t\t\t\tif (managementMap.has(this)) {\n\t\t\t\t\tconst management = managementMap.get(this);\n\t\t\t\t\tconst { registry, id } = management;\n\t\t\t\t\tif (isCreateChildrenMap(children)) {\n\t\t\t\t\t\t/* Because we have a map, but Promise.all only takes an array, we have to \"flatten\" the map into\n\t\t\t\t\t\t* two arrays, of promises and labels */\n\t\t\t\t\t\tconst promises: Promise<[ string, Child ]>[] = [];\n\t\t\t\t\t\tconst labels: string[] = [];\n\t\t\t\t\t\tfor (const label in children) {\n\t\t\t\t\t\t\tconst { factory, options = {} } = children[label];\n\t\t\t\t\t\t\tif (!options.id) {\n\t\t\t\t\t\t\t\t/* See createChild for explination of this logic */\n\t\t\t\t\t\t\t\toptions.id = `${id || this.id}-child-${++management.childrenUID}`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpromises.push(registry.create(factory, options));\n\t\t\t\t\t\t\tlabels.push(label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn Promise\n\t\t\t\t\t\t\t.all(promises)\n\t\t\t\t\t\t\t.then((items) => {\n\t\t\t\t\t\t\t\t/* create a handle which will destroy the children created */\n\t\t\t\t\t\t\t\tconst instances = items.map(([ , child ]) => child );\n\t\t\t\t\t\t\t\tthis.own({\n\t\t\t\t\t\t\t\t\tdestroy() {\n\t\t\t\t\t\t\t\t\t\treturn instances.map((instance) => instance.destroy());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t/* Now we need to constitute our map to return it */\n\t\t\t\t\t\t\t\tconst results: CreateChildrenResults<Child> = {};\n\t\t\t\t\t\t\t\tconst newChildren = items.map(([ id, widget ], idx) => {\n\t\t\t\t\t\t\t\t\tresults[labels[idx]] = { id, widget };\n\t\t\t\t\t\t\t\t\treturn id;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst children = this.state.children ? [ ...this.state.children, ...newChildren ] : newChildren;\n\t\t\t\t\t\t\t\tthis.setState({ children });\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn Promise\n\t\t\t\t\t\t\t.all(children.map(([ factory, options ]) => {\n\t\t\t\t\t\t\t\tif (!options.id) {\n\t\t\t\t\t\t\t\t\t/* depending upon the construction lifecycle, the this.id may not have been properly set and will\n\t\t\t\t\t\t\t\t\t* auto-generate an ID, therefore we have copied the ID out of options, if it was present and will\n\t\t\t\t\t\t\t\t\t* use that as a base for autogenerating the child widget's ID */\n\t\t\t\t\t\t\t\t\toptions.id = `${id || this.id}-child-${++management.childrenUID}`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn registry.create(factory, options);\n\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t.then((items) => {\n\t\t\t\t\t\t\t\t/* create a handle which will destroy the children created */\n\t\t\t\t\t\t\t\tconst instances = items.map(([ , child ]) => child );\n\t\t\t\t\t\t\t\tthis.own({\n\t\t\t\t\t\t\t\t\tdestroy() {\n\t\t\t\t\t\t\t\t\t\treturn instances.map((instance) => instance.destroy());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tconst newChildren = items.map(([ id ]) => id);\n\t\t\t\t\t\t\t\tconst children = this.state.children ? [ ...this.state.children, ...newChildren ] : newChildren;\n\t\t\t\t\t\t\t\tthis.setState({ children });\n\t\t\t\t\t\t\t\treturn items;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn Promise.reject(new Error('Unable to resolve registry'));\n\t\t\t},\n\n\t\t\tcreateChild<C extends Child>(\n\t\t\t\tthis: StatefulChildrenMixin<Child, StatefulChildrenState>,\n\t\t\t\tfactory: ComposeFactory<C, any>,\n\t\t\t\toptions: any = {}\n\t\t\t): Promise<[string, C]> {\n\t\t\t\treturn this.createChildren([ [ factory, options ] ]).then(([ tuple ]) => tuple);\n\t\t\t}\n\t\t},\n\t\tinitialize(instance: StatefulChildrenMixin<any, any>, { registryProvider, id, state }: StatefulChildrenOptions<any, any> = {}) {\n\t\t\tif (registryProvider) {\n\t\t\t\tconst registry = registryProvider.get('widgets');\n\t\t\t\tmanagementMap.set(instance, {\n\t\t\t\t\tregistry,\n\t\t\t\t\tgeneration: 0,\n\t\t\t\t\tchildrenUID: 0,\n\t\t\t\t\tid\n\t\t\t\t});\n\n\t\t\t\tinstance.own(instance.on('statechange', manageChildren));\n\t\t\t\tinstance.own(instance.on('childlist', manageChildrenState));\n\n\t\t\t\t/* Stateful will have already fired the statechange event at this point */\n\t\t\t\tif (state) {\n\t\t\t\t\tinstance.setState(state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createStatefulChildrenMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createStatefulChildrenMixin.ts","import WeakMap from 'dojo-shim/WeakMap';\nimport createFormFieldMixin, { FormFieldMixin, FormFieldMixinOptions, FormFieldMixinState } from 'dojo-widgets/mixins/createFormFieldMixin';\nimport createRenderMixin, { RenderMixin, RenderMixinOptions, RenderMixinState } from 'dojo-widgets/mixins/createRenderMixin';\nimport createVNodeEvented, { VNodeEvented } from 'dojo-widgets/mixins/createVNodeEvented';\nimport { VNodeProperties } from 'maquette';\n\n/* I suspect this needs to go somewhere else */\nexport interface TypedTargetEvent<T extends EventTarget> extends Event {\n\ttarget: T;\n}\n\nexport type FocusableTextInputState = RenderMixinState & FormFieldMixinState<string> & {\n\tfocused?: boolean;\n\tplaceholder?: string;\n};\n\nexport type FocusableTextInputOptions = RenderMixinOptions<FocusableTextInputState> & FormFieldMixinOptions<string, FocusableTextInputState>;\n\nexport type FocusableTextInput = RenderMixin<FocusableTextInputState> & FormFieldMixin<string, FocusableTextInputState> & VNodeEvented;\n\nconst afterUpdateFunctions = new WeakMap<FocusableTextInput, {(element: HTMLInputElement): void}>();\n\nfunction afterUpdate(instance: FocusableTextInput, element: HTMLInputElement) {\n\tconst focused: boolean = instance.state.focused;\n\tif (focused) {\n\t\tsetTimeout(() => element.focus(), 0);\n\t}\n\telse if (!focused && document.activeElement === element) {\n\t\telement.blur();\n\t}\n}\n\nconst createFocusableTextInput = createRenderMixin\n\t.mixin(createFormFieldMixin)\n\t.mixin({\n\t\tmixin: createVNodeEvented,\n\t\tinitialize(instance) {\n\t\t\tinstance.own(instance.on('input', (event: TypedTargetEvent<HTMLInputElement>) => {\n\t\t\t\tinstance.value = event.target.value;\n\t\t\t}));\n\t\t\tafterUpdateFunctions.set(instance, (element: HTMLInputElement) => afterUpdate(instance, element));\n\t\t}\n\t})\n\t.extend({\n\t\tnodeAttributes: [\n\t\t\tfunction (this: FocusableTextInput): VNodeProperties {\n\t\t\t\tconst afterUpdate = afterUpdateFunctions.get(this);\n\t\t\t\tconst { placeholder } = this.state;\n\t\t\t\treturn { afterUpdate, placeholder };\n\t\t\t}\n\t\t],\n\n\t\ttagName: 'input',\n\n\t\ttype: 'text'\n\t});\n\nexport default createFocusableTextInput;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createFocusableTextInput.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport createRenderMixin, { RenderMixinState, RenderMixinOptions, RenderMixin } from './mixins/createRenderMixin';\nimport createVNodeEvented, { VNodeEvented, VNodeEventedOptions } from './mixins/createVNodeEvented';\nimport createFormFieldMixin, { FormFieldMixin, FormFieldMixinState, FormFieldMixinOptions } from './mixins/createFormFieldMixin';\nimport css from './themes/structural/modules/Button';\n\nexport interface ButtonState extends RenderMixinState, FormFieldMixinState<string> { }\n\nexport interface ButtonOptions extends VNodeEventedOptions, RenderMixinOptions<ButtonState>, FormFieldMixinOptions<any, ButtonState> { }\n\nexport type Button = RenderMixin<ButtonState> & FormFieldMixin<string, ButtonState> & VNodeEvented;\n\nexport interface ButtonFactory extends ComposeFactory<Button, ButtonOptions> { }\n\nconst createButton: ButtonFactory = createRenderMixin\n\t.mixin(createFormFieldMixin)\n\t.mixin(createVNodeEvented)\n\t.extend({\n\t\ttagName: 'button',\n\t\ttype: 'button',\n\t\tclasses: [ css.button ]\n\t});\n\nexport default createButton;\n\n\n\n// WEBPACK FOOTER //\n// src/createButton.ts","/* tslint:disable:object-literal-key-quotes quotemark whitespace */\nexport default {\"button\":\"_button_ng9vr_1\"};\n\n\n\n// WEBPACK FOOTER //\n// src/themes/structural/modules/Button.ts","import createButton from 'dojo-widgets/createButton';\nimport createParentMapMixin, { ParentMap, ParentMapMixinOptions } from 'dojo-widgets/mixins/createParentMapMixin';\nimport createRenderMixin, { RenderMixin, RenderMixinOptions, RenderMixinState } from 'dojo-widgets/mixins/createRenderMixin';\nimport createStatefulChildrenMixin, { StatefulChildrenState, StatefulChildrenOptions } from 'dojo-widgets/mixins/createStatefulChildrenMixin';\nimport { Child } from 'dojo-widgets/mixins/interfaces';\n\nimport { h, VNode } from 'maquette';\n\nimport { clearCompleted } from '../actions/userActions';\nimport createTodoFilter from './createTodoFilter';\n\nexport type TodoFooterState = RenderMixinState & StatefulChildrenState & {\n\tactiveFilter?: string;\n\tactiveCount?: number;\n\tcompletedCount?: number;\n};\n\nexport type TodoFooterOptions = RenderMixinOptions<TodoFooterState> & ParentMapMixinOptions<Child> & StatefulChildrenOptions<Child, TodoFooterState>;\n\nexport type TodoFooter = RenderMixin<TodoFooterState> & ParentMap<RenderMixin<TodoFooterState>>;\n\nfunction manageChildren(this: TodoFooter) {\n\tconst filterWidget = this.children.get('filter');\n\tconst buttonWidget = this.children.get('button');\n\n\tfilterWidget.setState({\n\t\tactiveFilter: this.state.activeFilter\n\t});\n\n\tconst clearCompletedButtonClasses = ['clear-completed'];\n\tif (this.state.completedCount === 0) {\n\t\tclearCompletedButtonClasses.push('hidden');\n\t}\n\n\tbuttonWidget.setState({\n\t\tclasses: clearCompletedButtonClasses\n\t});\n}\n\nconst createTodoFooter = createRenderMixin\n\t.mixin(createStatefulChildrenMixin)\n\t.mixin({\n\t\tmixin: createParentMapMixin,\n\t\tinitialize(instance, options) {\n\t\t\tconst filterWidget = createTodoFilter({\n\t\t\t\tstate: {\n\t\t\t\t\tid: 'filter',\n\t\t\t\t\tclasses: ['filters']\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst clearCompletedButton = createButton({\n\t\t\t\tstate: {\n\t\t\t\t\tid: 'button',\n\t\t\t\t\tlabel: 'Clear completed',\n\t\t\t\t\tclasses: ['clear-completed']\n\t\t\t\t},\n\t\t\t\tlisteners: {\n\t\t\t\t\tclick: clearCompleted\n\t\t\t\t}\n\t\t\t});\n\t\t\tinstance.append([filterWidget, clearCompletedButton]);\n\t\t\tinstance.on('statechange', manageChildren);\n\t\t}\n\t})\n\t.extend({\n\t\tgetChildrenNodes(this: TodoFooter): VNode[] {\n\t\t\tconst activeCount = this.state.activeCount;\n\t\t\tconst countLabel = activeCount === 1 ? 'item' : 'items';\n\n\t\t\treturn [\n\t\t\t\th('span', {'class': 'todo-count'}, [\n\t\t\t\t\th('strong', [activeCount + ' ']),\n\t\t\t\t\th('span', [countLabel + ' left'])\n\t\t\t\t]),\n\t\t\t\tthis.children.get('filter').render(),\n\t\t\t\tthis.children.get('button').render()\n\t\t\t];\n\t\t},\n\n\t\ttagName: 'footer'\n\t});\n\nexport default createTodoFooter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoFooter.ts","import createRenderMixin, { RenderMixin, RenderMixinState, RenderMixinOptions } from 'dojo-widgets/mixins/createRenderMixin';\nimport { h, VNode } from 'maquette';\n\ntype TodoFilterState = RenderMixinState & {\n\tactiveFilter?: string;\n};\n\ntype TodoFilterOptions = RenderMixinOptions<TodoFilterState>;\n\ntype TodoFilter = RenderMixin<TodoFilterState>;\n\nconst createTodoFilter = createRenderMixin\n\t.extend({\n\t\tgetChildrenNodes(this: TodoFilter): VNode[] {\n\t\t\tconst { activeFilter } = this.state;\n\t\t\treturn [\n\t\t\t\th('li', {}, [\n\t\t\t\t\th('a', {\n\t\t\t\t\t\tinnerHTML: 'All',\n\t\t\t\t\t\thref: '#all',\n\t\t\t\t\t\tclasses: {\n\t\t\t\t\t\t\tselected: activeFilter === 'all'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t]),\n\t\t\t\th('li', {}, [\n\t\t\t\t\th('a', {\n\t\t\t\t\t\tinnerHTML: 'Active',\n\t\t\t\t\t\thref: '#active',\n\t\t\t\t\t\tclasses: {\n\t\t\t\t\t\t\tselected: activeFilter === 'active'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t]),\n\t\t\t\th('li', {}, [\n\t\t\t\t\th('a', {\n\t\t\t\t\t\tinnerHTML: 'Completed',\n\t\t\t\t\t\thref: '#completed',\n\t\t\t\t\t\tclasses: {\n\t\t\t\t\t\t\tselected: activeFilter === 'completed'\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t];\n\t\t},\n\n\t\ttagName: 'ul'\n\t});\n\nexport default createTodoFilter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoFilter.ts","import { Map } from 'immutable';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, { Evented, EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport { Handle } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Child, ChildListEvent, ChildrenMap } from './interfaces';\nimport { getRemoveHandle } from '../util/lang';\n\nexport interface ParentMapMixinOptions<C extends Child> {\n\t/**\n\t * Children that are owned by the parent on creation\n\t */\n\tchildren?: ChildrenMap<C>;\n}\n\nexport interface ParentMap<C extends Child> {\n\t/**\n\t * An immutable map of children associated with this parent\n\t */\n\tchildren: Map<string, C>;\n\n\t/**\n\t * Append a child (or an array of children) to this parent\n\t *\n\t * Appending will attempt to determine the child's ID and use that as the key in the\n\t * children map.  If it cannot be determined, a unique ID will be generated\n\t * @param child The child (or children) to append\n\t */\n\tappend(child: C | C[]): Handle;\n\n\t/**\n\t * Clear all the children from this parent\n\t */\n\tclear(): void;\n\n\t/**\n\t * Merge a map of children with any existing children of this parent\n\t * @param children The Map of the children\n\t */\n\tmerge(children: ChildrenMap<C>): Handle;\n\n\ton?(type: 'childlist', listener: EventedListener<ChildListEvent<this, C>>): Handle;\n\ton?(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type ParentMapMixin<C extends Child> = ParentMap<C> & Evented;\n\nexport interface ParentMapMixinFactory extends ComposeFactory<ParentMapMixin<Child>, ParentMapMixinOptions<Child>> { }\n\nconst childrenMap = new WeakMap<ParentMapMixin<Child>, Map<string, Child>>();\n\n/**\n * Function that resolves the key for the children map for a given child\n * @param parent The parent that the child will be mapped to\n * @param child The child that is being mapped\n */\nfunction getChildKey(parent: ParentMap<Child>, child: Child): string {\n\treturn child.id || 'child' + parent.children.size;\n}\n\n/**\n * Function that converts an array of children into a map of children\n * @param parent The parent that the children will be mapped to\n * @param children An array of children to be mapped to the parent\n */\nfunction mapChildArray<C extends Child>(parent: ParentMap<C>, children: C[]): ChildrenMap<C> {\n\tconst childMap: ChildrenMap<C> = {};\n\tlet keyCount = parent.children.size;\n\t/* TODO: in theory, if children are added, then removed and then added again, duplicate keys could\n\t * be generated*/\n\tchildren.forEach((child) => childMap[child.id || 'child' + keyCount++] = child);\n\treturn childMap;\n}\n\nconst createParentMapMixin: ParentMapMixinFactory = compose<ParentMap<Child>, ParentMapMixinOptions<Child>>({\n\t\tget children(this: ParentMapMixin<Child> & { invalidate?(): void; }): Map<string, Child> {\n\t\t\treturn childrenMap.get(this);\n\t\t},\n\n\t\tset children(this: ParentMapMixin<Child> & { invalidate?(): void; }, value: Map<string, Child>) {\n\t\t\tif (!value.equals(childrenMap.get(this))) {\n\t\t\t\tvalue.forEach((widget) => {\n\t\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t\t// istanbul ignore else\n\t\t\t\t\tif (widget) {\n\t\t\t\t\t\tif (widget.parent !== this) {\n\t\t\t\t\t\t\twidget.parent = this;\n\t\t\t\t\t\t\t/* TODO: If a child gets attached and reattached it may own multiple handles */\n\t\t\t\t\t\t\tgetRemoveHandle(this, widget);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchildrenMap.set(this, value);\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'childlist',\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tchildren: value\n\t\t\t\t});\n\t\t\t\tif (this.invalidate) {\n\t\t\t\t\tthis.invalidate();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tappend(this: ParentMapMixin<Child>, child: Child[] | Child): Handle {\n\t\t\tthis.children = Array.isArray(child) ?\n\t\t\t\tthis.children.merge(mapChildArray(this, child)) :\n\t\t\t\tthis.children.set(getChildKey(this, child), child);\n\t\t\treturn getRemoveHandle<Child>(this, child);\n\t\t},\n\n\t\tmerge(this: ParentMapMixin<Child>, children: ChildrenMap<Child>): Handle {\n\t\t\tthis.children = this.children.merge(children);\n\t\t\treturn getRemoveHandle(this, children);\n\t\t},\n\n\t\tclear(this: ParentMapMixin<Child>) {\n\t\t\tthis.children = Map<string, Child>();\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createEvented,\n\t\tinitialize(instance, options) {\n\t\t\tchildrenMap.set(instance, Map<string, Child>());\n\t\t\tif (options && options.children) {\n\t\t\t\tinstance.own(instance.merge(options.children));\n\t\t\t}\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tconst children = childrenMap.get(instance);\n\t\t\t\t\tchildren.forEach((child) => {\n\t\t\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t\t\t// istanbul ignore else\n\t\t\t\t\t\tif (child) {\n\t\t\t\t\t\t\tchild.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\nexport default createParentMapMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createParentMapMixin.ts","import createRoute from 'dojo-routing/createRoute';\nimport createRouter from 'dojo-routing/createRouter';\nimport { Parameters } from 'dojo-routing/interfaces';\nimport createHashHistory from 'dojo-routing/history/createHashHistory';\n\nimport { filter as filterAction } from './actions/userActions';\n\ninterface FilterParameters extends Parameters {\n\tfilter: 'active' | 'all' | 'completed';\n}\n\nconst filterRoute = createRoute<FilterParameters>({\n\tpath: '/{filter}',\n\n\tparams([filter]) {\n\t\tswitch (filter) {\n\t\t\tcase 'active':\n\t\t\t\treturn { filter: 'active' };\n\t\t\tcase 'all':\n\t\t\t\treturn { filter: 'all' };\n\t\t\tcase 'completed':\n\t\t\t\treturn { filter: 'completed' };\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t},\n\n\texec(request) {\n\t\tconst { filter } = request.params;\n\t\treturn filterAction.do({ filter });\n\t}\n});\n\nconst router = createRouter({ history: createHashHistory() });\nrouter.append(filterRoute);\n\nexport default router;\n\n\n\n// WEBPACK FOOTER //\n// ./src/routes.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented from 'dojo-compose/mixins/createEvented';\nimport global from 'dojo-core/global';\nimport on from 'dojo-core/on';\nimport WeakMap from 'dojo-shim/WeakMap';\n\nimport { History, HistoryOptions } from './interfaces';\n\n/**\n * A browser-based history manager that uses the location hash to store the current value.\n */\nexport type HashHistory = History;\n\n/**\n * Options for creating HashHistory instances.\n */\nexport interface HashHistoryOptions extends HistoryOptions {\n\t/**\n\t * A DOM window object. HashHistory uses the `location` property and\n\t * listens to `hashchange` events. The current value is initialized to the\n\t * initial hash.\n\t */\n\twindow: Window;\n}\n\nexport interface HashHistoryFactory extends ComposeFactory<HashHistory, HashHistoryOptions> {\n\t/**\n\t * Create a new HashHistory instance.\n\t * @param options Options to use during creation. If not specified the instance assumes\n\t *   the global object is a DOM window.\n\t */\n\t(options?: HashHistoryOptions): HashHistory;\n}\n\ninterface PrivateState {\n\tcurrent: string;\n\tbrowserLocation: Location;\n}\n\nconst privateStateMap = new WeakMap<HashHistory, PrivateState>();\n\nconst createHashHistory: HashHistoryFactory = compose.mixin(createEvented, {\n\tmixin: {\n\t\tget current(this: HashHistory) {\n\t\t\treturn privateStateMap.get(this).current;\n\t\t},\n\n\t\tprefix(path: string) {\n\t\t\treturn `#${path}`;\n\t\t},\n\n\t\tset(this: HashHistory, path: string) {\n\t\t\tconst privateState = privateStateMap.get(this);\n\t\t\tif (privateState.current === path) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprivateState.current = path;\n\t\t\tprivateState.browserLocation.hash = this.prefix(path);\n\t\t\tthis.emit({\n\t\t\t\ttype: 'change',\n\t\t\t\tvalue: path\n\t\t\t});\n\t\t},\n\n\t\treplace(this: HashHistory, path: string) {\n\t\t\tconst privateState = privateStateMap.get(this);\n\t\t\tif (privateState.current === path) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprivateState.current = path;\n\n\t\t\tconst { pathname, search } = privateState.browserLocation;\n\t\t\tprivateState.browserLocation.replace(pathname + search + this.prefix(path));\n\n\t\t\tthis.emit({\n\t\t\t\ttype: 'change',\n\t\t\t\tvalue: path\n\t\t\t});\n\t\t}\n\t},\n\tinitialize(instance: HashHistory, { window }: HashHistoryOptions = { window: global }) {\n\t\tconst { location: browserLocation } = window;\n\n\t\tconst privateState: PrivateState = {\n\t\t\tcurrent: browserLocation.hash.slice(1),\n\t\t\tbrowserLocation\n\t\t};\n\t\tprivateStateMap.set(instance, privateState);\n\n\t\tinstance.own(on(window, 'hashchange', () => {\n\t\t\tconst path = browserLocation.hash.slice(1);\n\n\t\t\t// Ignore hashchange for the current path. Guards against browsers firing hashchange when the history\n\t\t\t// manager sets the hash.\n\t\t\tif (path !== privateState.current) {\n\t\t\t\tprivateState.current = path;\n\t\t\t\tinstance.emit({\n\t\t\t\t\ttype: 'change',\n\t\t\t\t\tvalue: path\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\t}\n});\n\nexport default createHashHistory;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/history/createHashHistory.ts","import { Handle, EventObject } from 'dojo-interfaces/core';\nimport { createHandle, createCompositeHandle } from './lang';\nimport Evented from './Evented';\n\nexport interface EventCallback {\n\t(event: EventObject): void;\n}\n\nexport interface EventEmitter {\n\ton(event: string, listener: EventCallback): EventEmitter;\n\tremoveListener(event: string, listener: EventCallback): EventEmitter;\n}\n\ninterface DOMEventObject extends EventObject {\n\tbubbles: boolean;\n\tcancelable: boolean;\n}\n\n/**\n * Provides a normalized mechanism for dispatching events for event emitters, Evented objects, or DOM nodes.\n * @param target The target to emit the event from\n * @param event The event object to emit\n * @return Boolean indicating if preventDefault was called on the event object (only relevant for DOM events;\n *     always false for other event emitters)\n */\nexport function emit<T extends EventObject>(target: Evented | EventTarget | EventEmitter, event: T | EventObject): boolean;\nexport function emit<T extends EventObject>(target: any, event: T | EventObject): boolean {\n\tif (\n\t\ttarget.dispatchEvent && /* includes window and document */\n\t\t\t((target.ownerDocument && target.ownerDocument.createEvent) || /* matches nodes */\n\t\t\t(target.document && target.document.createEvent) || /* matches window */\n\t\t\ttarget.createEvent) /* matches document */\n\t) {\n\t\tconst nativeEvent = (target.ownerDocument || target.document || target).createEvent('HTMLEvents');\n\t\tnativeEvent.initEvent(\n\t\t\tevent.type,\n\t\t\tBoolean((<DOMEventObject> event).bubbles),\n\t\t\tBoolean((<DOMEventObject> event).cancelable)\n\t\t);\n\n\t\tfor (let key in event) {\n\t\t\tif (!(key in nativeEvent)) {\n\t\t\t\tnativeEvent[key] = (<any> event)[key];\n\t\t\t}\n\t\t}\n\n\t\treturn target.dispatchEvent(nativeEvent);\n\t}\n\n\tif (target.emit) {\n\t\tif (target.removeListener) {\n\t\t\t// Node.js EventEmitter\n\t\t\ttarget.emit(event.type, event);\n\t\t\treturn false;\n\t\t}\n\t\telse if (target.on) {\n\t\t\t// Dojo Evented or similar\n\t\t\ttarget.emit(event);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tthrow new Error('Target must be an event emitter');\n}\n\n/**\n * Provides a normalized mechanism for listening to events from event emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle which will remove the listener when destroy is called\n */\nexport default function on(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): Handle;\nexport default function on(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): Handle;\nexport default function on(target: any, type: any, listener: any, capture?: boolean): Handle {\n\tif (Array.isArray(type)) {\n\t\tlet handles: Handle[] = type.map(function (type: string): Handle {\n\t\t\treturn on(target, type, listener, capture);\n\t\t});\n\n\t\treturn createCompositeHandle(...handles);\n\t}\n\n\tconst callback = function (this: any) {\n\t\tlistener.apply(this, arguments);\n\t};\n\n\t// DOM EventTarget\n\tif (target.addEventListener && target.removeEventListener) {\n\t\ttarget.addEventListener(type, callback, capture);\n\t\treturn createHandle(function () {\n\t\t\ttarget.removeEventListener(type, callback, capture);\n\t\t});\n\t}\n\n\tif (target.on) {\n\t\t// EventEmitter\n\t\tif (target.removeListener) {\n\t\t\ttarget.on(type, callback);\n\t\t\treturn createHandle(function () {\n\t\t\t\ttarget.removeListener(type, callback);\n\t\t\t});\n\t\t}\n\t\t// Evented\n\t\telse if (target.emit) {\n\t\t\treturn target.on(type, listener);\n\t\t}\n\t}\n\n\tthrow new TypeError('Unknown event emitter object');\n}\n\n/**\n * Provides a mechanism for listening to the next occurrence of an event from event\n * emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may be a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle which will remove the listener when destroy is called\n */\nexport function once(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): Handle;\nexport function once(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): Handle;\nexport function once(target: any, type: any, listener: any, capture?: boolean): Handle {\n\t// FIXME\n\t// tslint:disable-next-line:no-var-keyword\n\tvar handle = on(target, type, function (this: any) {\n\t\thandle.destroy();\n\t\treturn listener.apply(this, arguments);\n\t}, capture);\n\n\treturn handle;\n}\n\nexport interface PausableHandle extends Handle {\n\tpause(): void;\n\tresume(): void;\n}\n\n/**\n * Provides a mechanism for creating pausable listeners for events from event emitters, Evented objects, or DOM nodes.\n * @param target Target to listen for event on\n * @param type Event event type(s) to listen for; may a string or an array of strings\n * @param listener Callback to handle the event when it fires\n * @param capture Whether the listener should be registered in the capture phase (DOM events only)\n * @return A handle with additional pause and resume methods; the listener will never fire when paused\n */\nexport function pausable(target: EventTarget, type: string | string[], listener: EventCallback, capture?: boolean): PausableHandle;\nexport function pausable(target: EventEmitter | Evented, type: string | string[], listener: EventCallback): PausableHandle;\nexport function pausable(target: any, type: any, listener: any, capture?: boolean): PausableHandle {\n\tlet paused: boolean;\n\n\tconst handle = <PausableHandle> on(target, type, function (this: any) {\n\t\tif (!paused) {\n\t\t\treturn listener.apply(this, arguments);\n\t\t}\n\t}, capture);\n\n\thandle.pause = function () {\n\t\tpaused = true;\n\t};\n\n\thandle.resume = function () {\n\t\tpaused = false;\n\t};\n\n\treturn handle;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/on.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, {\n\tEvented,\n\tEventedOptions,\n\tEventedListener,\n\tTargettedEventObject\n} from 'dojo-compose/mixins/createEvented';\nimport { Handle, Hash } from 'dojo-core/interfaces';\nimport Task from 'dojo-core/async/Task';\nimport { pausable, PausableHandle } from 'dojo-core/on';\nimport UrlSearchParams from 'dojo-core/UrlSearchParams';\nimport { includes } from 'dojo-shim/array';\nimport { Thenable } from 'dojo-shim/interfaces';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\n\nimport { Route, SearchParams, Selection } from './createRoute';\nimport { Context, Parameters, Request } from './interfaces';\nimport { History, HistoryChangeEvent } from './history/interfaces';\nimport { isNamedSegment, parse as parsePath } from './lib/path';\n\n/**\n * An object to resume or cancel router dispatch.\n */\nexport interface DispatchDeferral {\n\t/**\n\t * Call to prevent a path from being dispatched.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * Call to resume a path being dispatched.\n\t */\n\tresume(): void;\n}\n\n/**\n * Event object that is emitted for the 'navstart' event.\n */\nexport interface NavigationStartEvent extends TargettedEventObject {\n\t/**\n\t * The path that has been navigated to.\n\t */\n\tpath: string;\n\n\t/**\n\t * Call to prevent the path to be dispatched.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * Call to defer dispatching of the path\n\t * @return an object which allows the caller to resume or cancel dispatch.\n\t */\n\tdefer(): DispatchDeferral;\n\n\t/**\n\t * The router that emitted this event.\n\t */\n\ttarget: Router<Context>;\n}\n\n/**\n * Event object that is emitted for the 'error' event.\n */\nexport interface ErrorEvent<C extends Context> extends TargettedEventObject {\n\t/**\n\t * The context that was being dispatched when the error occurred.\n\t */\n\tcontext: C;\n\n\t/**\n\t * The error.\n\t */\n\terror: any;\n\n\t/**\n\t * The path that was being dispatched when the error occurred.\n\t */\n\tpath: string;\n\n\t/**\n\t * The router that emitted this event.\n\t */\n\ttarget: Router<C>;\n}\n\n/**\n * Describes the result of a dispatch.\n */\nexport interface DispatchResult {\n\t/**\n\t * Whether a route requested a redirect to a different path.\n\t */\n\tredirect?: string;\n\n\t/**\n\t * False if dispatch was canceled (via the navstart event) or if no routes could be selected. True otherwise.\n\t */\n\tsuccess: boolean;\n}\n\nexport type LinkParams = Hash<string | string[] | undefined>;\n\n/**\n * A router mixin.\n */\nexport interface RouterMixin<C extends Context> {\n\t/**\n\t * Append one or more routes.\n\t *\n\t * A route can only appended to another route, or a router itself, once.\n\t *\n\t * @param routes A single route or an array containing 0 or more routes.\n\t */\n\tappend(add: Route<Context, Parameters> | Route<Context, Parameters>[]): void;\n\n\t/**\n\t * Select and execute routes for a given path.\n\t * @param context A context object that is provided when executing selected routes.\n\t * @param path The path.\n\t */\n\tdispatch(context: C, path: string): Task<DispatchResult>;\n\n\t/**\n\t * Generate a link for the route.\n\t *\n\t * Route hierarchies may require parameters to be present. Parameters are automatically derived from the currently\n\t * selected routes. Errors are thrown if parameters are missing or if the route is not in this router's hierarchy.\n\t *\n\t * @\n\t */\n\tlink(route: Route<Context, Parameters>, params?: LinkParams): string;\n\n\t/**\n\t * Start the router.\n\t *\n\t * Observes the history manager provided when the router was created for change events and dispatches routes in\n\t * response. Noop if no history manager was provided.\n\t *\n\t * @param options An optional options object, can be used to prevent the router from immediately dispatching.\n\t */\n\tstart(options?: StartOptions): PausableHandle;\n}\n\nexport interface RouterOverrides<C extends Context> {\n\t/**\n\t * Event emitted when dispatch is called, but before routes are selected.\n\t */\n\ton(type: 'navstart', listener: EventedListener<NavigationStartEvent>): Handle;\n\n\t/**\n\t * Event emitted when errors occur during dispatch.\n\t *\n\t * Certain errors may reject the task returned when dispatching, but this task is not always accessible and may\n\t * hide errors if it's canceled.\n\t */\n\ton(type: 'error', listener: EventedListener<ErrorEvent<C>>): Handle;\n\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type Router<C extends Context> = Evented & RouterMixin<C> & RouterOverrides<C>;\n\n/**\n * The options for the router.\n */\nexport interface RouterOptions<C extends Context> extends EventedOptions {\n\t/**\n\t * A Context object to be used for all requests, or a function that provides such an object, called for each\n\t * dispatch.\n\t */\n\tcontext?: C | (() => C);\n\n\t/**\n\t * A handler called when no routes match the dispatch path.\n\t * @param request An object whose `context` property contains the dispatch context. No extracted parameters\n\t *   are available.\n\t */\n\tfallback?: (request: Request<C, Parameters>) => void | Thenable<any>;\n\n\t/**\n\t * The history manager. Routes will be dispatched in response to change events emitted by the manager.\n\t */\n\thistory?: History;\n}\n\n/**\n * The options for the router's start() method.\n */\nexport interface StartOptions {\n\t/**\n\t * Whether to immediately dispatch with the history's current value.\n\t */\n\tdispatchCurrent: boolean;\n}\n\nexport interface RouterFactory<C extends Context> extends ComposeFactory<Router<C>, RouterOptions<C>> {\n\t/**\n\t * Create a new instance of a Router.\n\t * @param options Options to use during creation.\n\t */\n\t(options?: RouterOptions<Context>): Router<Context>;\n\t<C>(options?: RouterOptions<C>): Router<C>;\n}\n\nconst parentMap = new WeakMap<Route<Context, Parameters>, Router<Context>>();\nexport function hasBeenAppended(route: Route<Context, Parameters>): boolean {\n\treturn parentMap.has(route) || route.parent !== undefined;\n}\n\ninterface PrivateState {\n\tcontextFactory: () => Context;\n\tcurrentSelection: Selection[];\n\tdispatchFromStart: boolean;\n\tfallback?: (request: Request<Context, Parameters>) => void | Thenable<any>;\n\thistory?: History;\n\troutes: Route<Context, Parameters>[];\n\tstarted?: boolean;\n}\n\nconst privateStateMap = new WeakMap<Router<Context>, PrivateState>();\n\n// istanbul ignore next\nconst noop = () => {};\n\nfunction createDeferral() {\n\t// Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.\n\tlet cancel: () => void = noop;\n\tlet resume: () => void = noop;\n\tconst promise = new Promise<void>((resolve, reject) => {\n\t\tcancel = reject;\n\t\t// Wrap resolve to avoid resume being called with a thenable if type checking is not used.\n\t\tresume = () => resolve();\n\t});\n\treturn { cancel, promise, resume };\n}\n\nfunction reportError(router: Router<Context>, context: Context, path: string, error: any) {\n\trouter.emit<ErrorEvent<Context>>({\n\t\tcontext,\n\t\terror,\n\t\tpath,\n\t\ttarget: router,\n\t\ttype: 'error'\n\t});\n}\n\nfunction catchRejection(router: Router<Context>, context: Context, path: string, thenable: void | Thenable<any>) {\n\tif (thenable) {\n\t\tPromise.resolve(thenable).catch((error) => {\n\t\t\treportError(router, context, path, error);\n\t\t});\n\t}\n}\n\nconst createRouter: RouterFactory<Context> = compose.mixin(createEvented, {\n\tmixin: {\n\t\tappend(this: Router<Context>, add: Route<Context, Parameters> | Route<Context, Parameters>[]) {\n\t\t\tconst { routes } = privateStateMap.get(this);\n\t\t\tconst append = (route: Route<Context, Parameters>) => {\n\t\t\t\tif (hasBeenAppended(route)) {\n\t\t\t\t\tthrow new Error('Cannot append route that has already been appended');\n\t\t\t\t}\n\n\t\t\t\troutes.push(route);\n\t\t\t\tparentMap.set(route, this);\n\t\t\t};\n\n\t\t\tif (Array.isArray(add)) {\n\t\t\t\tfor (const route of add) {\n\t\t\t\t\tappend(route);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tappend(add);\n\t\t\t}\n\t\t},\n\n\t\tdispatch(this: Router<Context>, context: Context, path: string): Task<DispatchResult> {\n\t\t\tconst state = privateStateMap.get(this);\n\t\t\tconst { dispatchFromStart } = state;\n\t\t\t// Reset, any further calls can't have come from start(). This is necessary since the navstart listeners\n\t\t\t// may call dispatch() themselves.\n\t\t\tstate.dispatchFromStart = false;\n\n\t\t\tlet canceled = false;\n\t\t\tconst cancel = () => {\n\t\t\t\tcanceled = true;\n\t\t\t};\n\n\t\t\tconst deferrals: Promise<void>[] = [];\n\n\t\t\tthis.emit<NavigationStartEvent>({\n\t\t\t\tcancel,\n\t\t\t\tdefer () {\n\t\t\t\t\tconst { cancel, promise, resume } = createDeferral();\n\t\t\t\t\tdeferrals.push(promise);\n\t\t\t\t\treturn { cancel, resume };\n\t\t\t\t},\n\t\t\t\tpath,\n\t\t\t\ttarget: this,\n\t\t\t\ttype: 'navstart'\n\t\t\t});\n\n\t\t\t// Synchronous cancelation.\n\t\t\tif (canceled) {\n\t\t\t\treturn Task.resolve({ success: false });\n\t\t\t}\n\n\t\t\tconst { searchParams, segments, trailingSlash } = parsePath(path);\n\t\t\treturn new Task<DispatchResult>((resolve, reject) => {\n\t\t\t\t// *Always* start dispatching in a future turn, even if there were no deferrals.\n\t\t\t\tPromise.all(deferrals).then<DispatchResult>(\n\t\t\t\t\t() => {\n\t\t\t\t\t\t// The cancel() function used in the NavigationStartEvent is reused as the Task canceler.\n\t\t\t\t\t\t// Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it\n\t\t\t\t\t\t// manages to do so before this turn.\n\t\t\t\t\t\tif (canceled) {\n\t\t\t\t\t\t\treturn { success: false };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst { fallback, routes } = state;\n\t\t\t\t\t\tlet redirect: undefined | string;\n\t\t\t\t\t\tconst dispatched = routes.some((route) => {\n\t\t\t\t\t\t\tconst result = route.select(context, segments, trailingSlash, searchParams);\n\n\t\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\t\tredirect = result;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (result.length === 0) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update the selected routes after selecting new routes, but before invoking the handlers.\n\t\t\t\t\t\t\t// This means the original value is available to guard() and params() functions, and the\n\t\t\t\t\t\t\t// new value when the newly selected routes are executed.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// Reset selected routes if not dispatched from start().\n\t\t\t\t\t\t\tstate.currentSelection = dispatchFromStart ? result : [];\n\n\t\t\t\t\t\t\tfor (const { handler, params } of result) {\n\t\t\t\t\t\t\t\tcatchRejection(this, context, path, handler({ context, params }));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.\n\t\t\t\t\t\tif (!dispatched || redirect !== undefined) {\n\t\t\t\t\t\t\tstate.currentSelection = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!dispatched && fallback) {\n\t\t\t\t\t\t\tcatchRejection(this, context, path, fallback({ context, params: {} }));\n\t\t\t\t\t\t\treturn { success: false };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result: DispatchResult = { success: dispatched };\n\t\t\t\t\t\tif (redirect !== undefined) {\n\t\t\t\t\t\t\tresult.redirect = redirect;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t},\n\t\t\t\t\t// When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves\n\t\t\t\t\t// with `false` instead of being rejected too.\n\t\t\t\t\t() => {\n\t\t\t\t\t\treturn { success: false };\n\t\t\t\t\t}\n\t\t\t\t).then(resolve, (error) => {\n\t\t\t\t\treportError(this, context, path, error);\n\t\t\t\t\treject(error);\n\t\t\t\t});\n\t\t\t}, cancel);\n\t\t},\n\n\t\tlink(this: Router<Context>, route: Route<Context, Parameters>, params: LinkParams = {}): string {\n\t\t\tconst { history, routes: roots, currentSelection } = privateStateMap.get(this);\n\n\t\t\tconst hierarchy = [ route ];\n\t\t\tfor (let parent = route.parent; parent !== undefined; parent = parent.parent) {\n\t\t\t\thierarchy.unshift(parent);\n\t\t\t}\n\n\t\t\tif (!includes(roots, hierarchy[0])) {\n\t\t\t\tthrow new Error('Cannot generate link for route that is not in the hierarchy');\n\t\t\t}\n\n\t\t\tconst { leadingSlash: addLeadingSlash } = hierarchy[0].path;\n\t\t\tlet addTrailingSlash = false;\n\t\t\tconst segments: string[] = [];\n\t\t\tconst searchParams = new UrlSearchParams();\n\n\t\t\thierarchy\n\t\t\t\t.map((route, index) => {\n\t\t\t\t\tconst { path } = route;\n\t\t\t\t\tlet currentPathValues: string[] | undefined;\n\t\t\t\t\tlet currentSearchParams: SearchParams | undefined;\n\n\t\t\t\t\tconst selection = currentSelection[index];\n\t\t\t\t\tif (selection && selection.route === route) {\n\t\t\t\t\t\tcurrentPathValues = selection.rawPathValues;\n\t\t\t\t\t\tcurrentSearchParams = selection.rawSearchParams;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { currentPathValues, currentSearchParams, path };\n\t\t\t\t})\n\t\t\t\t.forEach(({ currentPathValues, currentSearchParams, path }) => {\n\t\t\t\t\tconst { expectedSegments, searchParameters, trailingSlash } = path;\n\t\t\t\t\taddTrailingSlash = trailingSlash;\n\n\t\t\t\t\tlet namedOffset = 0;\n\t\t\t\t\tfor (const segment of expectedSegments) {\n\t\t\t\t\t\tif (isNamedSegment(segment)) {\n\t\t\t\t\t\t\tconst value = params[segment.name];\n\t\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\t\tsegments.push(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (Array.isArray(value)) {\n\t\t\t\t\t\t\t\tif (value.length === 1) {\n\t\t\t\t\t\t\t\t\tsegments.push(value[0]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(`Cannot generate link, multiple values for parameter '${segment.name}'`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (currentPathValues) {\n\t\t\t\t\t\t\t\tsegments.push(currentPathValues[namedOffset]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow new Error(`Cannot generate link, missing parameter '${segment.name}'`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnamedOffset++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tsegments.push(segment.literal);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const key of searchParameters) {\n\t\t\t\t\t\t// Don't repeat the search parameter if a previous route in the hierarchy has already appended\n\t\t\t\t\t\t// it.\n\t\t\t\t\t\tif (searchParams.has(key)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst value = params[key];\n\t\t\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\t\t\tsearchParams.append(key, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (Array.isArray(value)) {\n\t\t\t\t\t\t\tfor (const item of value) {\n\t\t\t\t\t\t\t\tsearchParams.append(key, item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (currentSearchParams) {\n\t\t\t\t\t\t\tfor (const item of currentSearchParams[key]) {\n\t\t\t\t\t\t\t\tsearchParams.append(key, item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthrow new Error(`Cannot generate link, missing search parameter '${key}'`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tlet pathname = segments.join('/');\n\t\t\tif (addLeadingSlash) {\n\t\t\t\tpathname = '/' + pathname;\n\t\t\t}\n\t\t\tif (addTrailingSlash) {\n\t\t\t\tpathname += '/';\n\t\t\t}\n\t\t\tif (history) {\n\t\t\t\tpathname = history.prefix(pathname);\n\t\t\t}\n\n\t\t\tconst search = searchParams.toString();\n\t\t\tconst path = search ? `${pathname}?${search}` : pathname;\n\n\t\t\treturn path;\n\t\t},\n\n\t\tstart(this: Router<Context>, { dispatchCurrent }: StartOptions = { dispatchCurrent: true }): PausableHandle {\n\t\t\tconst state = privateStateMap.get(this);\n\t\t\tif (state.started) {\n\t\t\t\tthrow new Error('start can only be called once');\n\t\t\t}\n\t\t\tstate.started = true;\n\n\t\t\tconst { contextFactory, history } = state;\n\t\t\tif (!history) {\n\t\t\t\treturn {\n\t\t\t\t\tpause() {},\n\t\t\t\t\tresume() {},\n\t\t\t\t\tdestroy() {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlet lastDispatch: Task<void>;\n\t\t\tlet redirectCount = 0;\n\t\t\tlet redirecting = false;\n\n\t\t\tconst dispatch = (path: string) => {\n\t\t\t\tif (lastDispatch) {\n\t\t\t\t\tlastDispatch.cancel();\n\t\t\t\t}\n\n\t\t\t\t// Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows\n\t\t\t\t// a route's exec / fallback / index handler to change the history, setting off a new flurry of\n\t\t\t\t// redirects, without being encumbered by the number of redirects that led to that route being selected.\n\t\t\t\tif (!redirecting) {\n\t\t\t\t\tredirectCount = 0;\n\t\t\t\t}\n\n\t\t\t\t// Signal to dispatch() that it was called from here.\n\t\t\t\tstate.dispatchFromStart = true;\n\n\t\t\t\tconst context = contextFactory();\n\t\t\t\tlastDispatch = this.dispatch(context, path).then(({ redirect, success }) => {\n\t\t\t\t\tif (success && redirect !== undefined) {\n\t\t\t\t\t\tredirectCount++;\n\t\t\t\t\t\tif (redirectCount > 20) {\n\t\t\t\t\t\t\tconst error = new Error('More than 20 redirects, giving up');\n\t\t\t\t\t\t\treportError(this, context, path, error);\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tredirecting = true;\n\t\t\t\t\t\t// The history manager MUST emit the change event synchronously.\n\t\t\t\t\t\thistory.replace(redirect);\n\t\t\t\t\t\tredirecting = false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tconst listener = pausable(history, 'change', (event: HistoryChangeEvent) => {\n\t\t\t\tdispatch(event.value);\n\t\t\t});\n\t\t\tthis.own(listener);\n\n\t\t\tif (dispatchCurrent) {\n\t\t\t\tdispatch(history.current);\n\t\t\t}\n\n\t\t\treturn listener;\n\t\t}\n\t},\n\tinitialize<C extends Context>(instance: Router<C>, { context, fallback, history }: RouterOptions<C> = {}) {\n\t\tlet contextFactory: () => C;\n\t\tif (typeof context === 'function') {\n\t\t\tcontextFactory = context;\n\t\t}\n\t\telse if (typeof context === 'undefined') {\n\t\t\tcontextFactory = () => {\n\t\t\t\treturn {} as C;\n\t\t\t};\n\t\t}\n\t\telse {\n\t\t\t// Assign to a constant since the context variable may be changed after the function is defined,\n\t\t\t// which would violate its typing.\n\t\t\tconst sharedContext = context;\n\t\t\tcontextFactory = () => sharedContext;\n\t\t}\n\n\t\tif (history) {\n\t\t\tinstance.own(history);\n\t\t}\n\n\t\tprivateStateMap.set(instance, {\n\t\t\tcontextFactory,\n\t\t\tcurrentSelection: [],\n\t\t\tdispatchFromStart: false,\n\t\t\tfallback,\n\t\t\thistory,\n\t\t\troutes: []\n\t\t});\n\t}\n});\n\nexport default createRouter;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/createRouter.ts","import { Hash } from 'dojo-interfaces/core';\nimport { duplicate } from './lang';\n\n/**\n * Object with string keys and string or string array values that describes a query string.\n */\nexport type ParamList = Hash<string | string[]>;\n\n/**\n * Parses a query string, returning a ParamList object.\n */\nfunction parseQueryString(input: string): ParamList {\n\tconst query: Hash<string[]> = {};\n\tfor (const entry of input.split('&')) {\n\t\tconst indexOfFirstEquals = entry.indexOf('=');\n\t\tlet key: string;\n\t\tlet value = '';\n\n\t\tif (indexOfFirstEquals >= 0) {\n\t\t\tkey = entry.slice(0, indexOfFirstEquals);\n\t\t\tvalue = entry.slice(indexOfFirstEquals + 1);\n\t\t} else {\n\t\t\tkey = entry;\n\t\t}\n\n\t\tkey = key ? decodeURIComponent(key) : '';\n\t\tvalue = value ? decodeURIComponent(value) : '';\n\n\t\tif (key in query) {\n\t\t\tquery[key].push(value);\n\t\t}\n\t\telse {\n\t\t\tquery[key] = [ value ];\n\t\t}\n\t}\n\treturn query;\n}\n\n/**\n * Represents a set of URL query search parameters.\n */\nexport default class UrlSearchParams {\n\t/**\n\t * Constructs a new UrlSearchParams from a query string, an object of parameters and values, or another\n\t * UrlSearchParams.\n\t */\n\tconstructor(input?: string | ParamList | UrlSearchParams) {\n\t\tlet list: ParamList;\n\n\t\tif (input instanceof UrlSearchParams) {\n\t\t\t// Copy the incoming UrlSearchParam's internal list\n\t\t\tlist = <ParamList> duplicate(input._list);\n\t\t}\n\t\telse if (typeof input === 'object') {\n\t\t\t// Copy the incoming object, assuming its property values are either arrays or strings\n\t\t\tlist = {};\n\t\t\tfor (const key in input) {\n\t\t\t\tconst value = (<ParamList> input)[key];\n\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tlist[key] = value.length ? value.slice() : [ '' ];\n\t\t\t\t}\n\t\t\t\telse if (value == null) {\n\t\t\t\t\tlist[key] = [ '' ];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlist[key] = [ <string> value ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof input === 'string') {\n\t\t\t// Parse the incoming string as a query string\n\t\t\tlist = parseQueryString(input);\n\t\t}\n\t\telse {\n\t\t\tlist = {};\n\t\t}\n\n\t\tObject.defineProperty(this, '_list', { value: list });\n\t}\n\n\t/**\n\t * Maps property keys to arrays of values. The value for any property that has been set will be an array containing\n\t * at least one item. Properties that have been deleted will have a value of 'undefined'.\n\t */\n\tprotected _list: Hash<string[] | undefined>;\n\n\t/**\n\t * Appends a new value to the set of values for a key.\n\t * @param key The key to add a value for\n\t * @param value The value to add\n\t */\n\tappend(key: string, value: string): void {\n\t\tif (!this.has(key)) {\n\t\t\tthis.set(key, value);\n\t\t}\n\t\telse {\n\t\t\tconst values = this._list[key];\n\t\t\tif (values) {\n\t\t\t\tvalues.push(value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Deletes all values for a key.\n\t * @param key The key whose values are to be removed\n\t */\n\tdelete(key: string): void {\n\t\t// Set to undefined rather than deleting the key, for better consistency across browsers.\n\t\t// If a deleted key is re-added, most browsers put it at the end of iteration order, but IE maintains\n\t\t// its original position.  This approach maintains the original position everywhere.\n\t\tthis._list[key] = undefined;\n\t}\n\n\t/**\n\t * Returns the first value associated with a key.\n\t * @param key The key to return the first value for\n\t * @return The first string value for the key\n\t */\n\tget(key: string): string | undefined {\n\t\tif (!this.has(key)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst value = this._list[key];\n\t\treturn value ? value[0] : undefined;\n\t}\n\n\t/**\n\t * Returns all the values associated with a key.\n\t * @param key The key to return all values for\n\t * @return An array of strings containing all values for the key\n\t */\n\tgetAll(key: string): string[] | undefined {\n\t\tif (!this.has(key)) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this._list[key];\n\t}\n\n\t/**\n\t * Returns true if a key has been set to any value, false otherwise.\n\t * @param key The key to test for existence\n\t * @return A boolean indicating if the key has been set\n\t */\n\thas(key: string): boolean {\n\t\treturn Array.isArray(this._list[key]);\n\t}\n\n\t/**\n\t * Returns an array of all keys which have been set.\n\t * @return An array of strings containing all keys set in the UrlSearchParams instance\n\t */\n\tkeys(): string[] {\n\t\tconst keys: string[] = [];\n\n\t\tfor (const key in this._list) {\n\t\t\tif (this.has(key)) {\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n\n\t/**\n\t * Sets the value associated with a key.\n\t * @param key The key to set the value of\n\t */\n\tset(key: string, value: string): void {\n\t\tthis._list[key] = [ value ];\n\t}\n\n\t/**\n\t * Returns this object's data as an encoded query string.\n\t * @return A string in application/x-www-form-urlencoded format containing all of the set keys/values\n\t */\n\ttoString(): string {\n\t\tconst query: string[] = [];\n\n\t\tfor (const key in this._list) {\n\t\t\tif (!this.has(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst values = this._list[key];\n\t\t\tif (values) {\n\t\t\t\tconst encodedKey = encodeURIComponent(key);\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tquery.push(encodedKey + (value ? ('=' + encodeURIComponent(value)) : ''));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn query.join('&');\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/UrlSearchParams.ts","import UrlSearchParams from 'dojo-core/UrlSearchParams';\n\nexport interface ParsedPath {\n\t/**\n\t * Parameters extracted from the search component.\n\t */\n\tsearchParams: UrlSearchParams;\n\n\t/**\n\t * Pathname segments.\n\t */\n\tsegments: string[];\n\n\t/**\n\t * Whether the pathname ended with a trailing slash.\n\t */\n\ttrailingSlash: boolean;\n}\n\n/**\n * Parses a path\n * @param path The path to parse.\n * @return The search params, pathname segments, and whether it ended with a trailing slash.\n */\nexport function parse(path: string): ParsedPath {\n\tconst tokens: string[] = path.split(/([/?#])/).filter(Boolean);\n\n\tlet pathnameTokens = tokens;\n\tlet searchParams: UrlSearchParams;\n\n\tconst searchStart = tokens.indexOf('?');\n\tconst hashStart = tokens.indexOf('#');\n\tif (searchStart >= 0) {\n\t\tif (hashStart >= 0) {\n\t\t\t// Either `/foo?bar#baz` or `/foo#bar?baz`\n\t\t\tpathnameTokens = tokens.slice(0, Math.min(searchStart, hashStart));\n\t\t\tsearchParams = new UrlSearchParams(tokens.slice(searchStart + 1, hashStart).join(''));\n\t\t}\n\t\telse {\n\t\t\t// `/foo?bar`\n\t\t\tpathnameTokens = tokens.slice(0, searchStart);\n\t\t\tsearchParams = new UrlSearchParams(tokens.slice(searchStart + 1).join(''));\n\t\t}\n\t}\n\telse {\n\t\tsearchParams = new UrlSearchParams();\n\t\tif (hashStart >= 0) {\n\t\t\t// `/foo#bar`\n\t\t\tpathnameTokens = tokens.slice(0, hashStart);\n\t\t}\n\t}\n\n\tconst segments = pathnameTokens.filter(t => t !== '/');\n\tconst trailingSlash = pathnameTokens[pathnameTokens.length - 1] === '/' && segments.length > 0;\n\n\treturn {\n\t\tsearchParams,\n\t\tsegments,\n\t\ttrailingSlash\n\t};\n}\n\nexport interface MatchResult {\n\t/**\n\t * Whether there are remaining segments that weren't matched.\n\t */\n\thasRemaining: boolean;\n\n\t/**\n\t * Position in the segments array that the remaining unmatched segments start.\n\t */\n\toffset: number;\n\n\t/**\n\t * Values for named segments.\n\t */\n\tvalues: string[];\n}\n\n/**\n * Determines whether a DeconstructedPath is a (partial) match for given pathname segments.\n * @param expectedSegments Part of a DeconstructedPath object.\n * @param segments Pathname segments as returned by `parse()`\n * @return A result object.\n */\nexport function match({ expectedSegments }: DeconstructedPath, segments: string[]): MatchResult | null {\n\tif (expectedSegments.length === 0) {\n\t\treturn {\n\t\t\thasRemaining: segments.length > 0,\n\t\t\toffset: 0,\n\t\t\tvalues: []\n\t\t};\n\t}\n\n\tif (expectedSegments.length > segments.length) {\n\t\treturn null;\n\t}\n\n\tlet isMatch = true;\n\tconst values: string[] = [];\n\tfor (let i = 0; isMatch && i < expectedSegments.length; i++) {\n\t\tconst value = segments[i];\n\t\tconst expected = expectedSegments[i];\n\t\tif (isNamedSegment(expected)) {\n\t\t\tvalues.push(value);\n\t\t}\n\t\telse if (expected.literal !== value) {\n\t\t\tisMatch = false;\n\t\t}\n\t}\n\n\tif (!isMatch) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\thasRemaining: expectedSegments.length < segments.length,\n\t\toffset: expectedSegments.length,\n\t\tvalues\n\t};\n}\n\nexport interface LiteralSegment {\n\tliteral: string;\n}\n\nexport interface NamedSegment {\n\tname: string;\n}\n\nexport type Segment = LiteralSegment | NamedSegment;\n\n/**\n * Determine whether the segment is a NamedSegment.\n *\n * @param segment The segment to be checked\n * @return true if the segment is a NamedSegment, false otherwise\n */\nexport function isNamedSegment(segment: Segment): segment is NamedSegment {\n\treturn (<NamedSegment> segment).name !== undefined;\n}\n\n/**\n * Describes a route path, broken down into its constituent parts.\n */\nexport interface DeconstructedPath {\n\t/**\n\t * Segments (literal and named) that are expected to be present when matching paths.\n\t */\n\texpectedSegments: Segment[];\n\n\t/**\n\t * Whether the pathname started with a slash.\n\t */\n\tleadingSlash: boolean;\n\n\t/**\n\t * Named path parameters, in the order that they occurred in the path.\n\t */\n\tparameters: string[];\n\n\t/**\n\t * Named query parameters, in the order that they occurred in the path.\n\t */\n\tsearchParameters: string[];\n\n\t/**\n\t * Whether the pathname ended with a slash.\n\t */\n\ttrailingSlash: boolean;\n}\n\n/**\n * Deconstruct a route path into its constituent parts.\n * @param path The path to deconstruct.\n * @return An object describing the path's constituent parts.\n */\nexport function deconstruct(path: string): DeconstructedPath {\n\tconst expectedSegments: Segment[] = [];\n\tconst parameters: string[] = [];\n\tconst searchParameters: string[] = [];\n\tlet trailingSlash = false;\n\n\tconst tokens = path.split(/([/{}?&])/).filter(Boolean);\n\tconst leadingSlash = tokens[0] === '/';\n\n\tlet i = 0;\n\tconst consume = () => tokens[i++];\n\tconst peek = () => tokens[i];\n\n\tlet inSearchComponent = false;\n\twhile (i < tokens.length) {\n\t\tconst t = consume();\n\n\t\tswitch (t) {\n\t\t\tcase '{': {\n\t\t\t\tconst name = consume();\n\t\t\t\tif (!name || name === '}') {\n\t\t\t\t\tthrow new TypeError('Parameter must have a name');\n\t\t\t\t}\n\t\t\t\t// Reserve : for future use, e.g. including type data in the parameter declaration.\n\t\t\t\tif (name === '{' || name === '&' || /:/.test(name)) {\n\t\t\t\t\tthrow new TypeError('Parameter name must not contain \\'{\\', \\'&\\' or \\':\\'');\n\t\t\t\t}\n\t\t\t\tif (parameters.indexOf(name) !== -1 || searchParameters.indexOf(name) !== -1) {\n\t\t\t\t\tthrow new TypeError(`Parameter must have a unique name, got '${name}'`);\n\t\t\t\t}\n\n\t\t\t\tconst closing = consume();\n\t\t\t\tif (!closing || closing !== '}') {\n\t\t\t\t\tthrow new TypeError(`Parameter name must be followed by '}', got '${closing}'`);\n\t\t\t\t}\n\n\t\t\t\tconst separator = peek();\n\t\t\t\tif (separator) {\n\t\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\t\tif (separator !== '&') {\n\t\t\t\t\t\t\tthrow new TypeError(`Search parameter must be followed by '&', got '${separator}'`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (separator !== '/' && separator !== '?') {\n\t\t\t\t\t\tthrow new TypeError(`Parameter must be followed by '/' or '?', got '${separator}'`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tsearchParameters.push(name);\n\t\t\t\t} else {\n\t\t\t\t\tparameters.push(name);\n\t\t\t\t\texpectedSegments.push(Object.freeze({ name }));\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase '?':\n\t\t\tcase '/':\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tthrow new TypeError(`Expected parameter in search component, got '${t}'`);\n\t\t\t\t}\n\n\t\t\t\tif (t === '?') {\n\t\t\t\t\tinSearchComponent = true;\n\t\t\t\t\tif (expectedSegments.length === 0) {\n\t\t\t\t\t\tthrow new TypeError('Path must contain at least one segment');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (t === '/') {\n\t\t\t\t\tconst next = peek();\n\t\t\t\t\tif (next === '/') {\n\t\t\t\t\t\tthrow new TypeError('Path segment must not be empty');\n\t\t\t\t\t}\n\t\t\t\t\tif (expectedSegments.length > 0 && (!next || next === '?')) {\n\t\t\t\t\t\ttrailingSlash = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tif (!inSearchComponent) {\n\t\t\t\t\tthrow new TypeError('Path segment must not contain \\'&\\'');\n\t\t\t\t}\n\n\t\t\t\tconst next = peek();\n\t\t\t\tif (next === '&') {\n\t\t\t\t\tthrow new TypeError('Expected parameter in search component, got \\'&\\'');\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tif (inSearchComponent) {\n\t\t\t\t\tthrow new TypeError(`Expected parameter in search component, got '${t}'`);\n\t\t\t\t}\n\n\t\t\t\texpectedSegments.push(Object.freeze({ literal: t }));\n\t\t}\n\t}\n\n\treturn Object.freeze({\n\t\texpectedSegments: Object.freeze(expectedSegments),\n\t\tleadingSlash,\n\t\tparameters: Object.freeze(parameters),\n\t\tsearchParameters: Object.freeze(searchParameters),\n\t\ttrailingSlash\n\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/lib/path.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport UrlSearchParams from 'dojo-core/UrlSearchParams';\nimport { Hash } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Thenable } from 'dojo-shim/interfaces';\n\nimport { DefaultParameters, Context, Parameters, Request } from './interfaces';\nimport { hasBeenAppended } from './createRouter';\nimport {\n\tdeconstruct as deconstructPath,\n\tmatch as matchPath,\n\tDeconstructedPath\n} from './lib/path';\n\n/**\n * Hash object where keys are parameter names and keys are arrays of one or more\n * parameter values.\n */\nexport type SearchParams = Hash<string[]>;\n\n/**\n * Describes whether a route matched.\n */\nexport interface MatchResult<P> {\n\t/**\n\t * Whether there are path segments that weren't matched by this route.\n\t */\n\thasRemaining: boolean;\n\n\t/**\n\t * Position in the segments array that the remaining unmatched segments start.\n\t */\n\toffset: number;\n\n\t/**\n\t * Any extracted parameters. Only available if the route matched.\n\t */\n\tparams: P;\n\n\t/**\n\t * Values for named segments in the path, in order of occurrence.\n\t */\n\trawPathValues: string[];\n\n\t/**\n\t * Values for known named query parameters that were actually present in the\n\t * path.\n\t */\n\trawSearchParams: SearchParams;\n}\n\n/**\n * A request handler.\n */\nexport type Handler = (request: Request<Context, Parameters>) => void | Thenable<any>;\n\n/**\n * Describes the selection of a particular route.\n */\nexport interface Selection {\n\t/**\n\t * Which handler should be called when the route is executed.\n\t */\n\thandler: Handler;\n\n\t/**\n\t * The selected path.\n\t */\n\tpath: DeconstructedPath;\n\n\t/**\n\t * The extracted parameters.\n\t */\n\tparams: Parameters;\n\n\t/**\n\t * Values for named segments in the path, in order of occurrence.\n\t */\n\trawPathValues: string[];\n\n\t/**\n\t * Values for known named query parameters that were actually present in the\n\t * path.\n\t */\n\trawSearchParams: SearchParams;\n\n\t/**\n\t * The selected route.\n\t */\n\troute: Route<Context, Parameters>;\n}\n\n/**\n * A route.\n * The generic should be specified if parameter access is required.\n */\nexport interface Route<C extends Context, P extends Parameters> {\n\t/**\n\t * The route this route has been appended to.\n\t */\n\treadonly parent?: Route<Context, Parameters>;\n\n\t/**\n\t * Frozen, deconstructed path object.\n\t */\n\treadonly path: DeconstructedPath;\n\n\t/**\n\t * Append one or more routes.\n\t *\n\t * A route can only appended to another route, or a router itself, once.\n\t *\n\t * @param routes A single route or an array containing 0 or more routes.\n\t */\n\tappend(add: Route<Context, Parameters> | Route<Context, Parameters>[]): void;\n\n\t/**\n\t * Determine whether the route matches.\n\t * @param segments Segments of the pathname (excluding slashes).\n\t * @param hasTrailingSlash Whether the pathname that's being matched ended with a slashes.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return Whether and how the route matched.\n\t */\n\tmatch(segments: string[], hasTrailingSlash: boolean, searchParams: UrlSearchParams): null | MatchResult<P>;\n\n\t/**\n\t * Attempt to select this and any nested routes.\n\t * @param context The dispatch context.\n\t * @param segments Segments of the pathname (excluding slashes).\n\t * @param hasTrailingSlash Whether the pathname that's being matched ended with a slashes.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return A string if a matching route determined a redirect is necessary. The string should be the path to\n\t *   redirect to. Otherwise an empty array if this (and any nested routes) could not be selected, else the selected\n\t *   routes and accompanying `params` objects.\n\t */\n\tselect(\n\t\tcontext: Context,\n\t\tsegments: string[],\n\t\thasTrailingSlash: boolean,\n\t\tsearchParams: UrlSearchParams\n\t): string | Selection[];\n}\n\n/**\n * The options for the route.\n */\nexport interface RouteOptions<C, P> {\n\t/**\n\t * Path the route matches against. Pathname segments may be named, same for query parameters. Leading slashes are\n\t * ignored. Defaults to `/`.\n\t */\n\tpath?: string;\n\n\t/**\n\t * If the `path` option contains a trailing slash (in the pathname component), the route will only match against\n\t * another pathname that contains a trailing slash, and vice-versa if the path does not contain a trailing slash.\n\t * Defaults to `true`, change to `false` to allow routes to match regardless of trailing slashes.\n\t */\n\ttrailingSlashMustMatch?: boolean;\n\n\t/**\n\t * A handler called when the route is executed.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\texec?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * If specified, causes the route to be selected if there are no nested routes that match the remainder of\n\t * the dispatched path. When the route is executed, this handler is called rather than `exec()`.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\tfallback?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * Callback used to determine whether the route should be selected after it's been matched.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t * @return Returning `true` causes the route to be selected. Returning a string indicates that a redirect is\n\t *   required; the string should be the path to redirect to.\n\t */\n\tguard?(request: Request<C, P>): string | boolean;\n\n\t/**\n\t * If specified, and the route is the final route in the hierarchy, when the route is executed, this handler is\n\t * called rather than `exec()`.\n\t * @param request An object whose `context` property contains the dispatch context. Extracted parameters are\n\t *   available under `params`.\n\t */\n\tindex?(request: Request<C, P>): void | Thenable<any>;\n\n\t/**\n\t * Callback used for constructing the `params` object from extracted parameters, and validating the parameters.\n\t * @param fromPathname Array of parameter values extracted from the pathname.\n\t * @param searchParams Parameters extracted from the search component.\n\t * @return If `null` prevents the route from being selected, else the value for the `params` object.\n\t */\n\tparams?(fromPathname: string[], searchParams: UrlSearchParams): null | P;\n}\n\nexport interface RouteFactory<C extends Context, P extends Parameters> extends ComposeFactory<Route<C, P>, RouteOptions<C, P>> {\n\t/**\n\t * Create a new instance of a route.\n\t * @param options Options to use during creation.\n\t */\n\t<P>(options?: RouteOptions<Context, P>): Route<Context, P>;\n\t<C, P>(options?: RouteOptions<C, P>): Route<C, P>;\n}\n\ninterface PrivateState {\n\tpath: DeconstructedPath;\n\troutes: Route<Context, Parameters>[];\n\ttrailingSlashMustMatch: boolean;\n\n\tcomputeParams<P extends Parameters>(fromPathname: string[], searchParams: UrlSearchParams): null | P;\n\texec?: Handler;\n\tfallback?: Handler;\n\tguard?(request: Request<Context, Parameters>): string | boolean;\n\tindex?: Handler;\n}\n\nconst privateStateMap = new WeakMap<Route<Context, Parameters>, PrivateState>();\n\n// Store parent relationships in a separate map, since it's the parent that adds entries to this map. Parents shouldn't\n// change the private state of their children.\nconst parentMap = new WeakMap<Route<Context, Parameters>, Route<Context, Parameters>>();\n\nconst noop = () => {};\n\nfunction computeDefaultParams(\n\tparameters: string[],\n\tsearchParameters: string[],\n\tfromPathname: string[],\n\tsearchParams: UrlSearchParams\n): null | DefaultParameters {\n\tconst params: DefaultParameters = {};\n\tparameters.forEach((name, index) => {\n\t\tparams[name] = fromPathname[index];\n\t});\n\tsearchParameters.forEach(name => {\n\t\tconst value = searchParams.get(name);\n\t\tif (value !== undefined) {\n\t\t\tparams[name] = value;\n\t\t}\n\t});\n\n\treturn params;\n}\n\nconst createRoute: RouteFactory<Context, Parameters> =\n\tcompose({\n\t\tget parent(this: Route<Context, Parameters>) {\n\t\t\treturn parentMap.get(this);\n\t\t},\n\n\t\tget path(this: Route<Context, Parameters>) {\n\t\t\treturn privateStateMap.get(this).path;\n\t\t},\n\n\t\tappend(this: Route<Context, Parameters>, add: Route<Context, Parameters> | Route<Context, Parameters>[]) {\n\t\t\tconst { routes } = privateStateMap.get(this);\n\t\t\tconst append = (route: Route<Context, Parameters>) => {\n\t\t\t\tif (hasBeenAppended(route)) {\n\t\t\t\t\tthrow new Error('Cannot append route that has already been appended');\n\t\t\t\t}\n\n\t\t\t\troutes.push(route);\n\t\t\t\tparentMap.set(route, this);\n\t\t\t};\n\n\t\t\tif (Array.isArray(add)) {\n\t\t\t\tfor (const route of add) {\n\t\t\t\t\tappend(route);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tappend(add);\n\t\t\t}\n\t\t},\n\n\t\tmatch(\n\t\t\tthis: Route<Context, Parameters>,\n\t\t\tsegments: string[],\n\t\t\thasTrailingSlash: boolean,\n\t\t\tsearchParams: UrlSearchParams\n\t\t): null | MatchResult<Parameters> {\n\t\t\tconst { computeParams, path, trailingSlashMustMatch } = privateStateMap.get(this);\n\n\t\t\tconst result = matchPath(path, segments);\n\t\t\tif (result === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!result.hasRemaining && trailingSlashMustMatch && path.trailingSlash !== hasTrailingSlash) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Only extract the search params defined in the route's path.\n\t\t\tconst knownSearchParams = path.searchParameters.reduce<SearchParams>((list, name) => {\n\t\t\t\tconst value = searchParams.getAll(name);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tlist[name] = value;\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}, {});\n\n\t\t\tconst params = computeParams(result.values, new UrlSearchParams(knownSearchParams));\n\t\t\tif (params === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\thasRemaining: result.hasRemaining,\n\t\t\t\toffset: result.offset,\n\t\t\t\tparams,\n\t\t\t\trawPathValues: result.values,\n\t\t\t\trawSearchParams: knownSearchParams\n\t\t\t};\n\t\t},\n\n\t\tselect(\n\t\t\tthis: Route<Context, Parameters>,\n\t\t\tcontext: Context,\n\t\t\tsegments: string[],\n\t\t\thasTrailingSlash: boolean,\n\t\t\tsearchParams: UrlSearchParams\n\t\t): string | Selection[] {\n\t\t\tconst { exec, index, fallback, guard, path, routes } = privateStateMap.get(this);\n\n\t\t\tconst matchResult = this.match(segments, hasTrailingSlash, searchParams);\n\n\t\t\t// Return early if possible.\n\t\t\tif (!matchResult || matchResult.hasRemaining && routes.length === 0 && !fallback) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst { params } = matchResult;\n\t\t\tif (guard) {\n\t\t\t\tconst guardResult = guard({ context, params });\n\t\t\t\tif (typeof guardResult === 'string') {\n\t\t\t\t\treturn guardResult;\n\t\t\t\t}\n\t\t\t\tif (!guardResult) {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet handler = exec;\n\t\t\tlet redirect: string | undefined;\n\t\t\tlet remainingSelection: Selection[] | undefined;\n\t\t\tlet selected = false;\n\n\t\t\tif (matchResult.hasRemaining) {\n\t\t\t\t// Match the remaining segments. Return a hierarchy if nested routes were selected.\n\t\t\t\tconst remainingSegments = segments.slice(matchResult.offset);\n\t\t\t\tselected = routes.some((nested) => {\n\t\t\t\t\tconst nestedResult = nested.select(context, remainingSegments, hasTrailingSlash, searchParams);\n\t\t\t\t\tif (typeof nestedResult === 'string') {\n\t\t\t\t\t\tredirect = nestedResult;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (nestedResult.length > 0) {\n\t\t\t\t\t\tremainingSelection = nestedResult;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\t// No remaining segments matched, only select this route if a fallback handler was specified.\n\t\t\t\tif (!selected && fallback) {\n\t\t\t\t\tselected = true;\n\t\t\t\t\thandler = fallback;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Select this route, configure the index handler if specified.\n\t\t\telse {\n\t\t\t\tselected = true;\n\t\t\t\tif (index) {\n\t\t\t\t\thandler = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!selected) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tif (redirect !== undefined) {\n\t\t\t\treturn redirect;\n\t\t\t}\n\n\t\t\tconst { rawPathValues, rawSearchParams } = matchResult;\n\t\t\tconst selection = {\n\t\t\t\t// Use a noop handler if exec was not provided. Something needs to be returned otherwise the router may\n\t\t\t\t// think no routes were selected.\n\t\t\t\thandler: handler || noop,\n\t\t\t\tpath,\n\t\t\t\tparams,\n\t\t\t\trawPathValues,\n\t\t\t\trawSearchParams,\n\t\t\t\troute: this\n\t\t\t};\n\t\t\treturn remainingSelection ? [selection, ...remainingSelection] : [selection];\n\t\t}\n\t},\n\t(\n\t\tinstance: Route<Context, Parameters>,\n\t\t{\n\t\t\texec,\n\t\t\tfallback,\n\t\t\tguard,\n\t\t\tindex,\n\t\t\tparams: computeParams,\n\t\t\tpath,\n\t\t\ttrailingSlashMustMatch = true\n\t\t}: RouteOptions<Context, Parameters> = {}\n\t) => {\n\t\tif (path && /#/.test(path)) {\n\t\t\tthrow new TypeError('Path must not contain \\'#\\'');\n\t\t}\n\n\t\tconst deconstructedPath = deconstructPath(path || '/');\n\t\tconst { parameters, searchParameters } = deconstructedPath;\n\n\t\tif (computeParams) {\n\t\t\tif (parameters.length === 0 && searchParameters.length === 0) {\n\t\t\t\tthrow new TypeError('Can\\'t specify params() if path doesn\\'t contain any');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcomputeParams = (fromPathname: string[], searchParams: UrlSearchParams) => {\n\t\t\t\treturn computeDefaultParams(parameters, searchParameters, fromPathname, searchParams);\n\t\t\t};\n\t\t}\n\n\t\tprivateStateMap.set(instance, {\n\t\t\tcomputeParams,\n\t\t\texec,\n\t\t\tfallback,\n\t\t\tguard,\n\t\t\tindex,\n\t\t\tpath: deconstructedPath,\n\t\t\troutes: [],\n\t\t\ttrailingSlashMustMatch\n\t\t});\n\t});\n\nexport default createRoute;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-routing/createRoute.ts","import createParentListMixin, { ParentList, ParentListMixinOptions } from 'dojo-widgets/mixins/createParentListMixin';\nimport createRenderMixin, { RenderMixin, RenderMixinOptions, RenderMixinState } from 'dojo-widgets/mixins/createRenderMixin';\nimport createStatefulChildrenMixin, { StatefulChildrenState, StatefulChildrenOptions } from 'dojo-widgets/mixins/createStatefulChildrenMixin';\n\nimport { VNode } from 'maquette';\nimport { List } from 'immutable';\n\nimport { TodoItem } from './createTodoItem';\n\ntype TodoListState = RenderMixinState & StatefulChildrenState & {\n\tactiveFilter?: string;\n};\n\ntype TodoListOptions = RenderMixinOptions<TodoListState> & ParentListMixinOptions<TodoItem> & StatefulChildrenOptions<TodoItem, TodoListState>;\n\nexport type TodoList = RenderMixin<TodoListState> & ParentList<TodoItem> & {\n\tchildren: List<TodoItem>;\n};\n\nfunction filterCompleted(children: List<TodoItem>): List<TodoItem> {\n\treturn <List<TodoItem>> children.filter((child) => {\n\t\treturn child.state.completed;\n\t});\n}\n\nfunction filterActive(children: List<TodoItem>): List<TodoItem> {\n\treturn <List<TodoItem>> children.filter((child) => {\n\t\treturn !child.state.completed;\n\t});\n}\n\nconst createTodoList = createRenderMixin\n\t.mixin(createParentListMixin)\n\t.mixin(createStatefulChildrenMixin)\n\t.extend({\n\t\tgetChildrenNodes(this: TodoList): (VNode | string)[] {\n\t\t\tconst results: (VNode | string)[] = [];\n\t\t\tconst { children } = this;\n\t\t\tlet filteredChildren = children;\n\n\t\t\tif (this.state.activeFilter === 'completed') {\n\t\t\t\tfilteredChildren = filterCompleted(children);\n\t\t\t}\n\t\t\telse if (this.state.activeFilter === 'active') {\n\t\t\t\tfilteredChildren = filterActive(children);\n\t\t\t}\n\t\t\tfilteredChildren.forEach((child) => results.push(child.render()));\n\t\t\treturn results;\n\t\t},\n\n\t\ttagName: 'ul'\n\t});\n\nexport default createTodoList;\n\n\n\n// WEBPACK FOOTER //\n// ./src/widgets/createTodoList.ts","import compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createEvented, { Evented, EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport { Handle } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { List } from 'immutable';\nimport { getRemoveHandle, insertInList, Position } from '../util/lang';\nimport { Parent, Child, ChildListEvent } from './interfaces';\n\nexport interface ParentListMixinOptions<C extends Child> {\n\t/**\n\t * Children that are owned by the parent on creation\n\t */\n\tchildren?: C[];\n}\n\nexport interface ParentList<C extends Child> extends Parent {\n\t/**\n\t * An immutable list of children for this parent\n\t */\n\tchildren: List<Child>;\n\n\t/**\n\t * Remove all children (but don't destory them)\n\t */\n\tclear(): void;\n\n\t/**\n\t * Insert a child in a specific position, providing the reference if required\n\t *\n\t * @param child The child to insert\n\t * @param position The position to insert the child\n\t * @param reference The referencable child, if required\n\t */\n\tinsert(child: C, position: Position, reference?: C): Handle;\n}\n\nexport interface ParentListOverloads<C extends Child> {\n\t/**\n\t * Listen for events emitted from a parent when its children are mutated\n\t */\n\ton(type: 'childlist', listener: EventedListener<ChildListEvent<this, C>>): Handle;\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type ParentListMixin<C extends Child> = ParentList<C> & Evented & ParentListOverloads<C>;\n\nexport interface ParentListMixinFactory extends ComposeFactory<ParentListMixin<Child>, ParentListMixinOptions<Child>> { }\n\n/**\n * Contains a List of children per instance\n */\nconst childrenMap = new WeakMap<ParentListMixin<Child>, List<Child>>();\n\nconst createParentMixin: ParentListMixinFactory = compose<ParentList<Child>, ParentListMixinOptions<Child>>({\n\t\tget children(this: ParentListMixin<Child>): List<Child> {\n\t\t\treturn childrenMap.get(this);\n\t\t},\n\n\t\tset children(this: ParentListMixin<Child>, value: List<Child>) {\n\t\t\tif (!value.equals(childrenMap.get(this))) {\n\t\t\t\tvalue.forEach((widget) => {\n\t\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t\t// istanbul ignore else\n\t\t\t\t\tif (widget) {\n\t\t\t\t\t\tif (widget.parent !== this) {\n\t\t\t\t\t\t\twidget.parent = this;\n\t\t\t\t\t\t\t/* TODO: If a child gets attached and reattached it may own multiple handles */\n\t\t\t\t\t\t\tgetRemoveHandle(this, widget);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchildrenMap.set(this, value);\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'childlist',\n\t\t\t\t\ttarget: this,\n\t\t\t\t\tchildren: value\n\t\t\t\t});\n\t\t\t\tif (this.invalidate) {\n\t\t\t\t\tthis.invalidate();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tappend(this: ParentListMixin<Child>, child: Child[] | Child): Handle {\n\t\t\tthis.children = Array.isArray(child) ? <List<Child>> this.children.concat(child) : this.children.push(child);\n\t\t\treturn getRemoveHandle<Child>(this, child);\n\t\t},\n\n\t\tclear(this: ParentListMixin<Child>): void {\n\t\t\tconst children = childrenMap.get(this);\n\t\t\tif (children) {\n\t\t\t\tchildren.forEach((child) => {\n\t\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t\t// istanbul ignore else\n\t\t\t\t\tif (child) {\n\t\t\t\t\t\tchild.parent === undefined;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.children = List<Child>();\n\t\t\t}\n\t\t},\n\n\t\tinsert(this: ParentListMixin<Child>, child: Child, position: Position, reference?: Child): Handle {\n\t\t\tchild.parent = this;\n\t\t\tthis.children = insertInList(childrenMap.get(this), child, position, reference);\n\t\t\treturn getRemoveHandle(this, child);\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createEvented,\n\t\tinitialize(instance, options) {\n\t\t\tchildrenMap.set(instance, List<any>());\n\t\t\tif (options && options.children && options.children.length) {\n\t\t\t\tinstance.own(instance.append(options.children));\n\t\t\t}\n\t\t\tinstance.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tconst children = childrenMap.get(instance);\n\t\t\t\t\tchildren.forEach((child) => {\n\t\t\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t\t\t// istanbul ignore else\n\t\t\t\t\t\tif (child) {\n\t\t\t\t\t\t\tchild.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\nexport default createParentMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createParentListMixin.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport createRenderMixin, { RenderMixin, RenderMixinOptions, RenderMixinState } from './mixins/createRenderMixin';\nimport createVNodeEvented, { VNodeEvented, VNodeEventedOptions } from './mixins/createVNodeEvented';\n\nexport type WidgetState = RenderMixinState;\n\nexport type WidgetOptions<S extends WidgetState> = RenderMixinOptions<S> & VNodeEventedOptions;\n\nexport type Widget<S extends WidgetState> = RenderMixin<S> & VNodeEvented;\n\nexport interface WidgetFactory extends ComposeFactory<Widget<WidgetState>, WidgetOptions<WidgetState>> {\n\t<S extends WidgetState>(options?: WidgetOptions<S>): Widget<S>;\n}\n\nconst createWidget: WidgetFactory = createRenderMixin\n\t.mixin(createVNodeEvented);\n\nexport default createWidget;\n\n\n\n// WEBPACK FOOTER //\n// src/createWidget.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport createWidget, { Widget, WidgetState, WidgetOptions } from './createWidget';\nimport createCloseableMixin, { Closeable, CloseableState } from './mixins/createCloseableMixin';\nimport createParentListMixin, { ParentListMixin, ParentListMixinOptions } from './mixins/createParentListMixin';\nimport createRenderableChildrenMixin from './mixins/createRenderableChildrenMixin';\nimport createStatefulChildrenMixin, { StatefulChildrenState, StatefulChildrenOptions } from './mixins/createStatefulChildrenMixin';\nimport { Child } from './mixins/interfaces';\n\nexport interface PanelState extends WidgetState, CloseableState, StatefulChildrenState {\n\tlabel?: string;\n}\n\nexport type PanelOptions = WidgetOptions<PanelState> & ParentListMixinOptions<Child> & StatefulChildrenOptions<Child, PanelState>;\n\nexport type Panel = Widget<PanelState> & Closeable & ParentListMixin<Child>;\n\nexport interface PanelFactory extends ComposeFactory<Panel, PanelOptions> { }\n\nconst createPanel: PanelFactory = createWidget\n\t.mixin(createCloseableMixin)\n\t.mixin(createParentListMixin)\n\t.mixin(createRenderableChildrenMixin)\n\t.mixin(createStatefulChildrenMixin)\n\t.extend({\n\t\ttagName: 'dojo-panel'\n\t});\n\nexport default createPanel;\n\n\n\n// WEBPACK FOOTER //\n// src/createPanel.ts","import { VNode } from 'maquette';\nimport { List } from 'immutable';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport { from as arrayFrom } from 'dojo-shim/array';\nimport { Child, ChildEntry } from './interfaces';\n\nexport interface RenderableChildrenOptions {\n\t/**\n\t * An optional method which can be used to sort the children\n\t */\n\tsort?: <C extends Child>(valueA: ChildEntry<C>, valueB: ChildEntry<C>) => number;\n}\n\nexport interface RenderableChildrenMixin {\n\t/**\n\t * Return an array of VNodes/strings the represent the rendered results of the children of this instance\n\t */\n\tgetChildrenNodes(): (VNode | string)[];\n\n\t/**\n\t * An optional method which can be used to sort the children when they are rendered\n\t * @param valueA The first entry to be compared\n\t * @param valueB The second entry to be compared\n\t */\n\tsort?<C extends Child>(valueA: ChildEntry<C>, valueB: ChildEntry<C>): number;\n}\n\nexport interface RenderableChildrenFactory extends ComposeFactory<RenderableChildrenMixin, RenderableChildrenOptions> {}\n\nconst createRenderableChildrenMixin: RenderableChildrenFactory = compose<RenderableChildrenMixin, RenderableChildrenOptions>({\n\t/* When this gets mixed in, if we had the children as part of the interface, we would end up overwritting what is\n\t * likely a get accessor for the children, so to protect ourselves, we won't have it part of the interface */\n\tgetChildrenNodes(this: RenderableChildrenMixin & { children: List<Child>; }): (VNode | string)[] {\n\t\tconst { children, sort } = this;\n\t\t/* children is not guarunteed to be set, therefore need to guard against it */\n\t\tif (children) {\n\t\t\tconst results: (VNode | string)[] = [];\n\t\t\tif (sort) {\n\t\t\t\tarrayFrom(<ChildEntry<Child>[]> <any> children.entries()).sort(sort)\n\t\t\t\t\t.forEach(([ , child ]) => results.push(child.render()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchildren.forEach((child) => {\n\t\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t\t// istanbul ignore else\n\t\t\t\t\tif (child) {\n\t\t\t\t\t\tresults.push(child.render());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\t\telse {\n\t\t\treturn [];\n\t\t}\n\t}\n}, (instance, options) => {\n\tif (options) {\n\t\tinstance.sort = options.sort;\n\t}\n});\n\nexport default createRenderableChildrenMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createRenderableChildrenMixin.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport createCancelableEvent, { CancelableEvent } from 'dojo-compose/util/createCancelableEvent';\nimport { EventedListener, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport createStateful, { Stateful, State, StatefulOptions } from 'dojo-compose/mixins/createStateful';\nimport { Handle } from 'dojo-core/interfaces';\nimport Promise from 'dojo-shim/Promise';\n\nexport interface CloseableState extends State {\n\t/**\n\t * Determines if the widget is closeable or not\n\t */\n\tcloseable?: boolean;\n}\n\nexport interface CloseEvent extends CancelableEvent<'close', CloseableMixin<CloseableState>> { }\n\nexport interface Closeable {\n\t/**\n\t * Attempt to close the widget\n\t */\n\tclose(): Promise<boolean>;\n\n\ton(type: 'close', listener: EventedListener<CloseEvent>): Handle;\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type CloseableMixin<S extends CloseableState> = Stateful<S> & Closeable;\n\nexport interface CloseableMixinFactory extends ComposeFactory<CloseableMixin<CloseableState>, StatefulOptions<CloseableState>> { }\n\nconst createCloseableMixin: CloseableMixinFactory = createStateful\n\t.mixin({\n\t\tmixin: {\n\t\t\tclose(this: CloseableMixin<CloseableState>): Promise<boolean> {\n\t\t\t\tif (this.state.closeable) {\n\t\t\t\t\tconst event = createCancelableEvent({ type: 'close', target: this });\n\t\t\t\t\tthis.emit(event);\n\t\t\t\t\treturn event.defaultPrevented ? Promise.resolve(false) : this.destroy();\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(false);\n\t\t\t}\n\t\t}\n\t});\n\nexport default createCloseableMixin;\n\n\n\n// WEBPACK FOOTER //\n// src/mixins/createCloseableMixin.ts","import { Action } from 'dojo-actions/createAction';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport { EventedListener, EventedListenersMap } from 'dojo-compose/mixins/createEvented';\nimport { ObservableState, State } from 'dojo-compose/mixins/createStateful';\nimport { Handle } from 'dojo-core/interfaces';\nimport IdentityRegistry from 'dojo-core/IdentityRegistry';\nimport { assign } from 'dojo-core/lang';\nimport Promise from 'dojo-shim/Promise';\nimport Set from 'dojo-shim/Set';\nimport Symbol from 'dojo-shim/Symbol';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Child } from 'dojo-widgets/mixins/interfaces';\n\nimport extractRegistrationElements from './lib/extractRegistrationElements';\nimport {\n\tmakeActionFactory,\n\tmakeCustomElementFactory,\n\tmakeStoreFactory,\n\tmakeWidgetFactory\n} from './lib/factories';\nimport InstanceRegistry from './lib/InstanceRegistry';\nimport makeIdGenerator from './lib/makeIdGenerator';\nimport makeMidResolver, { ToAbsMid, ResolveMid } from './lib/moduleResolver';\nimport realizeCustomElements, {\n\tisValidName,\n\tnormalizeName\n} from './lib/realizeCustomElements';\nimport RegistryProvider from './lib/RegistryProvider';\n\nexport { RegistryProvider, ToAbsMid };\n\n/**\n * Any kind of action.\n */\nexport type ActionLike = Action<any, any, any>;\n\n/**\n * Any kind of store.\n */\nexport type StoreLike = ObservableState<State> & {\n\tadd<T>(item: T, options?: any): Promise<T>;\n\tget<T>(id: string): Promise<T>;\n}\n\n/**\n * Any kind of widget.\n */\nexport type WidgetLike = Child;\n\n/**\n * Options passed to action factories.\n */\nexport interface ActionFactoryOptions {\n\t/**\n\t * Provides access to read-only registries for actions, stores and widgets.\n\t */\n\tregistryProvider: RegistryProvider;\n\n\t/**\n\t * The store that was defined for this action.\n\t *\n\t * It's the factories responsibility to create an action that observes the store.\n\t */\n\tstateFrom?: StoreLike;\n}\n\n/**\n * Options passed to widget factories.\n */\nexport interface WidgetFactoryOptions {\n\t/**\n\t * The ID for the widget to be created by the factory.\n\t */\n\tid?: string;\n\n\t/**\n\t * Listeners that should be attached when the widget is created.\n\t */\n\tlisteners?: EventedListenersMap;\n\n\t/**\n\t * Provides access to read-only registries for actions, stores and widgets.\n\t */\n\tregistryProvider: RegistryProvider;\n\n\t/**\n\t * State that should be set while the widget is being created.\n\t */\n\tstate?: any;\n\n\t/**\n\t * The store that was defined for this widget.\n\t *\n\t * It's the factories responsibility to create a widget that observes the store.\n\t */\n\tstateFrom?: StoreLike;\n}\n\n/**\n * Factory method to (asynchronously) create an action.\n *\n * @return The action, or a promise for it\n */\nexport interface ActionFactory {\n\t(options: ActionFactoryOptions): ActionLike | Promise<ActionLike>;\n}\n\n/**\n * Factory method to (asynchronously) create a store.\n *\n * @return The store, or a promise for it\n */\nexport interface StoreFactory {\n\t(options?: Object): StoreLike | Promise<StoreLike>;\n}\n\n/**\n * Factory method to (asynchronously) create a widget.\n *\n * @return The widget, or a promise for it\n */\nexport interface WidgetFactory {\n\t(options?: WidgetFactoryOptions): WidgetLike | Promise<WidgetLike>;\n}\n\n/**\n * Plain old JavaScript object that contains definitions of actions, stores and widgets.\n */\nexport interface Definitions {\n\t/**\n\t * Action definitions.\n\t */\n\tactions?: ActionDefinition[];\n\n\t/**\n\t * Custom element definitions.\n\t */\n\tcustomElements?: CustomElementDefinition[];\n\n\t/**\n\t * Store definitions.\n\t */\n\tstores?: StoreDefinition[];\n\n\t/**\n\t * Widget definitions.\n\t */\n\twidgets?: WidgetDefinition[];\n}\n\n/**\n * Actions, stores and widgets should have string identifiers.\n */\nexport type Identifier = string;\n\n/**\n * Base definition for a single action, store or widget.\n */\nexport interface ItemDefinition<Factory, Instance> {\n\t/**\n\t * Identifier for which the action, store or widget is to be registered.\n\t */\n\tid: Identifier;\n\n\t/**\n\t * Factory to create an action, store or widget, or a module identifier that resolves to\n\t * such a factory.\n\t */\n\tfactory?: Factory | string;\n\n\t/**\n\t * An action, store or widget instance, or a module identifier that resolves to such\n\t * an instance.\n\t */\n\tinstance?: Instance | string;\n}\n\n/**\n * Definition for a single action.\n */\nexport interface ActionDefinition extends ItemDefinition<ActionFactory, ActionLike> {\n\t/**\n\t * Initial state, to be added to the action's store, if any.\n\t */\n\tstate?: any;\n\n\t/**\n\t * Identifier of a store which the action should observe for its state.\n\t *\n\t * When the action is created it'll automatically observe this store.\n\t *\n\t * Note that the `DEFAULT_ACTION_STORE` and `DEFAULT_WIDGET_STORE` identifiers are not supported. The default action\n\t * store is automatically used if stateFrom is not provided.\n\t */\n\tstateFrom?: Identifier | StoreLike;\n}\n\n/**\n * Definition for a custom element;\n */\nexport interface CustomElementDefinition {\n\t/**\n\t * The name of the custom element. Must be valid according to\n\t * <https://www.w3.org/TR/custom-elements/#valid-custom-element-name>.\n\t */\n\tname: string;\n\n\t/**\n\t * Factory to create a widget, or a module identifier that resolves to such a factory.\n\t */\n\tfactory: WidgetFactory | string;\n}\n\n/**\n * Definition for a single store.\n */\nexport interface StoreDefinition extends ItemDefinition<StoreFactory, StoreLike> {\n\t/**\n\t * Optional options object passed to the store factory.\n\t */\n\toptions?: Object;\n}\n\n/**\n * Definition for a single widget.\n */\nexport interface WidgetDefinition extends ItemDefinition<WidgetFactory, WidgetLike> {\n\t/**\n\t * Any listeners that should automatically be attached to the widget.\n\t */\n\tlisteners?: WidgetListenersMap;\n\n\t/**\n\t * Initial state, to be added to the widget's store, if any.\n\t */\n\tstate?: any;\n\n\t/**\n\t * Identifier of a store which the widget should observe for its state.\n\t *\n\t * When the widget is created, the store is passed as the `stateFrom` option.\n\t *\n\t * Note that the `DEFAULT_ACTION_STORE` and `DEFAULT_WIDGET_STORE` identifiers are not supported. The default widget\n\t * store is automatically used if stateFrom is not provided.\n\t */\n\tstateFrom?: Identifier | StoreLike;\n\n\t/**\n\t * Optional options object passed to the widget factory. Must not contain `id`, `listeners` and `stateFrom`\n\t * properties.\n\t */\n\toptions?: Object;\n}\n\n/**\n * A listener for widgets, as used in definitions. May be an identifier for an action or an actual event listener.\n */\nexport type WidgetListener = Identifier | EventedListener<any>;\n\nexport type WidgetListenerOrArray = WidgetListener | WidgetListener[];\n\n/**\n * A map of listeners where the key is the event type.\n */\nexport interface WidgetListenersMap {\n\t[eventType: string]: WidgetListenerOrArray;\n}\n\n/**\n * Read-only interface to access actions, custom element factories, stores and widgets.\n *\n * Used in helper modules which shouldn't write to the app registry.\n */\nexport interface ReadOnlyRegistry {\n\t/**\n\t * Get the action with the given identifier.\n\t *\n\t * Note that the action may still need to be loaded when this method is called.\n\t *\n\t * @param id Identifier for the action\n\t * @return A promise for when the action has been loaded. Rejected if loading fails or if no action is registered\n\t *   with the given identifier.\n\t */\n\tgetAction(id: Identifier): Promise<ActionLike>;\n\n\t/**\n\t * Check whether an action has been registered with the given identifier.\n\t *\n\t * @param id Identifier for the action\n\t * @return `true` if an action has been registered, `false` otherwise.\n\t */\n\thasAction(id: Identifier): boolean;\n\n\t/**\n\t * Look up the identifier for which the given action has been registered.\n\t *\n\t * Throws if the value hasn't been registered.\n\t *\n\t * @param action The action\n\t * @return The identifier\n\t */\n\tidentifyAction(action: ActionLike): Identifier;\n\n\t/**\n\t * Get the factory for the custom element with the given name.\n\t *\n\t * @param name Name of the custom element\n\t * @return A factory to create a widget for the custom element.\n\t */\n\tgetCustomElementFactory(name: string): WidgetFactory;\n\n\t/**\n\t * Check whether a custom element has been registered with the given name.\n\t *\n\t * @param name Name of the custom element\n\t * @return `true` if a custom element has been registered, `false` otherwise.\n\t */\n\thasCustomElementFactory(name: string): boolean;\n\n\t/**\n\t * Get the store with the given identifier.\n\t *\n\t * Note that the store may still need to be loaded when this method is called.\n\t *\n\t * @param id Identifier for the store\n\t * @return A promise for when the store has been loaded. Rejected if loading fails or if no store is registered\n\t *   with the given identifier.\n\t */\n\tgetStore(id: Identifier | symbol): Promise<StoreLike>;\n\n\t/**\n\t * Check whether a store has been registered with the given identifier.\n\t *\n\t * @param id Identifier for the store\n\t * @return `true` if a store has been registered, `false` otherwise.\n\t */\n\thasStore(id: Identifier | symbol): boolean;\n\n\t/**\n\t * Look up the identifier for which the given store has been registered.\n\t *\n\t * Throws if the value hasn't been registered.\n\t *\n\t * @param store The store\n\t * @return The identifier\n\t */\n\tidentifyStore(store: StoreLike): Identifier | symbol;\n\n\t/**\n\t * Create a new widget and add it to the registry.\n\t *\n\t * @param factory Factory to create the widget\n\t * @param options Options to be passed to the factory. Automatically extended with the `registryProvider` option,\n\t *   and the `stateFrom` option if an `id` was present and the application factory has a default store.\n\t * @return A promise for a tuple containing the ID of the created widget, and the widget instance itself.\n\t */\n\tcreateWidget<U extends Child, O>(factory: ComposeFactory<U, O>, options?: O): Promise<[string, U]>;\n\n\t/**\n\t * Get the widget with the given identifier.\n\t *\n\t * Note that the widget may still need to be loaded when this method is called.\n\t *\n\t * @param id Identifier for the widget\n\t * @return A promise for when the widget has been loaded. Rejected if loading fails or if no widget is registered\n\t *   with the given identifier.\n\t */\n\tgetWidget(id: Identifier): Promise<WidgetLike>;\n\n\t/**\n\t * Check whether a widget has been registered or would be created based on an associated state record for the given identifier.\n\t *\n\t * @param id Identifier for the widget\n\t * @return A promise that will resolve to `true` if a widget has been registered or would be created, `false` otherwise.\n\t */\n\thasWidget(id: Identifier): Promise<boolean>;\n\n\t/**\n\t * Look up the identifier for which the given widget has been registered.\n\t *\n\t * Throws if the value hasn't been registered.\n\t *\n\t * @param widget The widget\n\t * @return The identifier\n\t */\n\tidentifyWidget(widget: WidgetLike): Identifier;\n}\n\nexport interface AppMixin {\n\t/**\n\t * A default store to be used as the `stateFrom` option to action factories, unless another store is specified.\n\t */\n\tdefaultActionStore?: StoreLike;\n\n\t/**\n\t * A default store to be used as the `stateFrom` option to widget and custom element factories, unless another\n\t * store is specified.\n\t */\n\tdefaultWidgetStore?: StoreLike;\n\n\t/**\n\t * Provides access to read-only registries for actions, stores and widgets.\n\t */\n\treadonly registryProvider: RegistryProvider;\n\n\t/**\n\t * Register an action with the app.\n\t *\n\t * @param id How the action is identified\n\t * @param action The action to be registered\n\t * @return A handle to deregister the action\n\t */\n\tregisterAction(id: Identifier, action: ActionLike): Handle;\n\n\t/**\n\t * Register an action factory with the app.\n\t *\n\t * The factory will be called the first time the action is needed. It'll be called with an options object that has\n\t * a `registryProvider` property containing a RegistryProvider implementation for the app. If a default action store\n\t * is available it'll be passed as the `stateFrom` property. It's the factories responsibility to create an action\n\t * that observes the store.\n\t *\n\t * Note that the `createAction()` factory from `dojo-actions` cannot be used here since it requires you to define\n\t * the `do()` implementation, which the app factory does not allow.\n\t *\n\t * @param id How the action is identified\n\t * @param factory A factory function that (asynchronously) creates an action.\n\t * @return A handle to deregister the action factory, or the action itself once it's been created\n\t */\n\tregisterActionFactory(id: Identifier, factory: ActionFactory): Handle;\n\n\t/**\n\t * Register a widget factory for a custom element.\n\t *\n\t * The factory will be called each time a widget instance is needed. It may be called with an options argument\n\t * derived from a `data-options` attribute on the custom element that is to be be replaced by the created widget.\n\t *\n\t * @param name The name of the custom element. Must be valid according to\n\t *   <https://www.w3.org/TR/custom-elements/#valid-custom-element-name>.\n\t * @param factory A factory that (asynchronously) creates a widget.\n\t * @return A handle to deregister the custom element\n\t */\n\tregisterCustomElementFactory(name: string, factory: WidgetFactory): Handle;\n\n\t/**\n\t * Register a store with the app.\n\t *\n\t * @param id How the store is identified\n\t * @param store The store to be registered\n\t * @return A handle to deregister the store\n\t */\n\tregisterStore(id: Identifier, store: StoreLike): Handle;\n\n\t/**\n\t * Register a store factory with the app.\n\t *\n\t * The factory will be called the first time the store is needed. It'll be called *without* any arguments.\n\t *\n\t * @param id How the store is identified\n\t * @param factory A factory function that (asynchronously) creates a store.\n\t * @return A handle to deregister the store factory, or the store itself once it's been created\n\t */\n\tregisterStoreFactory(id: Identifier, factory: StoreFactory): Handle;\n\n\t/**\n\t * Register a widget with the app.\n\t *\n\t * @param id How the widget is identified\n\t * @param widget The widget to be registered\n\t * @return A handle to deregister the widget\n\t */\n\tregisterWidget(id: Identifier, widget: WidgetLike): Handle;\n\n\t/**\n\t * Register a widget factory with the app.\n\t *\n\t * The factory will be called the first time the widget is needed. It'll be called with an options object\n\t * that has its `id` property set to the widget ID, and a `registryProvider` property containing a RegistryProvider\n\t * implementation for the app. If a default widget store is available it'll be passed as the `stateFrom` property.\n\t *\n\t * @param id How the widget is identified\n\t * @param factory A factory function that (asynchronously) creates a widget.\n\t * @return A handle to deregister the widget factory, or the widget itself once it's been created\n\t */\n\tregisterWidgetFactory(id: Identifier, factory: WidgetFactory): Handle;\n\n\t/**\n\t * Load a POJO definition containing actions, stores and widgets that need to be registered.\n\t *\n\t * All factories will be called with an options object.\n\t *\n\t * @return A handle to deregister *all* actions, stores and widgets that were registered.\n\t */\n\tloadDefinition(definitions: Definitions): Handle;\n\n\t/**\n\t * Extract declarative definition custom elements in the root and render widgets.\n\t *\n\t * @param root The root element that is searched for custom elements\n\t * @return A handle to detach rendered widgets from the DOM and remove them from the widget registry\n\t */\n\trealize(root: Element): Promise<Handle>;\n}\n\nexport type App = AppMixin & ReadOnlyRegistry;\n\nexport interface AppOptions {\n\t/**\n\t * A default store to be used as the `stateFrom` option to action factories, unless another store is specified.\n\t */\n\tdefaultActionStore?: StoreLike;\n\n\t/**\n\t * A default store to be used as the `stateFrom` option to widget and custom element factories, unless another\n\t * store is specified.\n\t */\n\tdefaultWidgetStore?: StoreLike;\n\n\t/**\n\t * Function that maps a (relative) module identifier to an absolute one. Used to resolve relative module\n\t * identifiers in definitions.\n\t */\n\ttoAbsMid?: ToAbsMid;\n}\n\nexport interface AppFactory extends ComposeFactory<App, AppOptions> {}\n\n/**\n * Identifier for the default action store, if any.\n */\nexport const DEFAULT_ACTION_STORE = Symbol('Identifier for default action stores');\n\n/**\n * Identifier for the default widget store, if any.\n */\nexport const DEFAULT_WIDGET_STORE = Symbol('Identifier for default widget stores');\n\nconst generateWidgetId = makeIdGenerator('app-widget-');\n\nconst noop = () => {};\n\ntype RegisteredFactory<T> = () => T | Promise<T>;\n\ninterface PrivateState {\n\treadonly actionFactories: IdentityRegistry<RegisteredFactory<ActionLike>>;\n\treadonly customElementFactories: IdentityRegistry<WidgetFactory>;\n\treadonly identifiers: Set<Identifier>;\n\treadonly instanceRegistry: InstanceRegistry;\n\treadonly registryProvider: RegistryProvider;\n\treadonly resolveMid: ResolveMid;\n\treadonly storeFactories: IdentityRegistry<RegisteredFactory<StoreLike>>;\n\treadonly widgetFactories: IdentityRegistry<RegisteredFactory<WidgetLike>>;\n\treadonly widgetInstances: IdentityRegistry<WidgetLike>;\n}\n\nconst privateStateMap = new WeakMap<App, PrivateState>();\n\nfunction addIdentifier(app: App, id: Identifier) {\n\tconst { identifiers } = privateStateMap.get(app);\n\tif (identifiers.has(id)) {\n\t\tthrow new Error(`'${id}' has already been used as an identifier`);\n\t}\n\n\tidentifiers.add(id);\n\n\treturn {\n\t\tdestroy(this: Handle) {\n\t\t\tthis.destroy = noop;\n\t\t\tidentifiers.delete(id);\n\t\t}\n\t};\n}\n\nfunction createCustomWidget(app: App, id: string) {\n\tconst { registryProvider, defaultWidgetStore } = app;\n\tlet factoryHandle: Handle;\n\t// istanbul ignore if\n\tif (!defaultWidgetStore) {\n\t\tthrow new Error('A default widget store must be configured in order to create custom widgets');\n\t}\n\n\treturn defaultWidgetStore.get(id).then((state: any) => {\n\t\tconst { customElementFactories, widgetFactories, widgetInstances } = privateStateMap.get(app);\n\n\t\tconst hasRegisteredFactory = widgetFactories.has(id);\n\t\tconst hasRegisteredInstance = widgetInstances.has(id);\n\n\t\tif (!hasRegisteredFactory && !hasRegisteredInstance) {\n\t\t\tconst customFactory = customElementFactories.get(state.type);\n\t\t\tfactoryHandle = app.registerWidgetFactory(id, customFactory);\n\t\t}\n\n\t\treturn app.getWidget(id);\n\t}).then((widget) => {\n\t\twidget.own(factoryHandle);\n\t\treturn widget;\n\t});\n}\n\nfunction registerInstance(app: App, instance: WidgetLike, id: string): Handle {\n\tconst { instanceRegistry, widgetInstances } = privateStateMap.get(app);\n\n\t// Maps the instance to its ID\n\tconst instanceHandle = instanceRegistry.addWidget(instance, id);\n\t// Maps the ID to the instance\n\tconst idHandle = widgetInstances.register(id, instance);\n\n\treturn {\n\t\tdestroy(this: Handle) {\n\t\t\tthis.destroy = noop;\n\t\t\tinstanceHandle.destroy();\n\t\t\tidHandle.destroy();\n\t\t}\n\t};\n}\n\nconst createApp = compose({\n\tset defaultActionStore(store: StoreLike) {\n\t\tconst { instanceRegistry, storeFactories } = privateStateMap.get(this);\n\t\tinstanceRegistry.addStore(store, DEFAULT_ACTION_STORE);\n\t\tstoreFactories.register(DEFAULT_ACTION_STORE, () => store);\n\t},\n\n\tget defaultActionStore(this: App) {\n\t\tconst { storeFactories } = privateStateMap.get(this);\n\t\tif (storeFactories.has(DEFAULT_ACTION_STORE)) {\n\t\t\treturn <StoreLike> storeFactories.get(DEFAULT_ACTION_STORE)();\n\t\t}\n\t},\n\n\tset defaultWidgetStore(store: StoreLike) {\n\t\tconst { instanceRegistry, storeFactories } = privateStateMap.get(this);\n\t\tinstanceRegistry.addStore(store, DEFAULT_WIDGET_STORE);\n\t\tstoreFactories.register(DEFAULT_WIDGET_STORE, () => store);\n\t},\n\n\tget defaultWidgetStore(this: App) {\n\t\tconst { storeFactories } = privateStateMap.get(this);\n\t\tif (storeFactories.has(DEFAULT_WIDGET_STORE)) {\n\t\t\treturn <StoreLike> storeFactories.get(DEFAULT_WIDGET_STORE)();\n\t\t}\n\t},\n\n\tget registryProvider(this: App) {\n\t\treturn privateStateMap.get(this).registryProvider;\n\t},\n\n\tregisterAction(this: App, id: Identifier, action: ActionLike): Handle {\n\t\tconst { actionFactories, instanceRegistry } = privateStateMap.get(this);\n\n\t\tconst idHandle = addIdentifier(this, id);\n\t\tconst instanceHandle = instanceRegistry.addAction(action, id);\n\n\t\tlet registryHandle = actionFactories.register(id, () => {\n\t\t\tconst promise = new Promise<void>((resolve) => {\n\t\t\t\tresolve(action.configure(this.registryProvider));\n\t\t\t})\n\t\t\t.then(() => action);\n\n\t\t\t// Replace the registered factory to ensure the action is not configured twice.\n\t\t\tregistryHandle.destroy();\n\t\t\tregistryHandle = actionFactories.register(id, () => promise);\n\n\t\t\treturn promise;\n\t\t});\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tidHandle.destroy();\n\t\t\t\tinstanceHandle.destroy();\n\t\t\t\tregistryHandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\n\tregisterActionFactory(this: App, id: Identifier, factory: ActionFactory): Handle {\n\t\tconst { actionFactories, instanceRegistry } = privateStateMap.get(this);\n\n\t\tconst idHandle = addIdentifier(this, id);\n\n\t\tlet destroyed = false;\n\t\tlet instanceHandle: Handle;\n\t\tlet registryHandle = actionFactories.register(id, () => {\n\t\t\tconst promise = Promise.resolve()\n\t\t\t\t.then(() => {\n\t\t\t\t\t// Always call the factory in a future turn. This harmonizes behavior regardless of whether the\n\t\t\t\t\t// factory is registered through this method or loaded from a definition.\n\n\t\t\t\t\tconst { defaultActionStore: stateFrom, registryProvider } = this;\n\t\t\t\t\treturn factory({ registryProvider, stateFrom });\n\t\t\t\t})\n\t\t\t\t.then((action) => {\n\t\t\t\t\tif (!destroyed) {\n\t\t\t\t\t\tinstanceHandle = instanceRegistry.addAction(action, id);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Configure the action, allow for a promise to be returned.\n\t\t\t\t\treturn Promise.resolve(action.configure(this.registryProvider)).then(() => {\n\t\t\t\t\t\treturn action;\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t// Replace the registered factory to ensure next time this action is needed, the same action is returned.\n\t\t\tregistryHandle.destroy();\n\t\t\tregistryHandle = actionFactories.register(id, () => promise);\n\n\t\t\treturn promise;\n\t\t});\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tdestroyed = true;\n\t\t\t\tidHandle.destroy();\n\t\t\t\tregistryHandle.destroy();\n\t\t\t\tif (instanceHandle) {\n\t\t\t\t\tinstanceHandle.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\n\tregisterCustomElementFactory(this: App, name: string, factory: WidgetFactory): Handle {\n\t\tif (!isValidName(name)) {\n\t\t\tthrow new SyntaxError(`'${name}' is not a valid custom element name`);\n\t\t}\n\n\t\t// Wrap the factory since the registry cannot store frozen factories, and dojo-compose creates\n\t\t// frozen factories\n\t\tconst wrapped = (options: WidgetFactoryOptions) => factory(options);\n\n\t\t// Note that each custom element requires a new widget, so there's no need to replace the\n\t\t// registered factory.\n\t\tconst registryHandle = privateStateMap.get(this).customElementFactories.register(normalizeName(name), wrapped);\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tregistryHandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\n\tregisterStore(this: App, id: Identifier, store: StoreLike): Handle {\n\t\tconst { instanceRegistry, storeFactories } = privateStateMap.get(this);\n\n\t\tconst idHandle = addIdentifier(this, id);\n\t\tconst instanceHandle = instanceRegistry.addStore(store, id);\n\t\tconst registryHandle = storeFactories.register(id, () => store);\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tidHandle.destroy();\n\t\t\t\tinstanceHandle.destroy();\n\t\t\t\tregistryHandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\n\tregisterStoreFactory(this: App, id: Identifier, factory: StoreFactory): Handle {\n\t\tconst { instanceRegistry, storeFactories } = privateStateMap.get(this);\n\n\t\tconst idHandle = addIdentifier(this, id);\n\n\t\tlet destroyed = false;\n\t\tlet instanceHandle: Handle;\n\t\tlet registryHandle = storeFactories.register(id, () => {\n\t\t\tconst promise = Promise.resolve().then(() => {\n\t\t\t\t// Always call the factory in a future turn. This harmonizes behavior regardless of whether the\n\t\t\t\t// factory is registered through this method or loaded from a definition.\n\t\t\t\treturn factory();\n\t\t\t}).then((store) => {\n\t\t\t\tif (!destroyed) {\n\t\t\t\t\tinstanceHandle = instanceRegistry.addStore(store, id);\n\t\t\t\t}\n\n\t\t\t\treturn store;\n\t\t\t});\n\t\t\t// Replace the registered factory to ensure next time this store is needed, the same store is returned.\n\t\t\tregistryHandle.destroy();\n\t\t\tregistryHandle = storeFactories.register(id, () => promise);\n\t\t\treturn promise;\n\t\t});\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tdestroyed = true;\n\t\t\t\tidHandle.destroy();\n\t\t\t\tregistryHandle.destroy();\n\t\t\t\tif (instanceHandle) {\n\t\t\t\t\tinstanceHandle.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\n\tregisterWidget(this: App, id: Identifier, widget: WidgetLike): Handle {\n\t\tconst { instanceRegistry, widgetFactories } = privateStateMap.get(this);\n\n\t\tconst idHandle = addIdentifier(this, id);\n\t\tconst instanceHandle = instanceRegistry.addWidget(widget, id);\n\t\tconst registryHandle = widgetFactories.register(id, () => widget);\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tidHandle.destroy();\n\t\t\t\tinstanceHandle.destroy();\n\t\t\t\tregistryHandle.destroy();\n\t\t\t}\n\t\t};\n\t},\n\n\tregisterWidgetFactory(this: App, id: Identifier, factory: WidgetFactory): Handle {\n\t\tconst { instanceRegistry, widgetFactories } = privateStateMap.get(this);\n\n\t\tconst idHandle = addIdentifier(this, id);\n\n\t\tlet destroyed = false;\n\t\tlet instanceHandle: Handle;\n\t\tlet registryHandle = widgetFactories.register(id, () => {\n\t\t\tconst promise = Promise.resolve().then(() => {\n\t\t\t\t// Always call the factory in a future turn. This harmonizes behavior regardless of whether the\n\t\t\t\t// factory is registered through this method or loaded from a definition.\n\n\t\t\t\tconst { registryProvider, defaultWidgetStore } = this;\n\t\t\t\tconst options: WidgetFactoryOptions = { id, registryProvider };\n\t\t\t\tif (defaultWidgetStore) {\n\t\t\t\t\toptions.stateFrom = defaultWidgetStore;\n\t\t\t\t}\n\t\t\t\treturn factory(options);\n\t\t\t}).then((widget) => {\n\t\t\t\tif (!destroyed) {\n\t\t\t\t\tinstanceHandle = instanceRegistry.addWidget(widget, id);\n\t\t\t\t}\n\n\t\t\t\treturn widget;\n\t\t\t});\n\t\t\t// Replace the registered factory to ensure next time this widget is needed, the same widget is returned.\n\t\t\tregistryHandle.destroy();\n\t\t\tregistryHandle = widgetFactories.register(id, () => promise);\n\t\t\treturn promise;\n\t\t});\n\n\t\treturn {\n\t\t\tdestroy(this: Handle) {\n\t\t\t\tthis.destroy = noop;\n\t\t\t\tdestroyed = true;\n\t\t\t\tidHandle.destroy();\n\t\t\t\tregistryHandle.destroy();\n\t\t\t\tif (instanceHandle) {\n\t\t\t\t\tinstanceHandle.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\n\tloadDefinition(this: App, { actions, customElements, stores, widgets }: Definitions): Handle {\n\t\tconst { resolveMid } = privateStateMap.get(this);\n\n\t\tconst handles: Handle[] = [];\n\n\t\tif (actions) {\n\t\t\tfor (const definition of actions) {\n\t\t\t\tconst factory = makeActionFactory(definition, resolveMid, this);\n\t\t\t\tconst handle = this.registerActionFactory(definition.id, factory);\n\t\t\t\thandles.push(handle);\n\t\t\t}\n\t\t}\n\n\t\tif (customElements) {\n\t\t\tfor (const definition of customElements) {\n\t\t\t\tconst factory = makeCustomElementFactory(definition, resolveMid);\n\t\t\t\tconst handle = this.registerCustomElementFactory(definition.name, factory);\n\t\t\t\thandles.push(handle);\n\t\t\t}\n\t\t}\n\n\t\tif (stores) {\n\t\t\tfor (const definition of stores) {\n\t\t\t\tconst factory = makeStoreFactory(definition, resolveMid);\n\t\t\t\tconst handle = this.registerStoreFactory(definition.id, factory);\n\t\t\t\thandles.push(handle);\n\t\t\t}\n\t\t}\n\n\t\tif (widgets) {\n\t\t\tfor (const definition of widgets) {\n\t\t\t\tconst factory = makeWidgetFactory(definition, resolveMid, this);\n\t\t\t\tconst handle = this.registerWidgetFactory(definition.id, factory);\n\t\t\t\thandles.push(handle);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tfor (const handle of handles.splice(0, handles.length)) {\n\t\t\t\t\thandle.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t},\n\n\trealize(this: App, root: Element) {\n\t\tconst { resolveMid } = privateStateMap.get(this);\n\n\t\treturn extractRegistrationElements(resolveMid, root)\n\t\t\t.then(({ actions, customElements, defaultStores, stores, widgets }) => {\n\t\t\t\tconst definitionHandle = this.loadDefinition({ actions, customElements, stores, widgets });\n\t\t\t\tif (defaultStores.length === 0) {\n\t\t\t\t\treturn definitionHandle;\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all(defaultStores.map((definition) => {\n\t\t\t\t\t// N.B. The ID is ignored by the store factory\n\t\t\t\t\tconst { id: type } = definition;\n\t\t\t\t\tconst factory = makeStoreFactory(definition, resolveMid);\n\t\t\t\t\treturn Promise.resolve(factory())\n\t\t\t\t\t\t.then((store) => {\n\t\t\t\t\t\t\tif (type === 'action') {\n\t\t\t\t\t\t\t\tthis.defaultActionStore = store;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthis.defaultWidgetStore = store;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t}))\n\t\t\t\t.then(() => definitionHandle);\n\t\t\t})\n\t\t\t.then((definitionHandle) => {\n\t\t\t\treturn realizeCustomElements(\n\t\t\t\t\t(id) => addIdentifier(this, id),\n\t\t\t\t\t(instance: WidgetLike, id: string) => registerInstance(this, instance, id),\n\t\t\t\t\tthis,\n\t\t\t\t\tthis.registryProvider,\n\t\t\t\t\troot,\n\t\t\t\t\tthis.defaultWidgetStore\n\t\t\t\t)\n\t\t\t\t.then((realizationHandle) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdestroy(this: Handle) {\n\t\t\t\t\t\t\tthis.destroy = noop;\n\t\t\t\t\t\t\tdefinitionHandle.destroy();\n\t\t\t\t\t\t\trealizationHandle.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t});\n\t}\n})\n.mixin({\n\tmixin: {\n\t\tgetAction(this: App, id: Identifier): Promise<ActionLike> {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tresolve(privateStateMap.get(this).actionFactories.get(id)());\n\t\t\t});\n\t\t},\n\n\t\thasAction(this: App, id: Identifier): boolean {\n\t\t\treturn privateStateMap.get(this).actionFactories.has(id);\n\t\t},\n\n\t\tidentifyAction(this: App, action: ActionLike): string {\n\t\t\treturn privateStateMap.get(this).instanceRegistry.identifyAction(action);\n\t\t},\n\n\t\tgetCustomElementFactory(this: App, name: string): WidgetFactory {\n\t\t\treturn privateStateMap.get(this).customElementFactories.get(name);\n\t\t},\n\n\t\thasCustomElementFactory(this: App, name: string) {\n\t\t\treturn privateStateMap.get(this).customElementFactories.has(name);\n\t\t},\n\n\t\tgetStore(this: App, id: Identifier | symbol): Promise<StoreLike> {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tresolve(privateStateMap.get(this).storeFactories.get(id)());\n\t\t\t});\n\t\t},\n\n\t\thasStore(this: App, id: Identifier | symbol): boolean {\n\t\t\treturn privateStateMap.get(this).storeFactories.has(id);\n\t\t},\n\n\t\tidentifyStore(this: App, store: StoreLike): Identifier | symbol {\n\t\t\treturn privateStateMap.get(this).instanceRegistry.identifyStore(store);\n\t\t},\n\n\t\tcreateWidget<U extends Child, O extends WidgetFactoryOptions>(\n\t\t\tthis: App,\n\t\t\tfactory: ComposeFactory<U, O>,\n\t\t\toptions: any = {}\n\t\t): Promise<[ string, U ]> {\n\t\t\tconst { defaultWidgetStore, registryProvider } = this;\n\t\t\tconst { id = generateWidgetId() } = options;\n\t\t\t// Like for custom elements, don't add the generated ID to the options.\n\n\t\t\tconst { widgetFactories, widgetInstances } = privateStateMap.get(this);\n\n\t\t\t// Ensure no other widget with this ID exists.\n\t\t\tif (widgetFactories.has(id) || widgetInstances.has(id)) {\n\t\t\t\treturn Promise.reject(new Error(`A widget with ID '${id}' already exists`));\n\t\t\t}\n\n\t\t\tif (!options.registryProvider) {\n\t\t\t\toptions.registryProvider = registryProvider;\n\t\t\t}\n\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tif (options.id && (options.stateFrom || defaultWidgetStore)) {\n\t\t\t\t\tconst store: StoreLike = options.stateFrom = options.stateFrom || defaultWidgetStore;\n\n\t\t\t\t\t// We will attempt to create an initial state, if it isn't present in the store\n\t\t\t\t\tconst state = { id };\n\t\t\t\t\tif (options.state) {\n\t\t\t\t\t\tassign(state, options.state);\n\t\t\t\t\t}\n\t\t\t\t\t// TODO: What happens if the store rejects?\n\t\t\t\t\tresolve(store.add(state));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => {\n\t\t\t\tconst widget = factory(options);\n\t\t\t\t// Add the instance to the various registries the app may maintain.\n\t\t\t\t//\n\t\t\t\t// No need to trap registerInstance for duplicates, because we are creating new\n\t\t\t\t// in this function\n\t\t\t\twidget.own(registerInstance(this, widget, id));\n\t\t\t\treturn [ id, widget ];\n\t\t\t});\n\t\t},\n\n\t\tgetWidget(this: App, id: Identifier): Promise<WidgetLike> {\n\t\t\t// Widgets either need to be resolved from a factory, or have been created when realizing\n\t\t\t// custom elements.\n\t\t\tconst { widgetFactories: factories, widgetInstances: instances } = privateStateMap.get(this);\n\n\t\t\tlet missingFactory: any;\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tlet factory: WidgetFactory;\n\t\t\t\ttry {\n\t\t\t\t\tfactory = factories.get(id);\n\t\t\t\t\t// Don't call the factory yet. Errors thrown during its execution should be differentiated from\n\t\t\t\t\t// errors thrown when getting the factory.\n\t\t\t\t}\n\t\t\t\tcatch (err) {\n\t\t\t\t\tmissingFactory = err;\n\t\t\t\t\tresolve(Promise.reject(err));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Be sure to call the factory synchronously.\n\t\t\t\tresolve(factory());\n\t\t\t}).catch((err) => {\n\t\t\t\tif (missingFactory && instances.has(id)) {\n\t\t\t\t\treturn instances.get(id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t}\n\t\t\t}).catch((err) => {\n\t\t\t\tif (missingFactory && this.defaultWidgetStore) {\n\t\t\t\t\t// Note that errors thrown by the createCustomWidget are masked by the missingFactory error.\n\t\t\t\t\treturn createCustomWidget(this, id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn Promise.reject(err);\n\t\t\t\t}\n\t\t\t}).catch((err) => {\n\t\t\t\treturn Promise.reject(missingFactory || err);\n\t\t\t});\n\t\t},\n\n\t\thasWidget(this: App, id: Identifier): Promise<boolean> {\n\t\t\tconst { customElementFactories, widgetFactories, widgetInstances } = privateStateMap.get(this);\n\t\t\tconst { defaultWidgetStore } = this;\n\n\t\t\tlet exists: Promise<boolean> | boolean = widgetFactories.has(id) || widgetInstances.has(id);\n\n\t\t\tif (exists || !defaultWidgetStore) {\n\t\t\t\treturn Promise.resolve(exists);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn defaultWidgetStore.get(id).then(({ type }) => customElementFactories.has(type));\n\t\t\t}\n\t\t},\n\n\t\tidentifyWidget(this: App, widget: WidgetLike): string {\n\t\t\treturn privateStateMap.get(this).instanceRegistry.identifyWidget(widget);\n\t\t}\n\t},\n\n\tinitialize (\n\t\tinstance: App,\n\t\t{\n\t\t\tdefaultActionStore,\n\t\t\tdefaultWidgetStore,\n\t\t\ttoAbsMid = (moduleId: string) => moduleId\n\t\t}: AppOptions = {}\n\t) {\n\t\tprivateStateMap.set(instance, {\n\t\t\tactionFactories: new IdentityRegistry<RegisteredFactory<ActionLike>>(),\n\t\t\tcustomElementFactories: new IdentityRegistry<RegisteredFactory<WidgetLike>>(),\n\t\t\tidentifiers: new Set<Identifier>(),\n\t\t\tinstanceRegistry: new InstanceRegistry(),\n\t\t\tregistryProvider: new RegistryProvider(instance),\n\t\t\tresolveMid: makeMidResolver(toAbsMid),\n\t\t\tstoreFactories: new IdentityRegistry<RegisteredFactory<StoreLike>>(),\n\t\t\twidgetFactories: new IdentityRegistry<RegisteredFactory<WidgetLike>>(),\n\t\t\twidgetInstances: new IdentityRegistry<WidgetLike>()\n\t\t});\n\n\t\tif (defaultActionStore) {\n\t\t\tinstance.defaultActionStore = defaultActionStore;\n\t\t}\n\t\tif (defaultWidgetStore) {\n\t\t\tinstance.defaultWidgetStore = defaultWidgetStore;\n\t\t}\n\t}\n}) as AppFactory;\n\nexport default createApp;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/createApp.ts","import { EventedListenersMap } from 'dojo-compose/mixins/createEvented';\nimport { Handle } from 'dojo-core/interfaces';\nimport { from as arrayFrom } from 'dojo-shim/array';\nimport Promise from 'dojo-shim/Promise';\nimport Set from 'dojo-shim/Set';\nimport Map from 'dojo-shim/Map';\nimport { place, Position } from 'dojo-dom/dom';\nimport { createProjector, Projector } from 'dojo-widgets/projector';\n\nimport {\n\tReadOnlyRegistry,\n\tRegistryProvider,\n\tStoreLike,\n\tWidgetFactory,\n\tWidgetFactoryOptions,\n\tWidgetLike,\n\tWidgetListenersMap\n} from '../createApp';\nimport makeIdGenerator from './makeIdGenerator';\nimport parseJsonAttribute from './parseJsonAttribute';\nimport resolveListenersMap from './resolveListenersMap';\n\nconst reservedNames = new Set([\n\t// According to <https://www.w3.org/TR/custom-elements/#valid-custom-element-name>.\n\t'annotation-xml',\n\t'color-profile',\n\t'font-face',\n\t'font-face-src',\n\t'font-face-uri',\n\t'font-face-format',\n\t'font-face-name',\n\t'missing-glyph'\n]);\n\n// According to <https://www.w3.org/TR/custom-elements/#valid-custom-element-name>.\nexport function isValidName(name: string): boolean {\n\tif (!/^[a-z]/.test(name)) { // Names must start with a lowercase ASCII letter\n\t\treturn false;\n\t}\n\n\tif (name.indexOf('-') === -1) { // Names must contain at least one hyphen\n\t\treturn false;\n\t}\n\n\tif (/[A-Z]/.test(name)) { // Names must not include uppercase ASCII letters\n\t\treturn false;\n\t}\n\n\tif (reservedNames.has(name)) { // Reserved names must not be used.\n\t\treturn false;\n\t}\n\n\tif (/^app-/.test(name)) { // Names must not start with app-\n\t\treturn false;\n\t}\n\n\t// Assume name does not contain other invalid characters.\n\t// TODO: Are the above rules sufficiently exclusive given the allowed PCENChar characters in the\n\t// <https://www.w3.org/TR/custom-elements/#valid-custom-element-name> specification?\n\treturn true;\n}\n\n// <https://www.w3.org/TR/custom-elements/#look-up-a-custom-element-definition> doesn't define *how* names\n// are to be compared. Additionally browsers and document modes differ in the case used for Element#tagName\n// values. Lowercasing the name is the most compatible solution. This is also the approach taken by the\n// Web Components polyfill:\n// <https://github.com/webcomponents/webcomponentsjs/blob/251f4afedec0ce649728fa1cf22e4fc16bf2bea5/src/CustomElements/register.js#L93>\nexport function normalizeName(name: string): string {\n\treturn name.toLowerCase();\n}\n\ninterface CustomElement {\n\treadonly children: CustomElement[];\n\treadonly element: Element;\n\treadonly name: string;\n\twidget?: WidgetLike;\n}\n\nfunction isCustomElement(registry: ReadOnlyRegistry, name: string): boolean {\n\treturn name === 'app-projector' || name === 'app-widget' || registry.hasCustomElementFactory(name);\n}\n\nfunction getCustomElementsByWidgetProjector(registry: ReadOnlyRegistry, root: Element): CustomElement[] {\n\tconst allElements: Element[] = arrayFrom(root.getElementsByTagName('*'));\n\tallElements.unshift(root); // Be inclusive!\n\n\tconst customElements: CustomElement[] = [];\n\tfor (const element of allElements) {\n\t\tlet name: string | undefined;\n\n\t\tconst tagName = normalizeName(element.tagName);\n\t\tif (isCustomElement(registry, tagName)) {\n\t\t\tname = tagName;\n\t\t}\n\t\telse {\n\t\t\tconst attrIs = normalizeName(element.getAttribute('is') || '');\n\t\t\tif (attrIs !== '' && isCustomElement(registry, attrIs)) {\n\t\t\t\tname = attrIs;\n\t\t\t}\n\t\t}\n\n\t\tif (name) {\n\t\t\tcustomElements.push({ children: [], element, name });\n\t\t}\n\t}\n\n\t// A list of trees, reconstructed from the `customElements`.\n\tconst widgetProjectors: CustomElement[] = [];\n\t// Inverse stack of the nodes in the current tree. The deepest node is at the start of the list.\n\tconst inverseStack: CustomElement[] = [];\n\n\tconst discardFirstNode = (element: Element) => {\n\t\tif (inverseStack.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `true` if the top-most element in the stack does *not* contain `element`.\n\t\treturn !(inverseStack[0].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);\n\t};\n\n\t// `customElements` is a flat list of elements, in document order. Reconstruct a tree structure where each\n\t// root is assumed to be a widget projector.\n\tfor (const custom of customElements) {\n\t\t// Remove nodes from the stack that do not contain the element.\n\t\twhile (discardFirstNode(custom.element)) {\n\t\t\tinverseStack.shift();\n\t\t}\n\n\t\t// Start a new tree if the element is not contained in any existing node.\n\t\tif (inverseStack.length === 0) {\n\t\t\t// Don't costruct an invalid tree.\n\t\t\tif (custom.name !== 'app-projector') {\n\t\t\t\tthrow new Error('Custom tags must be rooted in a app-projector');\n\t\t\t}\n\n\t\t\twidgetProjectors.push(custom);\n\t\t}\n\t\t// Add the element to the deepest node it is contained by.\n\t\telse {\n\t\t\t// Don't costruct an invalid tree.\n\t\t\tif (custom.name === 'app-projector') {\n\t\t\t\tthrow new Error('app-projector cannot contain another app-projector');\n\t\t\t}\n\n\t\t\tinverseStack[0].children.push(custom);\n\t\t}\n\n\t\t// Prepare for the next iteration.\n\t\tinverseStack.unshift(custom);\n\t}\n\n\treturn widgetProjectors;\n}\n\nfunction getIdFromAttributes(element: Element): string | undefined {\n\treturn element.getAttribute('data-uid') || element.getAttribute('id') || undefined;\n}\n\ninterface JsonOptions {\n\treadonly id?: string;\n\treadonly listeners?: any;\n\treadonly stateFrom?: any;\n}\n\ninterface Options {\n\tid?: string;\n\treadonly listeners?: EventedListenersMap;\n\tregistryProvider: RegistryProvider;\n\treadonly stateFrom?: StoreLike;\n}\n\nfunction resolveListeners(registry: ReadOnlyRegistry, element: Element): null | Promise<EventedListenersMap> {\n\tconst str = element.getAttribute('data-listeners');\n\tif (!str) {\n\t\treturn null;\n\t}\n\n\tconst listeners = parseJsonAttribute<WidgetListenersMap>('data-listeners', str);\n\tlet valid = true;\n\t// Prefer breaking a labeled loop over nesting Array#some() calls or repeating the throwing of\n\t// the TypeError.\n\tcheck: for (const eventType in listeners) {\n\t\tconst value = listeners[eventType];\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (const identifier of value) {\n\t\t\t\tif (typeof identifier !== 'string') {\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak check;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (typeof value !== 'string') {\n\t\t\tvalid = false;\n\t\t\tbreak check;\n\t\t}\n\t}\n\n\tif (!valid) {\n\t\tthrow new TypeError(`Expected data-listeners to be a widget listeners map with action identifiers (in ${JSON.stringify(str)})`);\n\t}\n\n\treturn resolveListenersMap(registry, listeners);\n}\n\nfunction resolveOptions(registry: ReadOnlyRegistry, registryProvider: RegistryProvider, element: Element, idFromAttributes?: string): Options {\n\tconst str = element.getAttribute('data-options') || '';\n\tif (!str) {\n\t\treturn idFromAttributes ? { id: idFromAttributes, registryProvider } : { registryProvider };\n\t}\n\n\tconst json = parseJsonAttribute<JsonOptions>('data-options', str);\n\tif ('id' in json) {\n\t\tthrow new Error(`Unexpected id value in data-options (in ${JSON.stringify(str)})`);\n\t}\n\tif ('listeners' in json) {\n\t\tthrow new Error(`Unexpected listeners value in data-options (in ${JSON.stringify(str)})`);\n\t}\n\tif ('registryProvider' in json) {\n\t\tthrow new Error(`Unexpected registryProvider value in data-options (in ${JSON.stringify(str)})`);\n\t}\n\tif ('state' in json) {\n\t\tthrow new Error(`Unexpected state value in data-options (in ${JSON.stringify(str)})`);\n\t}\n\tif ('stateFrom' in json) {\n\t\tthrow new Error(`Unexpected stateFrom value in data-options (in ${JSON.stringify(str)})`);\n\t}\n\n\t// Reassign, casted to the correct interface.\n\tconst options = <Options> json;\n\toptions.registryProvider = registryProvider;\n\tif (idFromAttributes) {\n\t\toptions.id = idFromAttributes;\n\t}\n\treturn options;\n}\n\nfunction getTransitionOptionFromProjector(element: Element): boolean {\n\tif (!element.hasAttribute('data-css-transitions')) {\n\t\treturn false;\n\t}\n\tconst value = element.getAttribute('data-css-transitions');\n\treturn value ? value === 'true' : true;\n}\n\nfunction resolveStateFromAttribute(registry: ReadOnlyRegistry, element: Element): null | Promise<StoreLike> {\n\tconst stateFrom = element.getAttribute('data-state-from');\n\treturn stateFrom ? registry.getStore(stateFrom) : null;\n}\n\nfunction getInitialState(element: Element): null | Object {\n\tconst str = element.getAttribute('data-state') || '';\n\tif (!str) {\n\t\treturn null;\n\t}\n\n\treturn parseJsonAttribute('data-state', str);\n}\n\nconst generateId = makeIdGenerator('custom-element-');\n\n/**\n * Realizes custom elements within a root element.\n *\n * @param defaultWidgetStore The default widget store of the app, may be null.\n * @param registerInstance Callback for registering new widget instances with the app\n * @param registry Read-only registry of actions, custom element factories, stores and widgets\n * @param registryProvider Registry provider, to be passed to custom element factories\n * @param root The element within which custom elements are realized\n *\n * @return A handle to detach rendered widgets from the DOM and remove them from the widget registry\n */\nexport default function realizeCustomElements(\n\taddIdentifier: (id: string) => Handle,\n\tregisterInstance: (widget: WidgetLike, id: string) => Handle,\n\tregistry: ReadOnlyRegistry,\n\tregistryProvider: RegistryProvider,\n\troot: Element,\n\tdefaultWidgetStore?: StoreLike,\n): Promise<Handle> {\n\t// Bottom up, breadth first queue of custom elements who's children's widgets need to be appended to\n\t// their own widget. Combined for all widget projectors.\n\tconst appendQueue: CustomElement[] = [];\n\t// For each projector, track the immediate custom element descendants. These placeholder\n\t// elements will be replaced with rendered widgets.\n\tconst immediatePlaceholderLookup = new Map<Projector, CustomElement[]>();\n\t// Projector instances for each widget projector.\n\tconst projectors: Projector[] = [];\n\t// Widgets that are created during realization (not registered instances).\n\tconst managedWidgets: WidgetLike[] = [];\n\t// Other handles that need to be cleaned up.\n\tconst handles: Handle[] = [];\n\n\t// Return a new promise here so API errors can be thrown in the executor, while still resulting in a\n\t// promise rejection.\n\treturn new Promise<WidgetLike[]>((resolve) => {\n\t\t// Flat list of all widgets that are being loaded.\n\t\tconst loadedWidgets: Promise<WidgetLike>[] = [];\n\n\t\tconst widgetProjectors = getCustomElementsByWidgetProjector(registry, root);\n\t\tfor (const { children, element: root } of widgetProjectors) {\n\t\t\tconst cssTransitions = getTransitionOptionFromProjector(root);\n\t\t\tconst projector = createProjector({ root, cssTransitions });\n\t\t\timmediatePlaceholderLookup.set(projector, children);\n\t\t\tprojectors.push(projector);\n\n\t\t\tconst projectorStateFrom = resolveStateFromAttribute(registry, root);\n\n\t\t\t// Recursion-free, depth first processing of the tree.\n\t\t\tlet processing = [children];\n\t\t\twhile (true) {\n\t\t\t\tconst next = processing.shift();\n\t\t\t\tif (!next) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tfor (const custom of next) {\n\t\t\t\t\tconst isWidgetInstance = custom.name === 'app-widget';\n\t\t\t\t\tlet id = getIdFromAttributes(custom.element);\n\n\t\t\t\t\tlet promise: Promise<WidgetLike>;\n\t\t\t\t\tif (isWidgetInstance) {\n\t\t\t\t\t\tif (!id) {\n\t\t\t\t\t\t\tthrow new Error('app-widget requires data-uid or id attribute');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpromise = registry.getWidget(id);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpromise = Promise.all<any>([\n\t\t\t\t\t\t\tregistry.getCustomElementFactory(custom.name),\n\t\t\t\t\t\t\tresolveListeners(registry, custom.element),\n\t\t\t\t\t\t\tresolveOptions(registry, registryProvider, custom.element, id),\n\t\t\t\t\t\t\tresolveStateFromAttribute(registry, custom.element),\n\t\t\t\t\t\t\tprojectorStateFrom\n\t\t\t\t\t\t]).then(([_factory, _listeners, _options, _store, projectorStore]) => {\n\t\t\t\t\t\t\tconst factory: WidgetFactory = _factory;\n\t\t\t\t\t\t\tconst listeners: EventedListenersMap = _listeners;\n\t\t\t\t\t\t\tconst options: WidgetFactoryOptions = _options;\n\t\t\t\t\t\t\t// `data-state-from` store of the element takes precedence, then of the projector, then\n\t\t\t\t\t\t\t// the application's default widget store.\n\t\t\t\t\t\t\tconst store: StoreLike = _store || projectorStore || defaultWidgetStore;\n\n\t\t\t\t\t\t\tid = options.id;\n\n\t\t\t\t\t\t\tif (listeners) {\n\t\t\t\t\t\t\t\toptions.listeners = listeners;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If the widget has an ID, and either its `data-state-from` attribute resolved to a store,\n\t\t\t\t\t\t\t// or there is a default store, set the stateFrom option to the `data-state-from` or default\n\t\t\t\t\t\t\t// widget store.\n\t\t\t\t\t\t\tif (id && store) {\n\t\t\t\t\t\t\t\toptions.stateFrom = store;\n\n\t\t\t\t\t\t\t\tconst initialState = getInitialState(custom.element);\n\t\t\t\t\t\t\t\tif (initialState) {\n\t\t\t\t\t\t\t\t\treturn store.add(initialState, { id })\n\t\t\t\t\t\t\t\t\t\t// Ignore error, assume store already contains state for this widget.\n\t\t\t\t\t\t\t\t\t\t.catch(() => undefined)\n\t\t\t\t\t\t\t\t\t\t.then(() => factory(options));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn factory(options);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tloadedWidgets.push(promise.then((widget) => {\n\t\t\t\t\t\t// Store the widget for easy access.\n\t\t\t\t\t\tcustom.widget = widget;\n\n\t\t\t\t\t\t// Widget instances come straight from the registry, but the other widgets were created\n\t\t\t\t\t\t// whilst realizing the custom elements. These should be managed.\n\t\t\t\t\t\tif (!isWidgetInstance) {\n\t\t\t\t\t\t\tmanagedWidgets.push(widget);\n\n\t\t\t\t\t\t\t// Assign a presumably unique ID if necessary. It's OK for the widget to not be aware of its\n\t\t\t\t\t\t\t// generated ID.\n\t\t\t\t\t\t\tif (!id) {\n\t\t\t\t\t\t\t\tid = generateId();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Belatedly ensure no other widget with this ID exists.\n\t\t\t\t\t\t\thandles.push(addIdentifier(id));\n\n\t\t\t\t\t\t\t// Add the instance to the various registries the app may maintain.\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\thandles.push(registerInstance(widget, id));\n\t\t\t\t\t\t\t} catch (_) {\n\t\t\t\t\t\t\t\t// registerInstance() will throw if the widget has already been registered. Throw a\n\t\t\t\t\t\t\t\t// friendlier error message.\n\t\t\t\t\t\t\t\tthrow new Error('Cannot attach a widget multiple times');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn widget;\n\t\t\t\t\t}));\n\n\t\t\t\t\tif (custom.children.length > 0) {\n\t\t\t\t\t\t// Ensure the children are processed.\n\t\t\t\t\t\tprocessing.push(custom.children);\n\t\t\t\t\t\t// Ensure the children are appended to their parent.\n\t\t\t\t\t\tappendQueue.unshift(custom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Wait for all widgets to be loaded in parallel.\n\t\tresolve(Promise.all(loadedWidgets));\n\t}).then((widgets) => {\n\t\t// Guard against improper widget usage.\n\t\tfor (const widget of widgets) {\n\t\t\t// <any> hammer because `widget` could be anything.\n\t\t\tif ((<any> widget).parent) {\n\t\t\t\tthrow new Error('Cannot attach a widget that already has a parent');\n\t\t\t}\n\t\t}\n\n\t\t// Build up the widget hierarchy.\n\t\tfor (const custom of appendQueue) {\n\t\t\tconst widgets = custom.children.map(child => child.widget);\n\t\t\t// Assume the widget has an append() method. Don't bother typing it since it's resolved dynamically anyway.\n\t\t\t(<any> custom.widget).append(widgets);\n\t\t}\n\n\t\t// Attach all projectors at the same time.\n\t\tconst attachedProjectors = projectors.map((projector) => {\n\t\t\t// The lookup is guaranteed to contain custom elements, which are guaranteed to have a widget.\n\t\t\t// Cast to the RealizedElement type to avoid strict null check violations.\n\t\t\ttype RealizedElement = CustomElement & { widget: WidgetLike }\n\t\t\tconst immediatePlaceholders = <RealizedElement[]> immediatePlaceholderLookup.get(projector);\n\t\t\timmediatePlaceholderLookup.delete(projector);\n\n\t\t\t// Append the top-level widgets to the projector.\n\t\t\tprojector.append(immediatePlaceholders.map(custom => custom.widget));\n\n\t\t\t// Get ready to replace the placeholder elements as soon as the widgets have rendered.\n\t\t\tconst handle = projector.on('attach', () => {\n\t\t\t\thandle.destroy();\n\n\t\t\t\tconst { root } = projector;\n\t\t\t\t// Rendered widgets start at this offset.\n\t\t\t\tconst offset = root.childNodes.length - immediatePlaceholders.length;\n\t\t\t\tfor (const { element: placeholder } of immediatePlaceholders) {\n\t\t\t\t\tplace(root.childNodes[offset], Position.Replace, placeholder);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Now attach the projector.\n\t\t\treturn projector.attach({ type: 'merge' });\n\t\t});\n\n\t\t// Wait for the projectors to be attached.\n\t\treturn Promise.all(attachedProjectors);\n\t}).then(() => {\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\tfor (const p of projectors) {\n\t\t\t\t\tp.destroy();\n\t\t\t\t}\n\t\t\t\tfor (const w of managedWidgets) {\n\t\t\t\t\tw.destroy();\n\t\t\t\t}\n\t\t\t\tfor (const h of handles) {\n\t\t\t\t\th.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/realizeCustomElements.ts","export default function parseJsonAttribute<O extends Object>(name: string, value: string): O {\n\tlet object: O;\n\ttry {\n\t\tobject = JSON.parse(value);\n\t}\n\tcatch (err) {\n\t\tthrow new SyntaxError(`Invalid ${name}: ${err.message} (in ${JSON.stringify(value)})`);\n\t}\n\tif (!object || typeof object !== 'object') {\n\t\tthrow new TypeError(`Expected object from ${name} (in ${JSON.stringify(value)})`);\n\t}\n\treturn object;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/parseJsonAttribute.ts","export default function makeIdGenerator(prefix: string): () => string {\n\tlet count = 0;\n\treturn () => prefix + (++count);\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/makeIdGenerator.ts","import { h, createProjector as createMaquetteProjector, Projector as MaquetteProjector, VNode, VNodeProperties } from 'maquette';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport { EventedListener, EventedOptions, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport global from 'dojo-core/global';\nimport { Handle } from 'dojo-core/interfaces';\nimport { assign } from 'dojo-core/lang';\nimport { queueTask } from 'dojo-core/queue';\nimport Promise from 'dojo-shim/Promise';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport createVNodeEvented, { VNodeEvented } from './mixins/createVNodeEvented';\nimport createParentListMixin, { ParentListMixin, ParentListMixinOptions } from './mixins/createParentListMixin';\nimport { Child } from './mixins/interfaces';\n\nexport type AttachType = 'append' | 'merge' | 'replace';\n\nexport interface ProjectorOptions extends ParentListMixinOptions<Child>, EventedOptions {\n\t/**\n\t * The root element for the projector\n\t */\n\troot?: Element;\n\n\t/**\n\t * If `true`, automatically attach to the DOM during creation (by merging). Do the same if a valid attach type is\n\t * provided (see `AttachOptions`). The attach type determines how the projector is attached.\n\t */\n\tautoAttach?: boolean | AttachType;\n\n\t/**\n\t * If `true`, will configure the projector to support css transitions using `cssTransitions` global object.\n\t * The projector will fail create if the options is true but the global object cannot be found.\n\t */\n\tcssTransitions?: boolean;\n}\n\nexport interface AttachOptions {\n\t/**\n\t * If `'append'` it will append to the root. If `'merge'` it will merge with the root. If `'replace'` it will\n\t * replace the root.\n\t */\n\n\ttype?: AttachType;\n\t/**\n\t * If `type` is `'append'` or `'replace'` then `tagName` will be used to determine what tag name\n\t * is used to append to or replace the root element. Defaults to `div`.\n\t */\n\ttagName?: string;\n}\n\nexport interface ProjectorMixin {\n\t/**\n\t * Get the projector's VNode attributes\n\t */\n\tgetNodeAttributes(overrides?: VNodeProperties): VNodeProperties;\n\n\t/**\n\t * Returns a VNode which represents the DOM for the projector\n\t */\n\trender(): VNode;\n\n\t/**\n\t * Attach the projector to the DOM and return a promise.\n\t *\n\t * The promise is fulfilled when all previously appended children have been created.\n\t * It is fulfilled with a handle which can be used to detach the projector. The same promise is\n\t * returned when called more than once.\n\t *\n\t * @param options An optional map of options that change the default behaviour of the attachment\n\t */\n\tattach(options?: AttachOptions): Promise<Handle>;\n\n\t/**\n\t * Inform the projector that it is in a dirty state and should re-render.  Calling event handles will automatically\n\t * schedule a re-render.\n\t */\n\tinvalidate(): void;\n\n\t/**\n\t * If unattached, set the root element for the projector.\n\t * @param root The Element that should serve as the root for the projector\n\t */\n\tsetRoot(root: Element): void;\n\n\t/**\n\t * The native maquette Projector that is being managed\n\t */\n\tprojector: MaquetteProjector;\n\n\t/**\n\t * The root of the projector\n\t */\n\troot: Element;\n\n\t/**\n\t * An array of classes that should be applied to the root of the projector\n\t */\n\tclasses?: string[];\n\n\t/**\n\t * A hash of inline styles that should be applied to the root of the projector\n\t */\n\tstyles?: { [style: string]: string; };\n\n\t/**\n\t * A reference to the document that the projector is attached to\n\t */\n\tdocument: Document;\n\n\t/**\n\t * The current state of the projector\n\t */\n\tstate: ProjectorState;\n}\n\nexport interface ProjectorOverrides {\n\t/**\n\t * Event emitted after the projector has been attached to the DOM.\n\t */\n\ton(type: 'attach', listener: EventedListener<TargettedEventObject>): Handle;\n\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport type Projector = VNodeEvented & ParentListMixin<Child> & ProjectorMixin;\n\nexport interface ProjectorFactory extends ComposeFactory<Projector, ProjectorOptions> { }\n\nexport enum ProjectorState {\n\tAttached = 1,\n\tDetached\n};\n\ninterface ProjectorData {\n\tafterInitialCreate?: () => void;\n\tattachHandle: Handle;\n\tattachPromise?: Promise<Handle>;\n\tboundRender: () => VNode;\n\tprojector: MaquetteProjector;\n\troot: Element;\n\tstate: ProjectorState;\n\ttagName: string;\n}\n\nconst projectorDataMap = new WeakMap<Projector, ProjectorData>();\n\nconst noopHandle = { destroy() { } };\nconst emptyVNode = h('div');\nconst noopVNode = function(): VNode { return emptyVNode; };\n\ninterface ProjectorAttributes {\n\n\tclasses?: {\n\t\t[index: string]: boolean | null | undefined;\n\t};\n\n\tstyles?: {\n\t\t[index: string]: string | null | undefined;\n\t};\n\n\t[index: string]: any;\n}\n\nexport const createProjector: ProjectorFactory = compose<ProjectorMixin, ProjectorOptions>({\n\t\tgetNodeAttributes(this: Projector, overrides?: VNodeProperties): VNodeProperties {\n\t\t\t/* TODO: This is the same logic as createCachedRenderMixin, merge somehow */\n\t\t\tconst props: ProjectorAttributes  = {};\n\t\t\tfor (let key in this.listeners) {\n\t\t\t\tprops[key] = this.listeners[key];\n\t\t\t}\n\t\t\tconst classes: { [index: string]: boolean; } = {};\n\t\t\tif (this.classes) {\n\t\t\t\tthis.classes.forEach((c) => classes[c] = true);\n\t\t\t}\n\t\t\tprops.classes = classes;\n\t\t\tprops.styles = this.styles || {};\n\t\t\tif (overrides) {\n\t\t\t\tassign(props, overrides);\n\t\t\t}\n\t\t\treturn props;\n\t\t},\n\t\trender(this: Projector): VNode {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\tconst childVNodes: VNode[] = [];\n\t\t\tthis.children.forEach((child) => {\n\t\t\t\t// Workaround for https://github.com/facebook/immutable-js/pull/919\n\t\t\t\t// istanbul ignore else\n\t\t\t\tif (child) {\n\t\t\t\t\tchildVNodes.push(child.render());\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst props = this.getNodeAttributes();\n\t\t\tprops.afterCreate = projectorData.afterInitialCreate;\n\t\t\treturn h(projectorData.tagName, props, childVNodes);\n\t\t},\n\t\tattach(this: Projector, { type, tagName }: AttachOptions = {}): Promise<Handle> {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\tif (projectorData.state === ProjectorState.Attached) {\n\t\t\t\treturn projectorData.attachPromise || Promise.resolve(noopHandle);\n\t\t\t}\n\t\t\tprojectorData.boundRender = this.render.bind(this);\n\t\t\tif (tagName !== undefined) {\n\t\t\t\tprojectorData.tagName = tagName;\n\t\t\t}\n\t\t\tprojectorData.state = ProjectorState.Attached;\n\t\t\tprojectorData.attachHandle = this.own({\n\t\t\t\tdestroy() {\n\t\t\t\t\tif (projectorData.state === ProjectorState.Attached) {\n\t\t\t\t\t\tprojectorData.projector.stop();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t/* Sometimes Maquette can't seem to find function */\n\t\t\t\t\t\t\tprojectorData.projector.detach(projectorData.boundRender);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\tif (e.message !== 'renderMaquetteFunction was not found') {\n\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* else, swallow */\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* for some reason, Maquette still trys to call this in some situations, so the noopVNode is\n\t\t\t\t\t\t * used to return an empty structure */\n\t\t\t\t\t\tprojectorData.boundRender = noopVNode;\n\t\t\t\t\t\tprojectorData.state = ProjectorState.Detached;\n\t\t\t\t\t}\n\t\t\t\t\tprojectorData.attachHandle = noopHandle;\n\t\t\t\t}\n\t\t\t});\n\t\t\tprojectorData.attachPromise = new Promise((resolve, reject) => {\n\t\t\t\tprojectorData.afterInitialCreate = () => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.emit({ type: 'attach' });\n\t\t\t\t\t\tresolve(projectorData.attachHandle);\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\n\t\t\t/* attaching async, in order to help ensure that if there are any other async behaviours scheduled at the end of the\n\t\t\t * turn, they are executed before this, since the attachement is actually done in turn, but subsequent schedule\n\t\t\t * renders are done out of turn */\n\t\t\tqueueTask(() => {\n\t\t\t\tconst { projector } = projectorData;\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\t\tprojector.append(projectorData.root, projectorData.boundRender);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'replace':\n\t\t\t\t\t\tprojector.replace(projectorData.root, projectorData.boundRender);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'merge':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprojector.merge(projectorData.root, projectorData.boundRender);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn projectorData.attachPromise;\n\t\t},\n\t\tinvalidate(this: Projector): void {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\tif (projectorData.state === ProjectorState.Attached) {\n\t\t\t\tthis.emit({\n\t\t\t\t\ttype: 'schedulerender',\n\t\t\t\t\ttarget: this\n\t\t\t\t});\n\t\t\t\tprojectorData.projector.scheduleRender();\n\t\t\t}\n\t\t},\n\t\tsetRoot(this: Projector, root: Element): void {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\tif (projectorData.state === ProjectorState.Attached) {\n\t\t\t\tthrow new Error('Projector already attached, cannot change root element');\n\t\t\t}\n\t\t\tprojectorData.root = root;\n\t\t},\n\n\t\tget root(this: Projector): Element {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\treturn projectorData && projectorData.root;\n\t\t},\n\n\t\tget projector(this: Projector): MaquetteProjector {\n\t\t\treturn projectorDataMap.get(this).projector;\n\t\t},\n\n\t\tget document(this: Projector): Document {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\treturn projectorData && projectorData.root && projectorData.root.ownerDocument;\n\t\t},\n\n\t\tget state(this: Projector): ProjectorState {\n\t\t\tconst projectorData = projectorDataMap.get(this);\n\t\t\treturn projectorData && projectorData.state;\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createVNodeEvented,\n\t\tinitialize(instance) {\n\t\t\t/* We have to stub out listeners for Maquette, otherwise it won't allow us to change them down the road */\n\t\t\tinstance.on('touchend', function () {});\n\t\t\tinstance.on('touchmove', function () {});\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createParentListMixin,\n\t\tinitialize(instance: Projector, { cssTransitions = false, autoAttach = false, root = document.body }: ProjectorOptions = {}) {\n\t\t\tconst options: { transitions?: any } = {};\n\t\t\tif (cssTransitions) {\n\t\t\t\tif (global.cssTransitions) {\n\t\t\t\t\toptions.transitions = global.cssTransitions;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error('Unable to create projector with css transitions enabled. Is the \\'css-transition.js\\' script loaded in the page?');\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst projector = createMaquetteProjector(options);\n\t\t\tprojectorDataMap.set(instance, {\n\t\t\t\tattachHandle: noopHandle,\n\t\t\t\tboundRender: noopVNode,\n\t\t\t\tprojector,\n\t\t\t\troot,\n\t\t\t\tstate: ProjectorState.Detached,\n\t\t\t\ttagName: 'div'\n\t\t\t});\n\t\t\tif (autoAttach === true) {\n\t\t\t\tinstance.attach({ type: 'merge' });\n\t\t\t}\n\t\t\telse if (typeof autoAttach === 'string') {\n\t\t\t\tinstance.attach({ type: autoAttach });\n\t\t\t}\n\t\t},\n\t\taspectAdvice: {\n\t\t\tafter: {\n\t\t\t\tclear(this: Projector): void {\n\t\t\t\t\tthis.invalidate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n// Projectors cannot be created outside of browser environments. Ensure that a default projector can always be\n// exported, even if it can't do anything.\nconst createStubbedProjector: ProjectorFactory = compose({\n\t\tgetNodeAttributes(): VNodeProperties {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\trender(): VNode {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tattach(): Promise<Handle> {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tinvalidate() {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tsetRoot(root: Element) {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tget projector(): MaquetteProjector {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tget root(): Element {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tget document(): Document {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t},\n\t\tget state(): ProjectorState {\n\t\t\tthrow new Error('Projector is stubbed');\n\t\t}\n\t})\n\t.mixin(createVNodeEvented)\n\t.mixin(createParentListMixin);\n\nconst defaultProjector: Projector = typeof global.document === 'undefined' ?\n\tcreateStubbedProjector() :\n\tcreateProjector();\n\nexport default defaultProjector;\n\n\n\n// WEBPACK FOOTER //\n// src/projector.ts","import global from './global';\nimport has from './has';\nimport { Handle } from 'dojo-interfaces/core';\n\nfunction executeTask(item: QueueItem | undefined): void {\n\tif (item && item.isActive && item.callback) {\n\t\titem.callback();\n\t}\n}\n\nfunction getQueueHandle(item: QueueItem, destructor?: (...args: any[]) => any): Handle {\n\treturn {\n\t\tdestroy: function (this: Handle) {\n\t\t\tthis.destroy = function () {};\n\t\t\titem.isActive = false;\n\t\t\titem.callback = null;\n\n\t\t\tif (destructor) {\n\t\t\t\tdestructor();\n\t\t\t}\n\t\t}\n\t};\n}\n\ninterface PostMessageEvent extends Event {\n\tsource: any;\n\tdata: string;\n}\n\nexport interface QueueItem {\n\tisActive: boolean;\n\tcallback: null | ((...args: any[]) => any);\n}\n\nlet checkMicroTaskQueue: () => void;\nlet microTasks: QueueItem[];\n\n/**\n * Schedules a callback to the macrotask queue.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport const queueTask = (function() {\n\tlet destructor: (...args: any[]) => any;\n\tlet enqueue: (item: QueueItem) => void;\n\n\t// Since the IE implementation of `setImmediate` is not flawless, we will test for `postMessage` first.\n\tif (has('postmessage')) {\n\t\tconst queue: QueueItem[] = [];\n\n\t\tglobal.addEventListener('message', function (event: PostMessageEvent): void {\n\t\t\t// Confirm that the event was triggered by the current window and by this particular implementation.\n\t\t\tif (event.source === global && event.data === 'dojo-queue-message') {\n\t\t\t\tevent.stopPropagation();\n\n\t\t\t\tif (queue.length) {\n\t\t\t\t\texecuteTask(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tqueue.push(item);\n\t\t\tglobal.postMessage('dojo-queue-message', '*');\n\t\t};\n\t}\n\telse if (has('setimmediate')) {\n\t\tdestructor = global.clearImmediate;\n\t\tenqueue = function (item: QueueItem): any {\n\t\t\treturn setImmediate(executeTask.bind(null, item));\n\t\t};\n\t}\n\telse {\n\t\tdestructor = global.clearTimeout;\n\t\tenqueue = function (item: QueueItem): any {\n\t\t\treturn setTimeout(executeTask.bind(null, item), 0);\n\t\t};\n\t}\n\n\tfunction queueTask(callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\t\tconst id: any = enqueue(item);\n\n\t\treturn getQueueHandle(item, destructor && function () {\n\t\t\tdestructor(id);\n\t\t});\n\t};\n\n\t// TODO: Use aspect.before when it is available.\n\treturn has('microtasks') ? queueTask : function (callback: (...args: any[]) => any): Handle {\n\t\tcheckMicroTaskQueue();\n\t\treturn queueTask(callback);\n\t};\n})();\n\n// When no mechanism for registering microtasks is exposed by the environment, microtasks will\n// be queued and then executed in a single macrotask before the other macrotasks are executed.\nif (!has('microtasks')) {\n\tlet isMicroTaskQueued = false;\n\n\tmicroTasks = [];\n\tcheckMicroTaskQueue = function (): void {\n\t\tif (!isMicroTaskQueued) {\n\t\t\tisMicroTaskQueued = true;\n\t\t\tqueueTask(function () {\n\t\t\t\tisMicroTaskQueued = false;\n\n\t\t\t\tif (microTasks.length) {\n\t\t\t\t\tlet item: QueueItem | undefined;\n\t\t\t\t\twhile (item = microTasks.shift()) {\n\t\t\t\t\t\texecuteTask(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Schedules an animation task with `window.requestAnimationFrame` if it exists, or with `queueTask` otherwise.\n *\n * Since requestAnimationFrame's behavior does not match that expected from `queueTask`, it is not used there.\n * However, at times it makes more sense to delegate to requestAnimationFrame; hence the following method.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport const queueAnimationTask = (function () {\n\tif (!has('raf')) {\n\t\treturn queueTask;\n\t}\n\n\tfunction queueAnimationTask(callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\t\tconst rafId: number = requestAnimationFrame(executeTask.bind(null, item));\n\n\t\treturn getQueueHandle(item, function () {\n\t\t\tcancelAnimationFrame(rafId);\n\t\t});\n\t}\n\n\t// TODO: Use aspect.before when it is available.\n\treturn has('microtasks') ? queueAnimationTask : function (callback: (...args: any[]) => any): Handle {\n\t\tcheckMicroTaskQueue();\n\t\treturn queueAnimationTask(callback);\n\t};\n})();\n\n/**\n * Schedules a callback to the microtask queue.\n *\n * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native\n * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask\n * registered with `queueTask` or `queueAnimationTask`.\n *\n * @param callback the function to be queued and later executed.\n * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.\n */\nexport let queueMicroTask = (function () {\n\tlet enqueue: (item: QueueItem) => void;\n\n\tif (has('host-node')) {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tglobal.process.nextTick(executeTask.bind(null, item));\n\t\t};\n\t}\n\telse if (has('es6-promise')) {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tglobal.Promise.resolve(item).then(executeTask);\n\t\t};\n\t}\n\telse if (has('dom-mutationobserver')) {\n\t\t/* tslint:disable-next-line:variable-name */\n\t\tconst HostMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\t\tconst node = document.createElement('div');\n\t\tconst queue: QueueItem[] = [];\n\t\tconst observer = new HostMutationObserver(function (): void {\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tconst item = queue.shift();\n\t\t\t\tif (item && item.isActive && item.callback) {\n\t\t\t\t\titem.callback();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tobserver.observe(node, { attributes: true });\n\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tqueue.push(item);\n\t\t\tnode.setAttribute('queueStatus', '1');\n\t\t};\n\t}\n\telse {\n\t\tenqueue = function (item: QueueItem): void {\n\t\t\tcheckMicroTaskQueue();\n\t\t\tmicroTasks.push(item);\n\t\t};\n\t}\n\n\treturn function (callback: (...args: any[]) => any): Handle {\n\t\tconst item: QueueItem = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\n\t\tenqueue(item);\n\n\t\treturn getQueueHandle(item);\n\t};\n})();\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/queue.ts","import has from './has';\nimport { CreateArgs, CreateFunction } from './interfaces';\n\n/**\n * Validates a token for the CSS class manipulation methods.\n */\nfunction validateToken(token: string): void {\n\tif (token === '') {\n\t\tthrow new Error('An invalid or illegal string was specified');\n\t}\n\tif (/\\s/.test(token)) {\n\t\tthrow new Error('String contains an invalid character');\n\t}\n}\n\n/**\n * Adds one or more CSS class names to an HTMLElement, without duplication.\n *\n * @param element The Element to which to add CSS classes\n * @param classes One or more CSS class strings to add to the Element\n *\n * @example\n * dom.addClass(document.body, 'loaded');\n *\n * @example\n * dom.addClass(document.body, 'loaded', 'ready');\n */\nexport function addClass(element: HTMLElement, ...classes: string[]): void {\n\t// Cast to <any> to support multiple Element types. For more info,\n\t// see https://github.com/Microsoft/TypeScript/issues/3220\n\tlet targetElement = <any> element;\n\tif (!targetElement || !classes.length) {\n\t\treturn;\n\t}\n\tlet newClasses: string[] = [];\n\tfor (let className of classes) {\n\t\tvalidateToken(className);\n\t\tif (!containsClass(targetElement, className)) {\n\t\t\t// Convert to string to match native classList implementations for values like null\n\t\t\tnewClasses.push(String(className));\n\t\t}\n\t}\n\tif (newClasses.length) {\n\t\ttargetElement.className += (targetElement.className.length ? ' ' : '') + newClasses.join(' ');\n\t}\n}\n\n/**\n * Applies CSS classes to the root element if the specified has features have truthy values.\n *\n * @param features One or more features to test and potentially apply CSS classes based on\n */\nexport function applyFeatureClass(...features: string[]) {\n\t// args will be applied to addClass, so start with the element classes will be added to\n\tlet args: any[] = [ document.documentElement ];\n\tfor (let feature of features) {\n\t\tif (has(feature)) {\n\t\t\targs.push('has-' + feature.replace(/\\s/g, '-'));\n\t\t}\n\t}\n\taddClass.apply(null, args);\n}\n\n/**\n * Retrieves an element from the document by its ID attribute.\n *\n * @param id ID to match in the DOM\n * @return the element with a matching ID attribute if found, otherwise null\n *\n * @example\n * let element = dom.byId('anElement');\n */\nexport function byId(id: string): HTMLElement | null {\n\treturn document.getElementById(id);\n}\n\n/**\n * Indicates whether the given parent contains the given node.\n * @param parent The parent node to check within\n * @param node The node to test whether parent is its ancestor\n * @return `true` if parent contains node, `false` otherwise\n */\nexport function contains(parent: Element, node: Node): boolean {\n\t// While modern browsers do support parent.contains, some support it only on HTML elements,\n\t// and IE has a known bug involving passing a text node as the argument:\n\t// https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n\t// Meanwhile, compareDocumentPosition works in all supported browsers.\n\n\tif (node == null) {\n\t\treturn false;\n\t}\n\tif (parent === node) {\n\t\treturn true;\n\t}\n\treturn Boolean(node.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS);\n}\n\n/*\n * Creates an Element.\n *\n * @param tagName Type of Element to create\n * @param kwArgs An object containing properties to add to the Element.\n *               If an \"attributes\" property is present, each member of this sub-object will be added to the Element\n *               via element.setAttribute\n * @param children An array of Nodes or strings, the latter of which will be converted to Text nodes\n * @return The created Element, with any passed properties/attributes applied\n *\n * @example\n * let div = dom.create('div', { className: 'loaded', attributes: { 'data-index': '1' } });\n *\n * @example\n * let div = dom.create('ul', null, [ dom.create('li'), dom.create('li') ]);\n *\n * @example\n * let div = dom.create('div', null, [ 'hello', ' ', 'world' ]);\n */\n\nexport let create: CreateFunction = function (\n\t\ttagName: string, kwArgs?: CreateArgs, children?: (Node | string)[]): any {\n\tconst element = document.createElement(tagName);\n\tif (children) {\n\t\tfor (let child of children) {\n\t\t\tif (typeof child === 'string') {\n\t\t\t\tchild = document.createTextNode(<string> child);\n\t\t\t}\n\t\t\telement.appendChild(<Node> child);\n\t\t}\n\t}\n\tif (kwArgs) {\n\t\tfor (let property in kwArgs) {\n\t\t\tif (property === 'attributes') {\n\t\t\t\tif (kwArgs.attributes) {\n\t\t\t\t\tfor (let attribute in kwArgs.attributes) {\n\t\t\t\t\t\telement.setAttribute(attribute, kwArgs.attributes[attribute]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(<any> element)[property] = kwArgs[property];\n\t\t\t}\n\t\t}\n\t}\n\treturn element;\n};\n\n// Tag trees for element creation, used by fromString\nconst tagWrap: {[key: string]: any} = {\n\tcaption: [ 'table' ],\n\tcol: [ 'table', 'colgroup' ],\n\tcolgroup: [ 'table' ],\n\toptgroup: [ 'select' ],\n\toption: [ 'select' ],\n\trp: [ 'ruby' ],\n\trt: [ 'ruby' ],\n\trtc: [ 'ruby' ],\n\tsource: [ 'audio' ],\n\ttbody: [ 'table' ],\n\ttd: [ 'table', 'tbody', 'tr' ],\n\ttfoot: [ 'table' ],\n\tth: [ 'table', 'thead', 'tr' ],\n\tthead: [ 'table' ],\n\ttr: [ 'table', 'tbody' ]\n};\n\nfor (const param in tagWrap) {\n\tconst tw = tagWrap[param];\n\ttw.pre = param === 'option' ? '<select multiple=\"multiple\">' : '<' + tw.join('><') + '>';\n\ttw.post = '</' + tw.reverse().join('></') + '>';\n}\n\n/**\n * Determines whether an HTMLElement has a given CSS class name.\n *\n * @param element The Element to check for a CSS class\n * @param className The CSS class name to check for\n *\n * @example\n * let hasLoaded = dom.containsClass(document.body, 'loaded');\n */\nexport function containsClass(element: HTMLElement, className: string): boolean | void {\n\tlet targetElement = <any> element;\n\tif (!targetElement) {\n\t\treturn;\n\t}\n\tvalidateToken(className);\n\tlet targetClass = ' ' + targetElement.className + ' ';\n\treturn targetClass.indexOf(' ' + className + ' ') > -1;\n}\n\n/**\n * Creates a DocumentFragment from a string.\n *\n * @param html string representation of nodes to create\n * @return DocumentFragment containing childNodes based on html string\n *\n * @example\n * let fragment = dom.fromString('<div></div>');\n *\n * @example\n * let fragment = dom.fromString('<div></div><span></span>');\n *\n * @example\n * let fragment = dom.fromString('<tr>');\n */\nexport function fromString(html: string): DocumentFragment  {\n\tlet fragment: DocumentFragment;\n\tconst useContextualFragment = has('dom-contextual-fragment');\n\n\tlet master: HTMLElement = document.createElement('div');\n\tconst match = String(html).match(/<\\s*([\\w\\:]+)/);\n\tconst tag = match ? match[1].toLowerCase() : '';\n\n\tfunction unwrapElement(element: HTMLElement, levels: number): HTMLElement {\n\t\tfor (let i = 0; i < levels; i++) {\n\t\t\telement = <HTMLElement> element.firstChild;\n\t\t}\n\n\t\treturn element;\n\t}\n\n\tif (useContextualFragment) {\n\t\tmaster.style.display = 'none';\n\t\tdocument.body.appendChild(master);\n\t\tconst range = document.createRange();\n\t\trange.selectNode(master);\n\n\t\tif (match && tagWrap[tag]) {\n\t\t\tconst wrap = tagWrap[tag];\n\t\t\tconst wrappedHTML = wrap.pre + html + wrap.post;\n\t\t\tfragment = range.createContextualFragment(wrappedHTML);\n\t\t\tfragment = unwrapElement(<HTMLElement> fragment, wrap.length);\n\t\t}\n\t\telse {\n\t\t\tfragment = range.createContextualFragment(html);\n\t\t}\n\t}\n\telse {\n\t\tif (match && tagWrap[tag]) {\n\t\t\tconst wrap = tagWrap[tag];\n\t\t\tconst wrappedHTML = wrap.pre + html + wrap.post;\n\t\t\tmaster.innerHTML = wrappedHTML;\n\t\t\tmaster = unwrapElement(master, wrap.length);\n\t\t}\n\t\telse {\n\t\t\tmaster.innerHTML = html;\n\t\t}\n\n\t\tfragment = document.createDocumentFragment();\n\t\tlet firstChild: Node;\n\t\twhile (firstChild = master.firstChild) {\n\t\t\tfragment.appendChild(firstChild);\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n/*\n * Positions used with the place API for node placement.\n */\nexport enum Position {\n\tAfter,\n\tBefore,\n\tFirstIn,\n\tLastIn,\n\tReplace\n}\n\n/**\n * Places a node in the DOM relative to another node.\n *\n * @param node The node to place in the DOM\n * @param position The position to place the node, relative to relativeElement\n * @param relativeElement The node to use as a reference when placing\n *\n * @example\n * dom.place(node, dom.Position.After, anotherNode);\n */\nexport function place(node: Node, position: Position, relativeElement: Element): void {\n\tlet parent: Node;\n\n\tif (position === Position.After || position === Position.Before || position === Position.Replace) {\n\t\tparent = relativeElement.parentNode;\n\t\tif (!parent) {\n\t\t\tthrow new ReferenceError('dom.place: Reference node must have a parent to determine placement');\n\t\t}\n\t\tif (position === Position.After) {\n\t\t\tif (parent.lastChild === relativeElement) {\n\t\t\t\tparent.appendChild(node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent.insertBefore(node, relativeElement.nextSibling);\n\t\t\t}\n\t\t}\n\t\telse if (position === Position.Before) {\n\t\t\tparent.insertBefore(node, relativeElement);\n\t\t}\n\t\telse if (position === Position.Replace) {\n\t\t\tparent.replaceChild(node, relativeElement);\n\t\t}\n\t}\n\telse if (position === Position.FirstIn) {\n\t\trelativeElement.insertBefore(node, relativeElement.firstChild);\n\t}\n\telse {\n\t\t// LastIn\n\t\trelativeElement.appendChild(node);\n\t}\n}\n\n/**\n * Removes a node from the DOM.\n *\n * @param node The node to remove\n */\nexport function remove(node: Node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * Removes all instances of one ore more CSS class names from an HTMLElement.\n *\n * @param element The Element from which to remove CSS classes\n * @param classes An array of string CSS classes to remove from the Element\n *\n * @example\n * dom.removeClass(document.body, 'loading');\n *\n * @example\n * dom.removeClass(document.body, 'loading', 'pending');\n */\nexport function removeClass(element: HTMLElement, ...classes: string[]): void {\n\tlet targetElement = <any> element;\n\tif (!targetElement) {\n\t\treturn;\n\t}\n\tlet oldClasses: string[] = targetElement.className.split(/\\s+/);\n\tlet length = oldClasses.length;\n\tfor (let className of classes) {\n\t\tclassName = String(className);\n\t\tvalidateToken(className);\n\t\tlet index = oldClasses.indexOf(className);\n\t\twhile (index !== -1) {\n\t\t\toldClasses.splice(index, 1);\n\t\t\tindex = oldClasses.indexOf(className);\n\t\t}\n\t}\n\tif (oldClasses.length < length) {\n\t\ttargetElement.className = oldClasses.join(' ');\n\t}\n}\n\n/**\n * Toggles the presence of a CSS class name on an HTMLElement. An optional\n * second parameter can be used to force class addition or removal.\n *\n * @param element The Element to add or remove classes to or from\n * @param className The CSS class name add or remove\n * @param force Forces either class addition if true or class removal if false\n *\n * @example\n * dom.toggleClass(button, 'active');\n *\n * @example\n * dom.toggleClass(button, 'active', isActive);\n */\nexport function toggleClass(element: HTMLElement, className: string, force: boolean = !containsClass(element, className)): boolean {\n\tconst func = force ? addClass : removeClass;\n\tfunc(element, className);\n\treturn force;\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-dom/dom.ts","import { add } from 'dojo-core/has';\n\nadd('dom-element-matches', function () {\n\tlet node = document.body;\n\t// TS typings include the vendor-prefixed methods used here, but not the standard\n\tif (typeof (<any> node).matches === 'function') {\n\t\treturn 'matches';\n\t}\n\tif (typeof node.msMatchesSelector === 'function') {\n\t\treturn 'msMatchesSelector';\n\t}\n\tif (typeof node.webkitMatchesSelector === 'function') {\n\t\treturn 'webkitMatchesSelector';\n\t}\n});\n\nadd('dom-contextual-fragment', function() {\n\treturn Boolean(Range && Range.prototype.createContextualFragment);\n});\n\nexport { default } from 'dojo-core/has';\nexport * from 'dojo-core/has';\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-dom/has.ts","import { EventedListener, EventedListenersMap, TargettedEventObject } from 'dojo-compose/mixins/createEvented';\nimport Promise from 'dojo-shim/Promise';\n\nimport {\n\tReadOnlyRegistry,\n\tWidgetListenersMap,\n\tWidgetListenerOrArray\n} from '../createApp';\n\n// Use generics to avoid annoying repetition of the EventedListener<TargettedEventObject> type.\ntype ResolvedListeners<T> = [T[], undefined] | [undefined, Promise<T[]>];\nfunction carriesValue<T>(result: ResolvedListeners<T>): result is [T[], undefined] {\n\treturn result[0] !== undefined;\n}\n\ntype MixedResultOverride<T> = {\n\t// Property on the array to track whether it contains promises, which makes the withoutPromises() type\n\t// guard possible.\n\tcontainsPromises?: boolean;\n\t// These seem to need to be redeclared. Declared them as narrowly as possible for the actual usage below.\n\tpush(result: T[]): number;\n\tpush(result: Promise<T[]>): number;\n};\ntype MixedResults<T> = (T[][] | (T[] | Promise<T[]>)[]) & MixedResultOverride<T>;\nfunction withoutPromises<T>(mixed: MixedResults<T>): mixed is T[][] & MixedResultOverride<T> {\n\treturn mixed.containsPromises !== true;\n}\n\nfunction resolveListeners(\n\tregistry: ReadOnlyRegistry,\n\tref: WidgetListenerOrArray\n): ResolvedListeners<EventedListener<TargettedEventObject>> {\n\tif (Array.isArray(ref)) {\n\t\tconst mixed: MixedResults<EventedListener<TargettedEventObject>> = [];\n\t\tfor (const item of ref) {\n\t\t\tconst result = resolveListeners(registry, item);\n\t\t\tif (carriesValue(result)) {\n\t\t\t\tmixed.push(result[0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmixed.containsPromises = true;\n\t\t\t\tmixed.push(result[1]);\n\t\t\t}\n\t\t}\n\n\t\tconst flattened: EventedListener<TargettedEventObject>[] = [];\n\t\tif (withoutPromises(mixed)) {\n\t\t\treturn [flattened.concat(...mixed), undefined];\n\t\t}\n\n\t\treturn [\n\t\t\tundefined,\n\t\t\tPromise.all(mixed)\n\t\t\t\t.then((results) => flattened.concat(...results))\n\t\t];\n\t}\n\n\tif (typeof ref !== 'string') {\n\t\treturn [ [ <EventedListener<TargettedEventObject>> ref ], undefined ];\n\t}\n\n\treturn [\n\t\tundefined,\n\t\tregistry.getAction(ref).then((action) => [ action ])\n\t];\n}\n\nexport default function resolveListenersMap(registry: ReadOnlyRegistry, listeners?: WidgetListenersMap): null | Promise<EventedListenersMap> {\n\tif (!listeners) {\n\t\treturn null;\n\t}\n\n\tconst map: EventedListenersMap = {};\n\tconst eventTypes = Object.keys(listeners);\n\treturn eventTypes.reduce((promise, eventType) => {\n\t\tconst result = resolveListeners(registry, listeners[eventType]);\n\t\tif (carriesValue(result)) {\n\t\t\tconst arr = result[0];\n\t\t\tmap[eventType] = arr.length > 1 ? arr : arr[0];\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn result[1].then((arr) => {\n\t\t\tmap[eventType] = arr.length > 1 ? arr : arr[0];\n\t\t\treturn promise;\n\t\t});\n\t}, Promise.resolve(map));\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/resolveListenersMap.ts","import Promise from 'dojo-shim/Promise';\nimport Symbol from 'dojo-shim/Symbol';\n\n/**\n * Internal interface to asynchronously resolve a module by its identifier.\n */\nexport interface ResolveMid {\n\t/**\n\t * Resolves a module export based on its identifier.\n\t *\n\t * @param mid The module identifier\n\t * @param member If not provided the default export is returned. If the `RESOLVE_CONTENTS` symbol an object is\n\t *   returned containing all non-default expors. Else returns the requested member.\n\t * @return A promise for the resolved export(s). Does not reject if the module could not be loaded, or if the\n\t *   requested export does not exist.\n\t */\n\t<T>(mid: string, member?: string | symbol): Promise<T>;\n}\n\n/**\n * Function that maps a (relative) module identifier to an absolute one.\n */\nexport interface ToAbsMid {\n\t(moduleId: string): string;\n}\n\n/**\n * Special value that can be provided to the module resolver, indicating it should resolve the module contents, not\n * just a particular export.\n */\nexport const RESOLVE_CONTENTS = Symbol();\n\n/**\n * Creates a module resolver.\n *\n * @param toAbsMid Function to resolve relative module identifiers\n * @return The resolver function\n */\nexport default function makeResolver(toAbsMid: ToAbsMid): ResolveMid {\n\treturn function resolveMid<T>(mid: string, member: string | symbol = 'default'): Promise<T> {\n\t\treturn new Promise((resolve) => {\n\t\t\t// Assumes require() is an AMD loader!\n\t\t\trequire([toAbsMid(mid)], resolve);\n\t\t})\n\t\t.then((module: any) => {\n\t\t\tif (member === 'default') {\n\t\t\t\treturn module.__esModule ? module.default : module;\n\t\t\t}\n\t\t\telse if (member === RESOLVE_CONTENTS) {\n\t\t\t\tconst contents: { [member: string]: any } = {};\n\t\t\t\tfor (const member of Object.keys(module)) {\n\t\t\t\t\tif (member !== '__esModule' && member !== 'default') {\n\t\t\t\t\t\tcontents[member] = module[member];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn contents;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn module[member];\n\t\t\t}\n\t\t});\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/moduleResolver.ts","import { Handle } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-shim/WeakMap';\n\nimport {\n\tActionLike,\n\tIdentifier,\n\tStoreLike,\n\tWidgetLike\n} from '../createApp';\n\ntype Instance = ActionLike | StoreLike | WidgetLike;\nenum Type { Action, Store, Widget };\nconst errorStrings: { [type: number]: string } = {\n\t[Type.Action]: 'action',\n\t[Type.Store]: 'store',\n\t[Type.Widget]: 'widget'\n};\n\nexport default class InstanceRegistry {\n\tprivate readonly map = new WeakMap<Instance, { id: Identifier | symbol, type: Type }>();\n\n\taddAction(action: ActionLike, id: Identifier): Handle {\n\t\treturn this.add(action, id, Type.Action);\n\t}\n\n\tidentifyAction(action: ActionLike): Identifier {\n\t\treturn this.identify(action, Type.Action);\n\t}\n\n\taddStore(store: StoreLike, id: Identifier | symbol): Handle {\n\t\treturn this.add(store, id, Type.Store);\n\t}\n\n\tidentifyStore(store: StoreLike): Identifier | symbol {\n\t\treturn this.identify(store, Type.Store);\n\t}\n\n\taddWidget(widget: WidgetLike, id: Identifier): Handle {\n\t\treturn this.add(widget, id, Type.Widget);\n\t}\n\n\tidentifyWidget(widget: WidgetLike): Identifier {\n\t\treturn this.identify(widget, Type.Widget);\n\t}\n\n\tprivate add(instance: ActionLike, id: Identifier, type: Type): Handle;\n\tprivate add(instance: StoreLike, id: Identifier | symbol, type: Type): Handle;\n\tprivate add(instance: WidgetLike, id: Identifier, type: Type): Handle;\n\tprivate add(instance: Instance, id: Identifier | symbol, type: Type): Handle {\n\t\tif (this.map.has(instance)) {\n\t\t\tconst existing = this.map.get(instance);\n\t\t\tthrow new Error(`Could not add ${errorStrings[type]}, already registered as ${errorStrings[existing.type]} with identity ${existing.id}`);\n\t\t}\n\n\t\tthis.map.set(instance, { id, type });\n\t\tconst handle = {\n\t\t\tdestroy: () => {\n\t\t\t\tthis.map.delete(instance);\n\t\t\t}\n\t\t};\n\t\treturn handle;\n\t}\n\n\tprivate identify(instance: ActionLike, expectedType: Type): string;\n\tprivate identify(instance: StoreLike, expectedType: Type): string | symbol;\n\tprivate identify(instance: WidgetLike, expectedType: Type): string;\n\tprivate identify(instance: Instance, expectedType: Type): string | symbol {\n\t\tif (!this.map.has(instance)) {\n\t\t\tthrow new Error(`Could not identify ${errorStrings[expectedType]}`);\n\t\t}\n\n\t\tconst { id, type } = this.map.get(instance);\n\t\tif (type !== expectedType) {\n\t\t\tthrow new Error(`Could not identify ${errorStrings[expectedType]}`);\n\t\t}\n\n\t\treturn id;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/InstanceRegistry.ts","import { EventedListenersMap } from 'dojo-compose/mixins/createEvented';\nimport { assign } from 'dojo-core/lang';\nimport Promise from 'dojo-shim/Promise';\n\nimport {\n\tActionDefinition,\n\tActionFactory,\n\tActionLike,\n\tCustomElementDefinition,\n\tItemDefinition,\n\tReadOnlyRegistry,\n\tStoreDefinition,\n\tStoreFactory,\n\tStoreLike,\n\tWidgetDefinition,\n\tWidgetFactory,\n\tWidgetFactoryOptions,\n\tWidgetLike\n} from '../createApp';\nimport { ResolveMid } from './moduleResolver';\nimport resolveListenersMap from './resolveListenersMap';\n\nfunction resolveStore(registry: ReadOnlyRegistry, definition: ActionDefinition | WidgetDefinition): null | StoreLike | Promise<StoreLike> {\n\tconst { stateFrom } = definition;\n\tif (!stateFrom) {\n\t\treturn null;\n\t}\n\n\tif (typeof stateFrom !== 'string') {\n\t\treturn stateFrom;\n\t}\n\n\treturn registry.getStore(<string> stateFrom);\n}\n\ntype Factory = ActionFactory | StoreFactory | WidgetFactory;\ntype Instance = ActionLike | StoreLike | WidgetLike;\ntype FactoryTypes = 'action' | 'customElement' | 'store' | 'widget';\nconst errorStrings: { [type: string]: string } = {\n\taction: 'an action',\n\tcustomElement: 'a widget',\n\tstore: 'a store',\n\twidget: 'a widget'\n};\n\nfunction isInstance(value: any): value is Instance {\n\treturn value && typeof value === 'object';\n}\n\n// Used as a cast for definitions passed to resolveFactory(). The definitions need to be cast because\n// CustomElementDefinition does not have an `instance` property. Note that at this point the definition has already\n// been validated to ensure it has either a factory or an instance.\ninterface DestructurableDefinition {\n\tinstance?: Instance | string;\n\tfactory?: Factory | string;\n}\n\n/**\n * Resolve a factory for an action, custom element, store or widget.\n *\n * Custom element definitions must have a `factory` field. Other definitions have either `instance` or `factory`\n * fields. These may be module identifiers. If necessary resolve the module identifier, then if an instance was\n * defined create a wrapper function that can act as a factory for that instance.\n *\n * @param type What type of factory needs to be resolved\n * @param definition Definition of the action, store or widget that is resolved\n * @param resolveMid Function to asynchronously resolve a module identifier\n * @return A promise for the factory. Rejects if the resolved module does not export an appropriate default\n */\nfunction resolveFactory(type: 'action', definition: ActionDefinition, resolveMid: ResolveMid): Promise<ActionFactory>;\nfunction resolveFactory(type: 'customElement', definition: CustomElementDefinition, resolveMid: ResolveMid): Promise<WidgetFactory>;\nfunction resolveFactory(type: 'store', definition: StoreDefinition, resolveMid: ResolveMid): Promise<StoreFactory>;\nfunction resolveFactory(type: 'widget', definition: WidgetDefinition, resolveMid: ResolveMid): Promise<WidgetFactory>;\nfunction resolveFactory(type: FactoryTypes, definition: CustomElementDefinition | ItemDefinition<Factory, Instance>, resolveMid: ResolveMid): Promise<Factory>;\nfunction resolveFactory(type: FactoryTypes, definition: CustomElementDefinition | ItemDefinition<Factory, Instance>, resolveMid: ResolveMid): Promise<Factory> {\n\tconst { factory, instance } = <DestructurableDefinition> definition;\n\n\tif (typeof factory === 'function') {\n\t\treturn Promise.resolve(factory);\n\t}\n\telse if (isInstance(instance)) {\n\t\t// Cast to Factory since TypeScript gets confused with the overloaded Factory types that can return promises.\n\t\tconst factory = (() => instance) as Factory;\n\t\treturn Promise.resolve(factory);\n\t}\n\telse {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (instance) {\n\t\t\t\tresolveMid<Instance>(instance)\n\t\t\t\t\t.then((defaultExport) => {\n\t\t\t\t\t\tif (!defaultExport || typeof defaultExport !== 'object') {\n\t\t\t\t\t\t\treject(new Error(`Could not resolve '${instance}' to ${errorStrings[type]} instance`));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(() => defaultExport);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(reject);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Calling code ensures that factory at this point is a string, even though TypeScript can't infer that.\n\t\t\t\tresolveMid<Factory>(<string> factory)\n\t\t\t\t\t.then((defaultExport) => {\n\t\t\t\t\t\tif (typeof defaultExport !== 'function') {\n\t\t\t\t\t\t\treject(new Error(`Could not resolve '${factory}' to ${errorStrings[type]} factory function`));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(defaultExport);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(reject);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function makeActionFactory(definition: ActionDefinition, resolveMid: ResolveMid, registry: ReadOnlyRegistry): ActionFactory {\n\tif (!('factory' in definition || 'instance' in definition)) {\n\t\tthrow new TypeError('Action definitions must specify either the factory or instance option');\n\t}\n\tif ('instance' in definition) {\n\t\tif ('state' in definition) {\n\t\t\tthrow new TypeError('Cannot specify state option when action definition points directly at an instance');\n\t\t}\n\t\tif ('stateFrom' in definition) {\n\t\t\tthrow new TypeError('Cannot specify stateFrom option when action definition points directly at an instance');\n\t\t}\n\t}\n\n\tconst { id, state: initialState } = definition;\n\treturn ({ registryProvider, stateFrom: defaultActionStore }) => {\n\t\treturn Promise.all<any>([\n\t\t\tresolveFactory('action', definition, resolveMid),\n\t\t\tresolveStore(registry, definition)\n\t\t]).then(([_factory, _store]) => {\n\t\t\tconst factory = <ActionFactory> _factory;\n\t\t\tconst store = <StoreLike> _store || defaultActionStore;\n\n\t\t\tconst options = { registryProvider, stateFrom: store };\n\n\t\t\tif (store && initialState) {\n\t\t\t\treturn store.add(initialState, { id })\n\t\t\t\t\t// Ignore error, assume store already contains state for this widget.\n\t\t\t\t\t.catch(() => {})\n\t\t\t\t\t.then(() => factory(options));\n\t\t\t}\n\n\t\t\treturn factory(options);\n\t\t});\n\t};\n}\n\nexport function makeCustomElementFactory(definition: CustomElementDefinition, resolveMid: ResolveMid): WidgetFactory {\n\tlet promise: Promise<void> | null = null;\n\tlet factory: WidgetFactory;\n\treturn (options: WidgetFactoryOptions) => {\n\t\tif (factory) {\n\t\t\treturn factory(options);\n\t\t}\n\n\t\tif (!promise) {\n\t\t\t// Memoize the factory resolution.\n\t\t\tpromise = resolveFactory('customElement', definition, resolveMid).then((result) => {\n\t\t\t\tfactory = result;\n\t\t\t\tpromise = null;\n\t\t\t});\n\t\t}\n\n\t\treturn promise.then(() => {\n\t\t\treturn factory(options);\n\t\t});\n\t};\n}\n\nexport function makeStoreFactory(definition: StoreDefinition, resolveMid: ResolveMid): StoreFactory {\n\tif (!('factory' in definition || 'instance' in definition)) {\n\t\tthrow new TypeError('Store definitions must specify either the factory or instance option');\n\t}\n\tif ('instance' in definition && 'options' in definition) {\n\t\tthrow new TypeError('Cannot specify options when store definition points directly at an instance');\n\t}\n\n\tconst options = assign({}, definition.options);\n\n\treturn () => {\n\t\treturn resolveFactory('store', definition, resolveMid).then((factory) => {\n\t\t\treturn factory(options);\n\t\t});\n\t};\n}\n\nexport function makeWidgetFactory(definition: WidgetDefinition, resolveMid: ResolveMid, registry: ReadOnlyRegistry): WidgetFactory {\n\tif (!('factory' in definition || 'instance' in definition)) {\n\t\tthrow new TypeError('Widget definitions must specify either the factory or instance option');\n\t}\n\tif ('instance' in definition) {\n\t\tif ('listeners' in definition) {\n\t\t\tthrow new TypeError('Cannot specify listeners option when widget definition points directly at an instance');\n\t\t}\n\t\tif ('state' in definition) {\n\t\t\tthrow new TypeError('Cannot specify state option when widget definition points directly at an instance');\n\t\t}\n\t\tif ('stateFrom' in definition) {\n\t\t\tthrow new TypeError('Cannot specify stateFrom option when widget definition points directly at an instance');\n\t\t}\n\t\tif ('options' in definition) {\n\t\t\tthrow new TypeError('Cannot specify options when widget definition points directly at an instance');\n\t\t}\n\t}\n\n\tconst { options: rawOptions } = definition;\n\tif (rawOptions) {\n\t\tif ('id' in rawOptions || 'listeners' in rawOptions || 'stateFrom' in rawOptions) {\n\t\t\tthrow new TypeError('id, listeners and stateFrom options should be in the widget definition itself, not its options value');\n\t\t}\n\t\tif ('registryProvider' in rawOptions) {\n\t\t\tthrow new TypeError('registryProvider option must not be specified');\n\t\t}\n\t}\n\n\treturn ({ registryProvider, stateFrom: defaultWidgetStore }: WidgetFactoryOptions) => {\n\t\tconst { id, state: initialState } = definition;\n\t\tconst options: WidgetFactoryOptions = assign({\n\t\t\tid,\n\t\t\tregistryProvider\n\t\t}, rawOptions);\n\n\t\treturn Promise.all<any>([\n\t\t\tresolveFactory('widget', definition, resolveMid),\n\t\t\tresolveListenersMap(registry, definition.listeners),\n\t\t\tresolveStore(registry, definition)\n\t\t]).then(([_factory, _listeners, _store]) => {\n\t\t\tconst factory = <WidgetFactory> _factory;\n\t\t\tconst listeners = <EventedListenersMap> _listeners;\n\t\t\tconst store = <StoreLike> _store || defaultWidgetStore;\n\n\t\t\tif (listeners) {\n\t\t\t\toptions.listeners = listeners;\n\t\t\t}\n\t\t\tif (store) {\n\t\t\t\toptions.stateFrom = store;\n\t\t\t}\n\n\t\t\tif (store && initialState) {\n\t\t\t\treturn store.add(initialState, { id })\n\t\t\t\t\t// Ignore error, assume store already contains state for this widget.\n\t\t\t\t\t.catch(() => undefined)\n\t\t\t\t\t.then(() => factory(options));\n\t\t\t}\n\n\t\t\treturn factory(options);\n\t\t});\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/factories.ts","import { remove } from 'dojo-dom/dom';\nimport { from as arrayFrom } from 'dojo-shim/array';\nimport Promise from 'dojo-shim/Promise';\nimport Set from 'dojo-shim/Set';\n\nimport {\n\tActionDefinition,\n\tActionFactory,\n\tActionLike,\n\tCustomElementDefinition,\n\tStoreDefinition,\n\tStoreFactory,\n\tStoreLike,\n\tWidgetDefinition,\n\tWidgetFactory,\n\tWidgetLike\n} from '../createApp';\nimport { RESOLVE_CONTENTS, ResolveMid } from './moduleResolver';\nimport parseJsonAttribute from './parseJsonAttribute';\n\ninterface JsonObject {\n\t[key: string]: any;\n}\n\ninterface BaseTask {\n\treadonly element: Element;\n}\n\ninterface FactoryResolver {\n\treadonly factory: string;\n}\n\ninterface ImportResolver {\n\treadonly from: string;\n\treadonly importName?: string;\n}\n\ninterface ActionTask extends BaseTask {\n\treadonly id: string;\n\treadonly resolver: FactoryResolver | ImportResolver;\n\treadonly state?: JsonObject;\n\treadonly stateFrom?: string;\n\treadonly type: 'action';\n}\n\ninterface ElementTask extends BaseTask, FactoryResolver {\n\treadonly name: string;\n\treadonly type: 'element';\n}\n\ninterface MultipleActionsTask extends BaseTask {\n\treadonly from: string;\n\treadonly type: 'multiple-actions';\n}\n\ninterface StoreTask extends BaseTask {\n\treadonly id: string;\n\treadonly isDefault: boolean;\n\treadonly options?: JsonObject;\n\treadonly resolver: FactoryResolver | ImportResolver;\n\treadonly type: 'store';\n}\n\ninterface WidgetTask extends BaseTask {\n\treadonly id: string;\n\treadonly listeners?: JsonObject;\n\treadonly options?: JsonObject;\n\treadonly resolver: FactoryResolver | ImportResolver;\n\treadonly state?: JsonObject;\n\treadonly stateFrom?: string;\n\treadonly type: 'widget';\n}\n\ntype Task = ActionTask | ElementTask | MultipleActionsTask | StoreTask | WidgetTask;\n\nfunction isFactoryResolver(resolver: FactoryResolver | ImportResolver): resolver is FactoryResolver {\n\treturn (<any> resolver).factory;\n}\n\nfunction get(element: Element, name: string): string | undefined {\n\tconst value = element.getAttribute(name);\n\treturn value === null ? undefined : value;\n}\n\nconst TAG_NAMES = new Set(['app-action', 'app-actions', 'app-element', 'app-store', 'app-widget']);\n\nconst parsers = {\n\taction(element: Element): ActionTask {\n\t\tlet id = get(element, 'data-uid') || get(element, 'id');\n\t\tconst factory = get(element, 'data-factory');\n\t\tconst from = get(element, 'data-from');\n\t\tconst importName = get(element, 'data-import');\n\t\tconst stateFrom = get(element, 'data-state-from');\n\t\tconst stateJson = get(element, 'data-state');\n\n\t\tif (factory && !id) {\n\t\t\tthrow new Error('app-action requires data-uid or id attribute if data-factory is given');\n\t\t}\n\t\tif (!factory && !from) {\n\t\t\tthrow new Error('app-action requires data-from attribute if data-factory is not given');\n\t\t}\n\t\tif (factory && from) {\n\t\t\tthrow new Error('app-action cannot be used with both data-from and data-factory attributes');\n\t\t}\n\t\tif (stateFrom && !factory) {\n\t\t\tthrow new Error('app-action requires data-factory attribute if data-state-from is given');\n\t\t}\n\t\tif (stateJson && !factory) {\n\t\t\tthrow new Error('app-action requires data-factory attribute if data-state is given');\n\t\t}\n\n\t\tif (from && !id) {\n\t\t\tif (importName) {\n\t\t\t\tid = importName;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = <string> from.split('/').pop();\n\t\t\t}\n\t\t}\n\n\t\tif (!id) {\n\t\t\tthrow new Error(`Could not determine ID for app-action (from=${from} and import=${importName})`);\n\t\t}\n\n\t\tconst resolver = factory ? { factory } : { from: <string> from, importName };\n\t\tconst state = stateJson ? parseJsonAttribute<JsonObject>('data-state', stateJson) : undefined;\n\n\t\treturn {\n\t\t\telement,\n\t\t\tid,\n\t\t\tresolver,\n\t\t\tstate,\n\t\t\tstateFrom,\n\t\t\ttype: 'action'\n\t\t};\n\t},\n\n\tactions(element: Element): MultipleActionsTask {\n\t\tconst from = get(element, 'data-from');\n\t\tif (!from) {\n\t\t\tthrow new Error('app-actions requires data-from attribute');\n\t\t}\n\n\t\treturn {\n\t\t\telement,\n\t\t\tfrom,\n\t\t\ttype: 'multiple-actions'\n\t\t};\n\t},\n\n\telement(element: Element): ElementTask {\n\t\tconst factory = get(element, 'data-factory');\n\t\tconst name = get(element, 'data-name');\n\n\t\tif (!factory) {\n\t\t\tthrow new Error('app-element requires data-factory');\n\t\t}\n\t\tif (!name) {\n\t\t\tthrow new Error('app-element requires data-name');\n\t\t}\n\n\t\treturn {\n\t\t\telement,\n\t\t\tfactory,\n\t\t\tname,\n\t\t\ttype: 'element'\n\t\t};\n\t},\n\n\tstore(element: Element): StoreTask {\n\t\tlet id = get(element, 'data-uid') || get(element, 'id');\n\t\tconst factory = get(element, 'data-factory');\n\t\tconst from = get(element, 'data-from');\n\t\tconst importName = get(element, 'data-import');\n\t\tconst type = <'action' | 'widget' | undefined> get(element, 'data-type');\n\t\tconst optionsJson = get(element, 'data-options');\n\n\t\tif (factory && !id && !type) {\n\t\t\tthrow new Error('app-store requires data-uid, id or data-type attribute if data-factory is given');\n\t\t}\n\t\tif (!factory && !from) {\n\t\t\tthrow new Error('app-store requires data-from attribute if data-factory is not given');\n\t\t}\n\t\tif (factory && from) {\n\t\t\tthrow new Error('app-store cannot be used with both data-from and data-factory attributes');\n\t\t}\n\t\tif (type && id) {\n\t\t\tthrow new Error('data-type attribute must not be provided if app-store has data-uid or id attribute');\n\t\t}\n\t\tif (type && type !== 'action' && type !== 'widget') {\n\t\t\tthrow new Error('data-type attribute of app-store must have a value of \\'action\\' or \\'widget\\'');\n\t\t}\n\t\tif (optionsJson && !factory) {\n\t\t\tthrow new Error('app-store requires data-factory attribute if data-options is given');\n\t\t}\n\n\t\tif (from && !type && !id) {\n\t\t\tif (importName) {\n\t\t\t\tid = importName;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = <string> from.split('/').pop();\n\t\t\t}\n\t\t}\n\n\t\tif (!type && !id) {\n\t\t\tthrow new Error(`Could not determine ID for app-store (from=${from} and import=${importName})`);\n\t\t}\n\n\t\tconst options = optionsJson ? parseJsonAttribute<JsonObject>('data-options', optionsJson) : undefined;\n\t\tconst resolver = factory ? { factory } : { from: <string> from, importName };\n\n\t\tconst isDefault = Boolean(type);\n\t\tif (isDefault) {\n\t\t\tid = type;\n\t\t}\n\n\t\treturn {\n\t\t\tid: <string> id,\n\t\t\tisDefault,\n\t\t\telement,\n\t\t\toptions,\n\t\t\tresolver,\n\t\t\ttype: 'store'\n\t\t};\n\t},\n\n\twidget(element: Element): WidgetTask | null {\n\t\tlet id = get(element, 'data-uid') || get(element, 'id');\n\t\tconst factory = get(element, 'data-factory');\n\t\tconst from = get(element, 'data-from');\n\t\tconst importName = get(element, 'data-import');\n\t\tconst listenersJson = get(element, 'data-listeners');\n\t\tconst optionsJson = get(element, 'data-options');\n\t\tconst stateFrom = get(element, 'data-state-from');\n\t\tconst stateJson = get(element, 'data-state');\n\n\t\tif (stateFrom && !factory) {\n\t\t\tthrow new Error('app-widget requires data-factory attribute if data-state-from is given');\n\t\t}\n\t\tif (listenersJson && !factory) {\n\t\t\tthrow new Error('app-widget requires data-factory attribute if data-listeners is given');\n\t\t}\n\t\tif (optionsJson && !factory) {\n\t\t\tthrow new Error('app-widget requires data-factory attribute if data-options is given');\n\t\t}\n\t\tif (stateJson && !factory) {\n\t\t\tthrow new Error('app-widget requires data-factory attribute if data-state is given');\n\t\t}\n\n\t\t// Without factory or from, assume the widget has already been defined elsewhere.\n\t\tif (!factory && !from) {\n\t\t\treturn null;\n\t\t}\n\t\tif (factory && from) {\n\t\t\tthrow new Error('app-widget cannot be used with both data-from and data-factory attributes');\n\t\t}\n\n\t\tif (factory && !id) {\n\t\t\tthrow new Error('app-widget requires data-uid or id attribute if data-factory is given');\n\t\t}\n\n\t\tif (from && !id) {\n\t\t\tif (importName) {\n\t\t\t\tid = importName;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = from.split('/').pop();\n\t\t\t}\n\t\t}\n\n\t\tif (!id) {\n\t\t\tthrow new Error(`Could not determine ID for app-widget (from=${from} and import=${importName})`);\n\t\t}\n\n\t\tconst listeners = listenersJson ? parseJsonAttribute<JsonObject>('data-listeners', listenersJson) : undefined;\n\t\tconst options = optionsJson ? parseJsonAttribute<JsonObject>('data-options', optionsJson) : undefined;\n\t\tconst state = stateJson ? parseJsonAttribute<JsonObject>('data-state', stateJson) : undefined;\n\n\t\tconst resolver = factory ? { factory } : { from: <string> from, importName };\n\n\t\treturn {\n\t\t\telement,\n\t\t\tid,\n\t\t\tlisteners,\n\t\t\toptions,\n\t\t\tresolver,\n\t\t\tstate,\n\t\t\tstateFrom,\n\t\t\ttype: 'widget'\n\t\t};\n\t}\n};\n\nfunction getRegistrationTasks(root: Element): Task[] {\n\tconst allElements: Element[] = arrayFrom(root.getElementsByTagName('*'));\n\tallElements.unshift(root); // Be inclusive!\n\n\tconst tasks: Task[] = [];\n\tfor (const element of allElements) {\n\t\tlet name: string | undefined;\n\n\t\tconst tagName = element.tagName.toLowerCase();\n\t\tif (TAG_NAMES.has(tagName)) {\n\t\t\tname = tagName;\n\t\t}\n\t\telse {\n\t\t\tconst attrIs = (get(element, 'is') || '').toLowerCase();\n\t\t\tif (TAG_NAMES.has(attrIs)) {\n\t\t\t\tname = attrIs;\n\t\t\t}\n\t\t}\n\n\t\tlet task: Task | null = null;\n\t\tswitch (name) {\n\t\t\tcase 'app-action':\n\t\t\t\ttask = parsers.action(element);\n\t\t\t\tbreak;\n\t\t\tcase 'app-actions':\n\t\t\t\ttask = parsers.actions(element);\n\t\t\t\tbreak;\n\t\t\tcase 'app-element':\n\t\t\t\ttask = parsers.element(element);\n\t\t\t\tbreak;\n\t\t\tcase 'app-store':\n\t\t\t\ttask = parsers.store(element);\n\t\t\t\tbreak;\n\t\t\tcase 'app-widget':\n\t\t\t\ttask = parsers.widget(element);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (task) {\n\t\t\ttasks.push(task);\n\t\t}\n\t}\n\n\treturn tasks;\n}\n\nfunction createActionDefinition(\n\tresolveMid: ResolveMid,\n\t{\n\t\tid,\n\t\tresolver,\n\t\tstate,\n\t\tstateFrom\n\t}: ActionTask\n): ActionDefinition {\n\treturn {\n\t\tid,\n\t\tfactory(options) {\n\t\t\tif (isFactoryResolver(resolver)) {\n\t\t\t\treturn resolveMid<ActionFactory>(resolver.factory).then((factory) => {\n\t\t\t\t\treturn factory(options);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resolveMid<ActionLike>(resolver.from, resolver.importName || 'default');\n\t\t\t}\n\t\t},\n\t\tstate,\n\t\tstateFrom\n\t};\n}\n\nfunction loadMultipleActions(\n\tresolveMid: ResolveMid,\n\t{ from }: MultipleActionsTask\n): Promise<ActionDefinition[]> {\n\treturn resolveMid<{ [member: string]: ActionLike }>(from, RESOLVE_CONTENTS).then((contents) => {\n\t\treturn Object.keys(contents).map((member) => {\n\t\t\treturn {\n\t\t\t\tid: member,\n\t\t\t\tinstance: contents[member]\n\t\t\t};\n\t\t});\n\t});\n}\n\nfunction createCustomElementDefinition(\n\tresolveMid: ResolveMid,\n\t{\n\t\tfactory,\n\t\tname\n\t}: ElementTask\n): CustomElementDefinition {\n\treturn {\n\t\tfactory(options) {\n\t\t\treturn resolveMid<WidgetFactory>(factory)\n\t\t\t\t.then((factory) => factory(options));\n\t\t},\n\t\tname\n\t};\n}\n\nfunction createStoreDefinition(\n\tresolveMid: ResolveMid,\n\t{\n\t\tid,\n\t\toptions,\n\t\tresolver\n\t}: StoreTask\n): StoreDefinition {\n\treturn {\n\t\tid,\n\t\tfactory(options: any) {\n\t\t\tif (isFactoryResolver(resolver)) {\n\t\t\t\treturn resolveMid<StoreFactory>(resolver.factory)\n\t\t\t\t\t.then((factory) => factory(options));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resolveMid<StoreLike>(resolver.from, resolver.importName || 'default');\n\t\t\t}\n\t\t},\n\t\toptions\n\t};\n}\n\nfunction createWidgetDefinition(\n\tresolveMid: ResolveMid,\n\t{\n\t\tid,\n\t\tlisteners,\n\t\toptions,\n\t\tresolver,\n\t\tstate,\n\t\tstateFrom\n\t}: WidgetTask\n): WidgetDefinition {\n\treturn {\n\t\tid,\n\t\tfactory(options) {\n\t\t\tif (isFactoryResolver(resolver)) {\n\t\t\t\treturn resolveMid<WidgetFactory>(resolver.factory)\n\t\t\t\t\t.then((factory) => factory(options));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn resolveMid<WidgetLike>(resolver.from, resolver.importName || 'default');\n\t\t\t}\n\t\t},\n\t\tlisteners,\n\t\toptions,\n\t\tstate,\n\t\tstateFrom\n\t};\n}\n\n/**\n * Provides resulting definition objects that were extracted from the root element.\n */\nexport interface Result {\n\t/**\n\t * Actions that should be loaded into the app.\n\t */\n\tactions: ActionDefinition[];\n\n\t/**\n\t * Custom elements that should be loaded into the app.\n\t */\n\tcustomElements: CustomElementDefinition[];\n\n\t/**\n\t * Default action and widget stores that should be loaded into the app.\n\t *\n\t * The 'action' ID indicates that the definition is for the default action store.\n\t * The 'widget' ID indicates that the definition is for the default widget store.\n\t */\n\tdefaultStores: StoreDefinition[];\n\n\t/**\n\t * Stores that should be loaded into the app.\n\t */\n\tstores: StoreDefinition[];\n\n\t/**\n\t * Widgets that should be loaded into the app.\n\t */\n\twidgets: WidgetDefinition[];\n}\n\n/**\n * Extract action, custom element, store and widget definitions that should be loaded into the app.\n *\n * @param resolveMid Function to asynchronously resolve a module identifier\n * @param root The element within which registration elements can be found\n * @return A promise for the definition objects\n */\nexport default function extractRegistrationElements(resolveMid: ResolveMid, root: Element): Promise<Result> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst result: Result = {\n\t\t\tactions: [],\n\t\t\tcustomElements: [],\n\t\t\tdefaultStores: [],\n\t\t\tstores: [],\n\t\t\twidgets: []\n\t\t};\n\t\tconst promises: Promise<void>[] = [];\n\n\t\tfor (const task of getRegistrationTasks(root)) {\n\t\t\tswitch (task.type) {\n\t\t\t\tcase 'action':\n\t\t\t\t\tresult.actions.push(createActionDefinition(resolveMid, <ActionTask> task));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'element':\n\t\t\t\t\tresult.customElements.push(createCustomElementDefinition(resolveMid, <ElementTask> task));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'multiple-actions': {\n\t\t\t\t\tconst promise = loadMultipleActions(resolveMid, <MultipleActionsTask> task)\n\t\t\t\t\t\t.then((actions) => {\n\t\t\t\t\t\t\tresult.actions.push(...actions);\n\t\t\t\t\t\t});\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'store': {\n\t\t\t\t\tconst { isDefault } = <StoreTask> task;\n\t\t\t\t\tconst definition = createStoreDefinition(resolveMid, <StoreTask> task);\n\t\t\t\t\tif (isDefault) {\n\t\t\t\t\t\tresult.defaultStores.push(definition);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult.stores.push(definition);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'widget':\n\t\t\t\t\tresult.widgets.push(createWidgetDefinition(resolveMid, <WidgetTask> task));\n\t\t\t\t\t// Forcibly add the possibly derived ID to the element, so the <app-widget> can be realized.\n\t\t\t\t\ttask.element.setAttribute('data-uid', (<WidgetTask> task).id);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (task.type !== 'widget') {\n\t\t\t\tremove(task.element);\n\t\t\t}\n\t\t}\n\n\t\tif (promises.length > 0) {\n\t\t\tPromise.all(promises)\n\t\t\t\t.then(() => resolve(result))\n\t\t\t\t.catch(reject);\n\t\t}\n\t\telse {\n\t\t\tresolve(result);\n\t\t}\n\t});\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/extractRegistrationElements.ts","import { ComposeFactory } from 'dojo-compose/compose';\nimport Promise from 'dojo-shim/Promise';\nimport { Child } from 'dojo-widgets/mixins/interfaces';\n\nimport {\n\tActionLike,\n\tIdentifier,\n\tReadOnlyRegistry,\n\tStoreLike,\n\tWidgetFactoryOptions,\n\tWidgetLike\n} from '../createApp';\n\n/**\n * Registry to (asynchronously) get instances by their ID.\n */\nexport interface Registry<I, T> {\n\t/**\n\t * Asynchronously get an instance by its ID.\n\t *\n\t * @param id Identifier for the instance that is to be retrieved\n\t * @return A promise for the instance. The promise rejects if no instance was found.\n\t */\n\tget(id: I): Promise<T>;\n\n\t/**\n\t * Look up the identifier for which the given value has been registered.\n\t *\n\t * Throws if the value hasn't been registered.\n\t *\n\t * @param value The value\n\t * @return The identifier\n\t */\n\tidentify(value: T): I;\n}\n\ninterface UnderlyingRegistry {\n\tgetAction(id: Identifier): Promise<ActionLike>;\n\tidentifyAction(action: ActionLike): Identifier;\n\tgetStore(id: Identifier | symbol): Promise<StoreLike>;\n\tidentifyStore(store: StoreLike): Identifier | symbol;\n\tcreateWidget<\n\t\tU extends Child,\n\t\tO extends WidgetFactoryOptions\n\t>(factory: ComposeFactory<U, O>, options?: O): Promise<[string, U]>;\n\tgetWidget(id: Identifier): Promise<WidgetLike>;\n\thasWidget(id: Identifier): Promise<boolean>;\n\tidentifyWidget(widget: WidgetLike): Identifier;\n}\n\n/**\n * Registry to (asynchronously) get widget instances by their ID, as well as create new instances that are then added\n * to the registry.\n */\nexport interface WidgetRegistry<I, T extends Child> extends Registry<I, T> {\n\t/**\n\t * Create a new instance and add it to the registry.\n\t *\n\t * @param factory Factory to create the new instance\n\t * @param options Options to be passed to the factory. Automatically extended with the `registryProvider` option,\n\t *   and the `stateFrom` option if an `id` was present and the application factory has a default store.\n\t * @return A promise for a tuple containing the ID of the created widget, and the widget instance itself.\n\t */\n\tcreate<U extends T, O>(factory: ComposeFactory<U, O>, options?: O): Promise<[string, U]>;\n\n\t/**\n\t * Checks if an instance exists in the registry for a given identifier.\n\t *\n\t * @param id identifier of the instance to check exists in the registry.\n\t * @return a Promise that resolves to a boolean indicating if the instance exists in the registry.\n\t */\n\thas(id: I): Promise<boolean>;\n}\n\n/**\n * Provides access to read-only registries for actions, stores and widgets.\n */\nexport default class RegistryProvider {\n\tprivate actionRegistry: Registry<Identifier, ActionLike>;\n\tprivate storeRegistry: Registry<Identifier | symbol, StoreLike>;\n\tprivate widgetRegistry: WidgetRegistry<Identifier, WidgetLike>;\n\n\tprivate readonly underlyingRegistry: UnderlyingRegistry;\n\tconstructor(registry: ReadOnlyRegistry) {\n\t\tthis.underlyingRegistry = Object.freeze({\n\t\t\tgetAction: registry.getAction.bind(registry),\n\t\t\tidentifyAction: registry.identifyAction.bind(registry),\n\t\t\tgetStore: registry.getStore.bind(registry),\n\t\t\tidentifyStore: registry.identifyStore.bind(registry),\n\t\t\tcreateWidget: registry.createWidget.bind(registry),\n\t\t\tgetWidget: registry.getWidget.bind(registry),\n\t\t\thasWidget: registry.hasWidget.bind(registry),\n\t\t\tidentifyWidget: registry.identifyWidget.bind(registry)\n\t\t});\n\t}\n\n\t/**\n\t * Get an action, store or widget registry.\n\t *\n\t * @param type The type of registry that is required.\n\t * @return The registry.\n\t */\n\tget(type: 'actions'): Registry<Identifier, ActionLike>;\n\tget(type: 'stores'): Registry<Identifier | symbol, StoreLike>;\n\tget(type: 'widgets'): WidgetRegistry<Identifier, WidgetLike>;\n\tget(type: string): Registry<any, any>;\n\tget(type: string): Registry<any, any> {\n\t\tswitch (type) {\n\t\t\tcase 'actions':\n\t\t\t\treturn this.actionRegistry || (this.actionRegistry = {\n\t\t\t\t\tget: this.underlyingRegistry.getAction,\n\t\t\t\t\tidentify: this.underlyingRegistry.identifyAction\n\t\t\t\t});\n\t\t\tcase 'stores':\n\t\t\t\treturn this.storeRegistry || (this.storeRegistry = {\n\t\t\t\t\tget: this.underlyingRegistry.getStore,\n\t\t\t\t\tidentify: this.underlyingRegistry.identifyStore\n\t\t\t\t});\n\t\t\tcase 'widgets':\n\t\t\t\treturn this.widgetRegistry || (this.widgetRegistry = {\n\t\t\t\t\tcreate: this.underlyingRegistry.createWidget,\n\t\t\t\t\tget: this.underlyingRegistry.getWidget,\n\t\t\t\t\thas: this.underlyingRegistry.hasWidget,\n\t\t\t\t\tidentify: this.underlyingRegistry.identifyWidget\n\t\t\t\t});\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`No such store: ${type}`);\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-app/lib/RegistryProvider.ts","import Map from 'dojo-shim/Map';\nimport WeakMap from 'dojo-shim/WeakMap';\nimport { Handle } from 'dojo-interfaces/core';\n\nconst noop = () => {};\n\ninterface Entry<V> {\n\thandle: Handle;\n\tvalue: V;\n}\n\ninterface State<V> {\n\tentryMap: Map<Identity, Entry<V>>;\n\tidMap: WeakMap<V, Identity>;\n}\n\nconst privateStateMap = new WeakMap<IdentityRegistry<any>, State<any>>();\n\nfunction getState<V>(instance: IdentityRegistry<V>): State<V> {\n\treturn privateStateMap.get(instance);\n}\n\n/**\n * Registry identities can be strings or symbols. Note that the empty string is allowed.\n */\nexport type Identity = string | symbol;\n\n/**\n * A registry of values, mapped by identities.\n */\nexport default class IdentityRegistry<V extends Object> {\n\tconstructor() {\n\t\tprivateStateMap.set(this, {\n\t\t\tentryMap: new Map<Identity, Entry<V>>(),\n\t\t\tidMap: new WeakMap<V, Identity>()\n\t\t});\n\t}\n\n\t/**\n\t * Look up a value by its identifier.\n\t *\n\t * Throws if no value has been registered for the given identifier.\n\t *\n\t * @param id The identifier\n\t * @return The value\n\t */\n\tget(id: Identity): V {\n\t\tconst entry = getState<V>(this).entryMap.get(id);\n\t\tif (!entry) {\n\t\t\tthrow new Error(`Could not find a value for identity '${id.toString()}'`);\n\t\t}\n\n\t\treturn entry.value;\n\t}\n\n\t/**\n\t * Determine whether the value has been registered.\n\t * @param value The value\n\t * @return `true` if the value has been registered, `false` otherwise\n\t */\n\tcontains(value: V): boolean {\n\t\treturn getState<V>(this).idMap.has(value);\n\t}\n\n\t/**\n\t * Remove from the registry the value for a given identifier.\n\t * @param id The identifier\n\t * @return `true` if the value was removed, `false` otherwise\n\t */\n\tdelete(id: Identity): boolean {\n\t\tconst entry = getState<V>(this).entryMap.get(id);\n\t\tif (!entry) {\n\t\t\treturn false;\n\t\t}\n\n\t\tentry.handle.destroy();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Determine whether a value has been registered for the given identifier.\n\t * @param id The identifier\n\t * @return `true` if a value has been registered, `false` otherwise\n\t */\n\thas(id: Identity): boolean {\n\t\treturn getState<V>(this).entryMap.has(id);\n\t}\n\n\t/**\n\t * Look up the identifier for which the given value has been registered.\n\t *\n\t * Throws if the value hasn't been registered.\n\t *\n\t * @param value The value\n\t * @return The identifier otherwise\n\t */\n\tidentify(value: V): Identity {\n\t\tif (!this.contains(value)) {\n\t\t\tthrow new Error('Could not identify non-registered value');\n\t\t}\n\n\t\treturn getState<V>(this).idMap.get(value);\n\t}\n\n\t/**\n\t * Register a new value with a new identity.\n\t *\n\t * Throws if a different value has already been registered for the given identity,\n\t * or if the value has already been registered with a different identity.\n\t *\n\t * @param id The identifier\n\t * @param value The value\n\t * @return A handle for deregistering the value. Note that when called repeatedly with\n\t *   the same identifier and value combination, the same handle is returned\n\t */\n\tregister(id: Identity, value: V): Handle {\n\t\tconst entryMap = getState<V>(this).entryMap;\n\t\tconst existingEntry = entryMap.get(id);\n\t\tif (existingEntry && existingEntry.value !== value) {\n\t\t\tconst str = id.toString();\n\t\t\tthrow new Error(`A value has already been registered for the given identity (${str})`);\n\t\t}\n\n\t\tconst existingId = this.contains(value) ? this.identify(value) : null;\n\t\tif (existingId && existingId !== id) {\n\t\t\tconst str = (<Identity> existingId).toString();\n\t\t\tthrow new Error(`The value has already been registered with a different identity (${str})`);\n\t\t}\n\n\t\t// Adding the same value with the same id is a noop, return the original handle.\n\t\tif (existingEntry && existingId) {\n\t\t\treturn existingEntry.handle;\n\t\t}\n\n\t\tconst handle = {\n\t\t\tdestroy: () => {\n\t\t\t\thandle.destroy = noop;\n\t\t\t\tgetState<V>(this).entryMap.delete(id);\n\t\t\t}\n\t\t};\n\n\t\tentryMap.set(id, { handle, value });\n\t\tgetState<V>(this).idMap.set(value, id);\n\n\t\treturn handle;\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/dojo-core/IdentityRegistry.ts"],"sourceRoot":""}